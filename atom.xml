<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maxw的小站</title>
  
  <subtitle>Maxw学习记录</subtitle>
  <link href="https://mackz-maxw.github.io/atom.xml" rel="self"/>
  
  <link href="https://mackz-maxw.github.io/"/>
  <updated>2025-06-22T20:52:23.275Z</updated>
  <id>https://mackz-maxw.github.io/</id>
  
  <author>
    <name>Mackz-Maxw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>操作系统基础 | 2.4 初试linux内核实验</title>
    <link href="https://mackz-maxw.github.io/2025/06/22/oper_sys4/"/>
    <id>https://mackz-maxw.github.io/2025/06/22/oper_sys4/</id>
    <published>2025-06-22T16:26:14.296Z</published>
    <updated>2025-06-22T20:52:23.275Z</updated>
    
    <content type="html"><![CDATA[<h2id="树莓派镜像下载配置与自定义内核安装流程">树莓派镜像下载、配置与自定义内核安装流程</h2><h3 id="下载并写入指定树莓派镜像">1. 下载并写入指定树莓派镜像</h3><p>为避免因购买或借用的树莓派设备时间不同导致的系统版本不一致，建议大家统一下载指定的树莓派镜像作为起点。</p><ul><li>将 MicroSD 卡插入 USB 读卡器，并连接到你的电脑。</li><li>下载并安装最新版 Raspberry Pi Imager。</li><li>下载课程指定的树莓派镜像：<ahref="https://downloads.raspberrypi.org/raspios_armhf/images/raspios_armhf-2022-01-28/2022-01-28-raspios-bullseye-armhf.zip">2022-01-28-raspios-bullseye-armhf.zip</a>（约1.2GB，解压后近4GB）。</li><li>解压 zip 文件，得到 .img 镜像文件。</li><li>打开 Raspberry Pi Imager，选择“CHOOSE OS”→“Usecustom”，选中刚才解压的 .img 文件。</li><li>选择“CHOOSE SD CARD”，选中你的 MicroSD卡（注意不要选错，否则会清空数据）。</li><li>进入高级设置（齿轮图标，或 Windows 下用Ctrl+Shift+X），建议修改主机名为唯一值（如包含你的用户名），以免与他人冲突。</li><li>勾选“Enable SSH”，选择“Use passwordauthentication”，设置用户名和强密码（建议不要用默认密码）。</li><li>勾选“Set locale settings”，设置时区（如美国中部用America/Chicago），键盘布局选 us。</li><li>点击“Save”，然后点击“WRITE”写入镜像。</li><li>写入完成后，卸载 MicroSD 卡，插入树莓派并开机。</li></ul><hr /><h3 id="首次启动与-ssh-连接">2. 首次启动与 SSH 连接</h3><ul><li>树莓派首次启动可能需要几分钟，启动后通过 SSH 连接（如 sshpiuser@pihost，用户名和主机名为你设置的）。</li><li>若主机名无法解析，可在路由器管理页面查找树莓派的 IP 地址，再用 ssh连接。</li></ul><hr /><h3 id="初始设置与系统升级">3. 初始设置与系统升级</h3><ul><li>首次登录会看到“Welcome to the RaspberryPi”向导，按提示设置国家、语言、时区、键盘等。</li><li>可能会再次提示设置密码，可直接关闭。</li><li>为防止欢迎界面反复出现，运行： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt purge piwiz</span><br></pre></td></tr></table></figure></li><li>升级系统和驱动： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure></li><li>升级完成后重启树莓派。</li></ul><hr /><h3 id="网络设置与信息收集">4. 网络设置与信息收集</h3><ul><li>连接 WiFi，打开终端，运行： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig wlan0</span><br></pre></td></tr></table></figure> 记录 MAC 地址（ether后面的六组十六进制数）。</li><li>运行： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostname -I</span><br></pre></td></tr></table></figure> 记录 IP 地址。</li></ul><hr /><h3 id="传输并安装自编译内核与模块">5. 传输并安装自编译内核与模块</h3><ul><li>用 ssh 连接学校提供的linux工作平台，进入你编译内核的目录：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /project/scratch01/compile/<span class="string">&quot;your username&quot;</span>/linux_source</span><br></pre></td></tr></table></figure></li><li>打包模块和内核启动文件： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -C modules/lib -czf modules.tgz modules</span><br><span class="line">tar -C linux/arch/arm -czf boot.tgz boot</span><br></pre></td></tr></table></figure></li><li>在树莓派上新建 linux_source 目录，进入后用 sftp 下载上述两个压缩包：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sftp [学校统一登陆平台key]@shell.cec.学校曾用简称.edu</span><br><span class="line"><span class="built_in">cd</span> /project/scratch01/compile/<span class="string">&quot;your username&quot;</span>/linux_source</span><br><span class="line">get modules.tgz</span><br><span class="line">get boot.tgz</span><br><span class="line">quit</span><br></pre></td></tr></table></figure></li><li>备份 <code>/usr/lib/modules</code> 和 <code>/boot</code> 目录（或<code>/lib/modules</code>，视系统而定）： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> -r /usr/lib/modules ~/Desktop/modules_backup</span><br><span class="line">sudo <span class="built_in">cp</span> -r /boot ~/Desktop/boot_backup</span><br></pre></td></tr></table></figure></li><li>解压并安装新内核和模块： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf modules.tgz</span><br><span class="line">tar -xzf boot.tgz</span><br><span class="line"><span class="built_in">cd</span> modules</span><br><span class="line">sudo <span class="built_in">cp</span> -rd * /usr/lib/modules   <span class="comment"># 或 /lib/modules</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">sudo <span class="built_in">cp</span> boot/dts/*.dtb /boot/</span><br><span class="line">sudo <span class="built_in">cp</span> boot/dts/overlays/*.dtb* /boot/overlays</span><br><span class="line">sudo <span class="built_in">cp</span> boot/dts/overlays/README /boot/overlays</span><br></pre></td></tr></table></figure></li><li>树莓派 3B+： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> boot/zImage /boot/kernel7.img</span><br></pre></td></tr></table></figure></li><li>树莓派 4/4B： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> boot/zImage /boot/kernel7l.img</span><br></pre></td></tr></table></figure></li></ul><hr /><h3 id="验证新内核">6. 验证新内核</h3><ul><li>重启树莓派，运行： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure>检查输出是否包含你设置的本地版本字符串、编译日期等。</li><li>若未生效，编辑 <code>/boot/config.txt</code>，在 <code>[pi4]</code>段落前加一行： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm_64bit=0</span><br></pre></td></tr></table></figure> 再重启并用 <code>uname -a</code>检查。</li></ul><hr /><h3 id="备份与后续建议">7. 备份与后续建议</h3><ul><li>建议用 svn、git等工具备份你的代码，也可在多台树莓派间做冗余，防止系统崩溃或锁死导致数据丢失。</li><li><code>sudo passwd root</code>更新root密码（忘记密码用）</li><li><code>sudo raspi-config</code>中可以更改主机名</li><li>在树莓派的桌面环境中，可以使用快捷键 Ctrl + Alt + T快速打开终端</li></ul><h3 id="用户管理">用户管理</h3><ul><li><code>sudo adduser 新用户名</code>创建新用户</li><li><code>usermod -aG sudo username</code>将username用户加入sudoers组</li><li>执行visudo命令并在文件中添加<code>username  ALL=(ALL) NOPASSWD:ALL</code>-赋予username用户执行所有sudo命令权限，不需要密码提示</li><li><code>sudo userdel --remove --force pi</code>删除默认账号</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2
id=&quot;树莓派镜像下载配置与自定义内核安装流程&quot;&gt;树莓派镜像下载、配置与自定义内核安装流程&lt;/h2&gt;
&lt;h3 id=&quot;下载并写入指定树莓派镜像&quot;&gt;1. 下载并写入指定树莓派镜像&lt;/h3&gt;
&lt;p&gt;为避免因购买或借用的树莓派设备时间不同导致的系统版本不一致，建议大家统一</summary>
      
    
    
    
    <category term="os basic" scheme="https://mackz-maxw.github.io/categories/os-basic/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统基础 | 2.3 初试linux内核实验</title>
    <link href="https://mackz-maxw.github.io/2025/06/21/oper_sys3/"/>
    <id>https://mackz-maxw.github.io/2025/06/21/oper_sys3/</id>
    <published>2025-06-22T00:53:37.040Z</published>
    <updated>2025-06-22T00:54:50.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="树莓派-linux-内核源码下载与编译流程">树莓派 Linux内核源码下载与编译流程</h2><h3 id="下载适用于树莓派的内核源码">1. 下载适用于树莓派的内核源码</h3><p>一般项目可以直接去 <a href="https://kernel.org">kernel.org</a> 下载Linux 源码，但本课程针对树莓派，需要用树莓派官方维护的内核版本（在 <ahref="https://github.com/raspberrypi">https://github.com/raspberrypi</a>）。</p><p>在你的 <code>/project/scratch01/compile/user-name/</code>目录下，新建 <code>linux_source</code>文件夹用于存放源码和编译文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> linux_source</span><br><span class="line"><span class="built_in">cd</span> linux_source</span><br></pre></td></tr></table></figure><p>下载指定版本的树莓派内核源码（此过程可能需要20-30分钟）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/raspberrypi/linux/archive/raspberrypi-kernel_1.20210527-1.tar.gz</span><br></pre></td></tr></table></figure><p>解压源码包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf raspberrypi-kernel_1.20210527-1.tar.gz</span><br></pre></td></tr></table></figure><p>解压后会得到一个新目录，建议用 <code>mv</code> 命令重命名为<code>linux</code>，便于后续操作。解压完成后请删除 <code>.tar.gz</code>文件以节省空间。</p><p>进入 <code>linux</code> 目录，运行以下命令查看内核版本：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make kernelversion</span><br></pre></td></tr></table></figure><p>并用文本编辑器（如 emacs、vim、nano）打开<code>Makefile</code>，查看前几行定义的内核版本常量，记录<code>NAME</code> 常量的值。</p><hr /><h3 id="针对树莓派-44b-的设备树修改">2. 针对树莓派 4/4B的设备树修改</h3><p>如果你使用的是 Raspberry Pi 4 或 4B，需要修改设备树文件<code>arch/arm/boot/dts/bcm2711.dtsi</code>，找到 <code>arm-pmu</code>条目，将 <code>compatible</code> 行改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compatible = <span class="string">&quot;arm,cortex-a72-pmu&quot;</span>, <span class="string">&quot;arm,cortex-a15-pmu&quot;</span>, <span class="string">&quot;arm,armv8-pmuv3&quot;</span>;</span><br></pre></td></tr></table></figure><hr /><h3 id="配置交叉编译环境">3. 配置交叉编译环境</h3><p>添加交叉编译器和新版 gcc 到 PATH（并将以下两行添加到<code>~/.bashrc</code> 文件末尾，确保下次登录自动生效）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">module add arm-rpi</span><br><span class="line">module add gcc-8.3.0</span><br></pre></td></tr></table></figure><hr /><h3 id="配置内核">4. 配置内核</h3><p>对于 Raspberry Pi 3B+，运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfig</span><br></pre></td></tr></table></figure><p>对于 Raspberry Pi 4/4B，运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2711_defconfig</span><br></pre></td></tr></table></figure><p>这会生成树莓派的默认内核配置。</p><hr /><h3 id="自定义内核配置">5. 自定义内核配置</h3><p>进入菜单配置界面：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig</span><br></pre></td></tr></table></figure><ul><li>在 "General setup" -&gt; "Local version" 里，添加你的唯一标识（如<code>-v7</code> 或 <code>-v7l</code> 后面加你的名字，无空格）。</li><li>修改 "Preemption Model" 选项为 "Preemptible Kernel (Low-LatencyDesktop)"，以获得更低延迟的抢占模型。</li><li>启用 ARM 性能监控单元驱动（"Kernel Performance Events andCounters"），并确保 "Profiling support" 也已启用。</li><li>任选一个有趣的选项，按 <code>H</code>键查看简介，记录该选项的名称、简介和符号（symbol），并简述为何选择"Preemptible Kernel (Low-LatencyDesktop)"（提示：该模式适合需要低延迟响应的场景，如桌面或实时应用）。</li></ul><p>保存并退出配置。</p><hr /><h3 id="编译内核">6. 编译内核</h3><p>记录编译开始和结束时间：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span>&gt;&gt;time.txt; make -j8 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- zImage modules dtbs; <span class="built_in">date</span>&gt;&gt;time.txt</span><br></pre></td></tr></table></figure><p>编译完成后，创建用于存放模块的目录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ../modules</span><br></pre></td></tr></table></figure><p>安装内核模块：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j8 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- INSTALL_MOD_PATH=../modules modules_install</span><br></pre></td></tr></table></figure><hr /><h3 id="回答与说明">7. 回答与说明</h3><ul><li>用 <code>cat time.txt</code> 查看编译所用时间。</li><li>说明为何要用交叉编译器：因为 linuxlab服务器的架构与树莓派不同，必须用交叉编译器生成适用于 ARM架构的内核和模块。</li></ul><hr /><p><strong>总结</strong><br />本流程涵盖了树莓派专用 Linux内核源码的下载、解压、配置、定制、编译和模块安装，并介绍了如何设置交叉编译环境和设备树修改。通过这些步骤，你可以为树莓派编译和定制属于自己的Linux 内核。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;树莓派-linux-内核源码下载与编译流程&quot;&gt;树莓派 Linux
内核源码下载与编译流程&lt;/h2&gt;
&lt;h3 id=&quot;下载适用于树莓派的内核源码&quot;&gt;1. 下载适用于树莓派的内核源码&lt;/h3&gt;
&lt;p&gt;一般项目可以直接去 &lt;a href=&quot;https://kern</summary>
      
    
    
    
    <category term="os basic" scheme="https://mackz-maxw.github.io/categories/os-basic/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统基础 | 2.2 linux内核与用户空间的不同</title>
    <link href="https://mackz-maxw.github.io/2025/06/20/oper_sys2/"/>
    <id>https://mackz-maxw.github.io/2025/06/20/oper_sys2/</id>
    <published>2025-06-21T02:18:37.358Z</published>
    <updated>2025-06-22T00:17:17.060Z</updated>
    
    <content type="html"><![CDATA[<h2id="与众不同的野兽内核与用户空间的区别">与众不同的“野兽”：内核与用户空间的区别</h2><p>Linux内核与普通用户空间程序相比，有许多独特之处。这些差异并不一定让内核开发更难，但确实让它与用户空间开发大不相同。内核开发有一些“特殊规则”，有些显而易见，有些则不那么直观。主要区别包括：</p><ol type="1"><li><strong>内核无法使用 C 标准库（libc）和标准 C 头文件。</strong></li><li><strong>内核使用 GNU C 语言编写。</strong></li><li><strong>内核没有用户空间的内存保护机制。</strong></li><li><strong>内核中不能轻易执行浮点运算。</strong></li><li><strong>内核每个进程的栈空间很小且固定。</strong></li><li><strong>由于内核有异步中断、支持抢占和多处理器（SMP），因此同步和并发问题非常重要。</strong></li><li><strong>可移植性很重要。</strong></li></ol><p>下面简要解释这些差异：</p><hr /><h3 id="没有-libc-或标准头文件">没有 libc 或标准头文件</h3><p>与用户空间程序不同，内核不会链接标准 C库（libc）或其他外部库。主要原因是速度和体积——完整的 C库太大、效率太低，不适合内核使用。</p><p>不用担心，内核自己实现了很多常用的 libc函数。例如，常见的字符串操作函数在 <code>lib/string.c</code>中实现，只需包含 <code>&lt;linux/string.h&gt;</code>头文件即可使用。</p><h4 id="头文件">头文件</h4><p>内核源码只能包含内核源码树中的头文件，不能引用外部头文件或库。<br />- 基础头文件位于源码根目录的 <code>include/</code>目录下。例如，<code>&lt;linux/inotify.h&gt;</code> 实际路径为<code>include/linux/inotify.h</code>。 - 架构相关的头文件位于<code>arch/&lt;architecture&gt;/include/asm</code>，如 x86 架构下为<code>arch/x86/include/asm</code>，引用时用<code>&lt;asm/ioctl.h&gt;</code>。</p><h4 id="没有-printf用-printk">没有 printf()，用 printk()</h4><p>内核没有 <code>printf()</code>，但提供了类似的 <code>printk()</code>用于内核日志输出。例如： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printk(<span class="string">&quot;Hello world! A string &#x27;%s&#x27; and an integer &#x27;%d&#x27;\n&quot;</span>, str, i);</span><br></pre></td></tr></table></figure> 与 <code>printf()</code>不同，<code>printk()</code> 可以指定优先级（priority flag），用于syslogd 判断消息显示位置。例如： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printk(KERN_ERR <span class="string">&quot;this is an error!\n&quot;</span>);</span><br></pre></td></tr></table></figure>注意：<code>KERN_ERR</code>和消息之间没有逗号，这是因为优先级标志是字符串宏，编译时会自动拼接。</p><h3 id="gnu-c">GNU C</h3><p>和大多数 Unix 内核一样，Linux 内核主要用 C 语言编写。但它并不是严格的ANSI C，而是大量使用了 gcc（GNU编译器套件）提供的各种语言扩展。内核开发者会用到 ISO C99 和 GNU C的扩展特性，这使得 Linux 内核基本只能用 gcc 编译（近年 Intel C编译器也支持了大部分 gcc 特性，可以编译内核）。目前推荐使用 gcc 4.4或更高版本。</p><p>C99 的扩展比较常见，而 GNU C 的扩展则是 Linux 内核代码区别于普通 C项目的重要原因。下面介绍几个常见的 GNU C 扩展：</p><h4 id="内联函数inline-functions">内联函数（Inline Functions）</h4><p>C99 和 GNU C 都支持内联函数（inlinefunction）。内联函数会在每个调用点直接插入函数体，避免了函数调用和返回的开销（如寄存器保存/恢复），有利于编译器整体优化调用者和被调用者的代码。但缺点是会增加代码体积和内存消耗。</p><p>内核开发者通常只对小型、对性能要求高的函数使用内联。大函数或不常用的函数不建议内联。</p><p>内联函数的声明方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">wolf</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> tail_size)</span></span><br></pre></td></tr></table></figure><ul><li><code>static inline</code> 关键字用于定义内联函数。</li><li>内联函数的声明要在使用前，否则编译器无法内联。</li><li>通常内联函数会放在头文件中（因为是 static，不会导出符号）。</li></ul><p>内核更倾向于用内联函数而不是复杂的宏，因为内联函数有类型安全和可读性好等优点。</p><h4 id="内联汇编inline-assembly">内联汇编（Inline Assembly）</h4><p>gcc 支持在 C代码中嵌入汇编指令，这在与硬件密切相关的内核代码中很有用。用法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> low, high;</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;rdtsc&quot;</span> : <span class="string">&quot;=a&quot;</span> (low), <span class="string">&quot;=d&quot;</span> (high))</span>;</span><br><span class="line"><span class="comment">/* low 和 high 现在分别保存了 64 位 tsc 的低 32 位和高 32 位 */</span></span><br></pre></td></tr></table></figure><ul><li><code>asm</code> 关键字用于插入汇编代码。</li><li>这种用法主要用于体系结构相关或对性能极致要求的代码。</li><li>大部分内核代码还是用 C 语言编写，汇编只用于底层和关键路径。</li></ul><h4 id="分支预测注解branch-annotation">分支预测注解（BranchAnnotation）</h4><p>gcc提供了分支预测指令，可以告诉编译器某个条件分支更可能被执行，从而优化生成的代码。内核通过<code>likely()</code> 和 <code>unlikely()</code> 宏来使用这些特性。</p><p>例如： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (unlikely(error)) &#123;</span><br><span class="line">    <span class="comment">/* 这里假设 error 很少为真 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (likely(success)) &#123;</span><br><span class="line">    <span class="comment">/* 这里假设 success 几乎总为真 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> - 只有在分支方向非常明确时才建议使用这些宏。 -如果预测正确，可以提升性能；预测错误则可能降低性能。 -在内核中，<code>unlikely()</code>常用于错误处理分支，因为大多数情况下不会出错。</p><h3 id="没有内存保护">没有内存保护</h3><p>当用户空间程序非法访问内存时，内核可以捕获错误，发送 SIGSEGV信号并终止该进程。但如果内核自身非法访问内存，后果就不可控了（毕竟，谁来保护内核呢？）。内核中的内存违规会导致oops（严重内核错误）。因此，在内核中绝不能非法访问内存，比如解引用 NULL指针——在内核里，这样的错误代价更高！</p><p>另外，内核内存是不可换页的（notpageable），即内核占用的每一字节物理内存都不能被换出。你在内核里多用一点内存，系统可用物理内存就少一点。每次想给内核加新功能时，请记住这一点！</p><h3 id="不能轻易使用浮点运算">不能（轻易）使用浮点运算</h3><p>用户空间进程使用浮点指令时，内核会负责从整数模式切换到浮点模式。具体做法依赖于体系结构，通常是通过陷阱（trap）实现的。</p><p>但内核自身不能像用户空间那样方便地使用浮点运算，因为内核无法轻松地“陷阱”自己。内核里用浮点数需要手动保存和恢复浮点寄存器等操作，非常麻烦。<strong>简而言之：不要在内核里用浮点运算！</strong>除极少数特殊情况外，内核代码中基本没有浮点操作。</p><h3 id="小而固定的栈空间">小而固定的栈空间</h3><p>用户空间可以在栈上分配大量变量，包括大结构体和大数组，因为用户空间的栈很大且可以动态增长。但内核栈既不大也不能动态扩展，而是小且固定的。</p><ul><li>栈的具体大小依赖于体系结构。例如 x86 架构下，栈大小可在编译时配置为4KB 或 8KB。</li><li>通常，32 位系统为 8KB，64 位系统为16KB，每个进程有自己的内核栈，这个大小是固定的。</li></ul><p>因此，内核开发时要避免在栈上分配大对象。</p><h3 id="同步与并发">同步与并发</h3><p>内核容易出现竞态条件（racecondition）。与单线程的用户空间程序不同，内核有多种并发访问共享资源的情况，必须通过同步机制防止竞态：</p><ul><li>Linux是抢占式多任务操作系统，进程会被调度器随时切换，内核需要在这些任务间同步。</li><li>Linux支持对称多处理（SMP），多个处理器上的内核代码可能同时访问同一资源。</li><li>中断是异步发生的，可能在访问资源时被打断，导致中断处理程序也访问同一资源。</li><li>内核本身是可抢占的，内核代码可能被抢占，切换到另一个访问同一资源的代码。</li></ul><p>常见的同步机制有自旋锁（spinlock）和信号量（semaphore）。后续章节会详细介绍。</p><h3 id="可移植性的重要性">可移植性的重要性</h3><p>虽然用户空间程序不一定要追求可移植性，但 Linux作为一个可移植操作系统，必须保证代码能在多种体系结构上正确编译和运行。体系结构相关的代码要放在专门的目录下，体系结构无关的代码要保持通用。</p><p>一些基本规则包括：保持字节序中立、支持 64位、不要假设字长或页面大小等。后续章节会详细讨论可移植性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2
id=&quot;与众不同的野兽内核与用户空间的区别&quot;&gt;与众不同的“野兽”：内核与用户空间的区别&lt;/h2&gt;
&lt;p&gt;Linux
内核与普通用户空间程序相比，有许多独特之处。这些差异并不一定让内核开发更难，但确实让它与用户空间开发大不相同。内核开发有一些“特殊规则”，有些显而易见</summary>
      
    
    
    
    <category term="os basic" scheme="https://mackz-maxw.github.io/categories/os-basic/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统基础 | 2. 初试linux内核</title>
    <link href="https://mackz-maxw.github.io/2025/06/20/oper_sys1/"/>
    <id>https://mackz-maxw.github.io/2025/06/20/oper_sys1/</id>
    <published>2025-06-20T22:57:37.115Z</published>
    <updated>2025-06-22T00:44:08.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内核源码相关">内核源码相关</h2><h3 id="获取内核源码">获取内核源码</h3><p>当前的 Linux 源代码总是可以在 <ahref="http://www.kernel.org">http://www.kernel.org</a>官方网站上以完整的 tarball（用 tar命令创建的归档文件）和增量补丁的形式获得。 可以利用<ahref="https://elixir.bootlin.com/linux/v5.10.17/source">Elixir CrossReferencer</a>网站在线查看源码</p><h4 id="使用-git">使用 Git</h4><p>你可以用 Git 获取 Linus 主线最新的源码树： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git</span><br></pre></td></tr></table></figure>检出后，可以用如下命令更新你的源码树到 Linus 的最新版本：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></p><h4 id="安装内核源码">安装内核源码</h4><p>内核 tarball 以 GNU zip（gzip）和 bzip2 两种格式发布。bzip2是默认且推荐的格式，因为它通常压缩得更好。bzip2 格式的内核包名为linux-x.y.z.tar.bz2，其中 x.y.z是内核版本号。下载源码后，解压和解包很简单。如果你的 tarball 是 bzip2压缩的，运行： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvjf linux-x.y.z.tar.bz2</span><br></pre></td></tr></table></figure> 如果是 gzip 压缩的，运行： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xvzf linux-x.y.z.tar.gz</span><br></pre></td></tr></table></figure>这会将源码解压到 linux-x.y.z 目录。如果你用 git 获取源码，就不需要下载tarball，只需运行 git clone，Git 会自动下载并解包最新源码。</p><h4 id="源码安装与开发位置">源码安装与开发位置</h4><p>内核源码通常安装在<code>/usr/src/linux</code>。但你不应该在这个目录下开发，因为你的 C库可能会链接到这里的内核版本。此外，修改内核源码不应需要 root权限——建议在你的 home 目录下开发，只在安装新内核时用root。即使安装新内核，也不要动 <code>/usr/src/linux</code>。</p><h4 id="使用补丁">使用补丁</h4><p>在 Linux内核社区，补丁是交流的通用语言。你会以补丁的形式分发你的代码更改，也会以补丁的形式接收别人的代码。增量补丁可以让你轻松地从一个内核版本升级到下一个，无需每次都下载完整的大包，只需应用增量补丁即可，节省带宽和时间。要应用增量补丁，在内核源码目录下运行：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch -p1 &lt; ../patch-x.y.z</span><br></pre></td></tr></table></figure> 通常，补丁是针对前一个版本的源码生成的。</p><h3 id="内核源码树结构简介">内核源码树结构简介</h3><p>Linux 内核源码树（sourcetree）被划分为多个目录，每个目录下又包含许多子目录。下表列出了源码树根目录下的主要目录及其说明：</p><table><thead><tr><th>目录（Directory）</th><th>说明（Description）</th></tr></thead><tbody><tr><td>arch</td><td>架构相关源码（不同CPU架构的实现）</td></tr><tr><td>block</td><td>块设备I/O层</td></tr><tr><td>crypto</td><td>加密API</td></tr><tr><td>Documentation</td><td>内核源码文档</td></tr><tr><td>drivers</td><td>设备驱动</td></tr><tr><td>firmware</td><td>某些驱动需要用到的设备固件</td></tr><tr><td>fs</td><td>虚拟文件系统（VFS）及各类文件系统实现</td></tr><tr><td>include</td><td>内核头文件</td></tr><tr><td>init</td><td>内核启动与初始化代码</td></tr><tr><td>ipc</td><td>进程间通信代码</td></tr><tr><td>kernel</td><td>核心子系统（如调度器等）</td></tr><tr><td>lib</td><td>辅助函数库</td></tr><tr><td>mm</td><td>内存管理子系统及虚拟内存</td></tr><tr><td>net</td><td>网络子系统</td></tr><tr><td>samples</td><td>示例和演示代码</td></tr><tr><td>scripts</td><td>构建内核用的脚本</td></tr><tr><td>security</td><td>Linux安全模块</td></tr><tr><td>sound</td><td>声音子系统</td></tr><tr><td>usr</td><td>早期用户空间代码（如initramfs）</td></tr><tr><td>tools</td><td>内核开发相关工具</td></tr><tr><td>virt</td><td>虚拟化基础设施</td></tr></tbody></table><h4 id="源码树根目录下的一些文件">源码树根目录下的一些文件</h4><ul><li><strong>COPYING</strong>：内核许可证（GNU GPL v2）。</li><li><strong>CREDITS</strong>：内核主要开发者名单。</li><li><strong>MAINTAINERS</strong>：各子系统和驱动的维护者名单。</li><li><strong>Makefile</strong>：内核主Makefile，用于编译和构建整个内核。</li></ul><h2 id="配置内核configuring-the-kernel">配置内核（Configuring theKernel）</h2><p>因为 Linux源码是开放的，所以你可以在编译前根据自己的需求进行配置和定制。实际上，你可以只为你需要的功能和驱动编译支持。<strong>配置内核</strong>是编译前的必经步骤。由于内核功能丰富、支持的硬件种类繁多，配置选项也非常多。</p><h3 id="内核配置选项configuration-options">内核配置选项（ConfigurationOptions）</h3><p>内核配置通过一系列以 <code>CONFIG_</code> 开头的选项控制，例如<code>CONFIG_SMP</code> 控制对称多处理（SMP）支持。设置该选项即启用SMP，未设置则禁用。配置选项既决定编译哪些文件，也通过预处理指令影响源码。</p><ul><li><strong>布尔型（Boolean）</strong>：只有 yes 或 no 两种状态。比如<code>CONFIG_PREEMPT</code>。</li><li><strong>三态（Tristate）</strong>：yes、no 或 module。module表示编译为可动态加载的模块（.ko 文件）；yes表示直接编译进内核镜像。</li><li><strong>字符串或整数</strong>：用于指定某些参数值，比如数组大小，这些不会影响编译流程，而是作为宏被源码访问。</li></ul><h3 id="发行版内核与自定义内核">发行版内核与自定义内核</h3><p>各大 Linux 发行版（如Ubuntu、Fedora）自带的内核都是预编译好的，通常会启用大部分常用功能，并把绝大多数驱动编译为模块，以便支持各种硬件。但如果你想深入学习或开发内核，还是需要自己编译内核，并选择合适的模块。</p><h3 id="配置工具">配置工具</h3><p>内核提供了多种配置工具：</p><ul><li><p><strong>文本命令行工具</strong><br /><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make config</span><br></pre></td></tr></table></figure> 逐项询问每个选项，适合有耐心的用户。</p></li><li><p><strong>基于 ncurses 的图形界面</strong><br /><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure> 推荐使用，界面友好，选项分门别类。</p></li><li><p><strong>基于 GTK+ 的图形界面</strong><br /><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make gconfig</span><br></pre></td></tr></table></figure> 适合喜欢图形界面的用户。</p></li></ul><p>这些工具会把配置选项分为不同类别（如“处理器类型与特性”），你可以浏览、修改各项配置。</p><h3 id="快速生成默认配置">快速生成默认配置</h3><p>如果你不想从零开始配置，可以用默认配置： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make defconfig</span><br></pre></td></tr></table></figure>这会生成一个适合你当前架构的默认配置（比如 i386 下据说是 Linus的配置），适合新手快速上手。之后可以再根据自己的硬件调整配置。</p><h3 id="配置文件的位置与管理">配置文件的位置与管理</h3><p>所有配置选项最终会保存在源码根目录下的 <code>.config</code>文件中。你也可以直接编辑这个文件（很多内核开发者都这么做），只需搜索并修改对应的配置项即可。</p><p>如果你用现有的 <code>.config</code>文件，或者升级到新内核后想沿用旧配置，可以用： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make oldconfig</span><br></pre></td></tr></table></figure>它会根据新内核的选项补全或更新你的配置。</p><h3 id="复制当前内核配置">复制当前内核配置</h3><p>如果当前内核启用了 <code>CONFIG_IKCONFIG_PROC</code>，你可以直接从<code>/proc/config.gz</code> 拷贝当前内核的配置： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zcat /proc/config.gz &gt; .config</span><br><span class="line">make oldconfig</span><br></pre></td></tr></table></figure>这样可以方便地克隆当前系统的内核配置。</p><h2 id="编译内核">编译内核</h2><p>配置好后，只需一条命令即可编译内核： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure> 自 2.6版本起，无需再手动运行 <code>make dep</code> 或分别编译bzImage、modules，默认的 Makefile 规则会自动处理所有依赖和构建流程。</p><h3id="降低编译输出噪音minimizing-build-noise">降低编译输出噪音（MinimizingBuild Noise）</h3><p>在编译内核时，终端会输出大量信息。为了减少这些“噪音”，但又能看到警告和错误，可以将<code>make</code> 的标准输出重定向到文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &gt; ../detritus</span><br></pre></td></tr></table></figure><p>如果需要查看详细输出，可以阅读该文件。由于警告和错误信息会输出到标准错误（stderr），通常你不需要关心标准输出。实际上，你可以直接把输出丢到“黑洞”：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &gt; /dev/null</span><br></pre></td></tr></table></figure><p>这样所有无用的输出都会被丢弃，只在终端显示警告和错误。</p><hr /><h3 id="并行编译spawning-multiple-build-jobs">并行编译（SpawningMultiple Build Jobs）</h3><p><code>make</code>支持并行编译，可以同时运行多个编译任务，大大加快多核系统上的编译速度。方法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -jN</span><br></pre></td></tr></table></figure><p>其中 <code>N</code>是并行任务数。通常建议每个处理器核心分配1~2个任务。例如，16核机器可以这样：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j32 &gt; /dev/null</span><br></pre></td></tr></table></figure><p>此外，使用如 <code>distcc</code> 或 <code>ccache</code>等工具也能进一步提升编译速度。</p><hr /><h2 id="安装新内核installing-the-new-kernel">安装新内核（Installing theNew Kernel）</h2><p>内核编译完成后，需要安装。安装方式依赖于你的硬件架构和引导程序（bootloader），请查阅对应引导程序的文档。</p><p><strong>以 x86 + grub 为例：</strong></p><ol type="1"><li>将 <code>arch/i386/boot/bzImage</code> 复制到<code>/boot</code>，并命名为如 <code>vmlinuz-version</code>。</li><li>编辑 <code>/boot/grub/grub.conf</code>，为新内核添加启动项。</li></ol><p><strong>如果使用 LILO：</strong></p><ol type="1"><li>编辑 <code>/etc/lilo.conf</code>，添加新内核项。</li><li>重新运行 <code>lilo</code> 命令。</li></ol><h3 id="安装模块installing-modules">安装模块（Installing Modules）</h3><p>模块的安装是自动且与架构无关的。只需以 root 权限运行： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make modules_install</span><br></pre></td></tr></table></figure>这会把所有编译好的模块安装到 <code>/lib/modules</code>下的对应目录。</p><h3 id="system.map-文件">System.map 文件</h3><p>编译过程中还会在源码根目录生成 <code>System.map</code>文件。它是一个符号查找表，用于将内核符号映射到内存地址，在调试时可以把地址转换为函数或变量名。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;内核源码相关&quot;&gt;内核源码相关&lt;/h2&gt;
&lt;h3 id=&quot;获取内核源码&quot;&gt;获取内核源码&lt;/h3&gt;
&lt;p&gt;当前的 Linux 源代码总是可以在 &lt;a
href=&quot;http://www.kernel.org&quot;&gt;http://www.kernel.org&lt;/a&gt;
</summary>
      
    
    
    
    <category term="os basic" scheme="https://mackz-maxw.github.io/categories/os-basic/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统基础 | 1. linux内核简介</title>
    <link href="https://mackz-maxw.github.io/2025/06/18/oper_sys0/"/>
    <id>https://mackz-maxw.github.io/2025/06/18/oper_sys0/</id>
    <published>2025-06-18T15:59:12.650Z</published>
    <updated>2025-06-21T02:19:25.449Z</updated>
    
    <content type="html"><![CDATA[<p>总结一下课堂笔记，不然总是放在不知道哪个作业文件夹里找不到</p><h3 id="操作系统与内核概述">操作系统与内核概述</h3><p><strong>内核</strong>是操作系统的最核心部分，负责管理硬件资源（如CPU、内存、硬盘等），并为上层软件提供服务。内核运行在“内核空间”，拥有对硬件的完全控制权，而普通应用程序运行在“用户空间”，只能通过内核提供的接口访问硬件。</p><p>应用程序与内核的交互主要通过<strong>系统调用</strong>完成。比如：</p><ul><li>当你在 C 语言程序里调用 <code>printf("hello\n")</code>时，实际上发生了多层调用。<code>printf()</code>负责格式化和缓冲数据，最终会调用 <code>write()</code>函数，把数据写到终端。<code>write()</code> 是一个库函数，它最终会触发<code>write</code> 系统调用，由内核把数据真正输出到屏幕。</li><li>类似地，<code>open()</code> 库函数几乎只做一件事，就是调用<code>open</code> 系统调用，让内核帮你打开一个文件。</li><li>还有一些库函数，比如<code>strcpy()</code>，只是单纯地在内存中复制数据，根本不会和内核打交道。</li></ul><p><strong>简单来说：</strong> - 你写的应用程序通过库函数（如<code>printf()</code>、<code>open()</code>）间接或直接调用系统调用（如<code>write</code>、<code>open</code>），由内核完成实际的硬件操作。 -有些库函数（如<code>strcpy()</code>）只在用户空间工作，不需要内核参与。</p><p><strong>内核还负责处理中断</strong>。比如你敲键盘时，键盘控制器会发出中断信号，内核收到后会执行相应的中断处理程序，把你输入的内容读出来。</p><figure><img src="../images/oper_sys0.png" alt="操作系统结构图" /><figcaption aria-hidden="true">操作系统结构图</figcaption></figure><p>在任何给定时刻，每个处理器正在做以下三件事中的一件：</p><ul><li>在用户空间，在进程上下文中执行用户代码</li><li>在内核空间，在进程上下文中，代表特定进程执行操作（包括空闲进程）</li><li>在内核空间，在中断上下文中，不与任何进程关联，处理中断</li></ul><h3 id="linux-与经典-unix-内核设计">Linux 与经典 Unix 内核设计</h3><ul><li><strong>单一内核/宏内核（Monolithic Kernel）</strong><br />经典 Unix 和 Linux都采用单一内核设计。单一内核就是把所有核心功能（如进程管理、内存管理、文件系统、驱动等）都放在一个大程序里，在同一个内存空间中运行。这样做的好处是：<ul><li>内核内部各部分可以直接调用彼此的函数，通信效率高，性能好。</li><li>设计和实现相对简单。</li></ul></li><li><strong>微内核（Microkernel）</strong><br />微内核把内核功能拆分成多个独立的“服务器”，有的在内核空间，有的在用户空间。它们之间通过消息传递（IPC）通信。优点是：<ul><li>各部分相互隔离，一个崩溃不会影响其他部分，系统更稳定。</li><li>更容易替换和扩展功能。 缺点是：<br /></li><li>消息传递比直接函数调用慢，频繁切换上下文会影响性能。</li><li>实际上，很多微内核系统（如 WindowsNT、Mach）为了性能，后来又把大部分服务放回了内核空间。</li></ul></li><li><strong>Linux 的做法</strong><br />Linux是单一内核，但吸收了微内核的一些优点，比如模块化设计、支持内核线程、可以动态加载内核模块等。<ul><li>Linux 所有核心功能都在内核空间，通信用直接函数调用，性能高。</li><li>同时，Linux 也很灵活，可以按需加载或卸载功能模块。</li></ul></li></ul><p>Linux 虽然继承了 Unix 的理念和 API，但并不基于任何特定 Unix变体，因此可以灵活选择或创新最佳技术方案。</p><ul><li><strong>动态内核模块</strong>：Linux支持内核模块的动态加载和卸载，增强了灵活性和可扩展性。</li><li><strong>对称多处理器（SMP）支持</strong>：Linux 从早期就支持SMP，而许多传统 Unix 系统最初并不支持。</li><li><strong>抢占式内核</strong>：Linux内核支持抢占，允许内核任务被中断，提高了实时性和响应速度，而大多数传统Unix 内核不是抢占式的。</li><li><strong>线程与进程统一</strong>：Linux内核不区分线程和进程，所有进程本质上是一样的，只是有些进程共享资源。</li><li><strong>面向对象的设备模型</strong>：Linux采用了现代的设备管理方式，如设备类、热插拔和 sysfs。</li><li><strong>精简与创新</strong>：Linux有选择地实现功能，忽略了被认为设计不佳或无实际价值的传统 Unix 特性（如STREAMS）。</li><li><strong>开放与自由</strong>：Linux的功能集来源于开放的开发模式，只有经过充分论证、设计清晰、实现扎实的功能才会被采纳。</li></ul><h3 id="linux-内核版本">Linux 内核版本</h3><ul><li><strong>稳定版 (Stable)：</strong> 次版本号为<strong>偶数</strong>(如 2.4, 2.6, 4.18,5.10)。适合生产环境部署，主要更新是错误修复和新驱动。</li><li><strong>开发版 (Development)：</strong>次版本号为<strong>奇数</strong> (如 2.5,3.1)。代码快速变化，包含实验性功能，不稳定。</li><li><strong>版本号格式：</strong><code>主版本.次版本.修订版本[.稳定版本]</code> (如<code>2.6.30.1</code>)。<ul><li><code>主版本.次版本</code> 定义内核系列 (如 2.6)。</li><li><code>修订版本</code> 表示同一系列内的主要发布。</li><li><code>.稳定版本</code> (可选)表示在主要发布后的小更新，专注于关键错误修复。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;总结一下课堂笔记，不然总是放在不知道哪个作业文件夹里找不到&lt;/p&gt;
&lt;h3 id=&quot;操作系统与内核概述&quot;&gt;操作系统与内核概述&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;内核&lt;/strong&gt;是操作系统的最核心部分，负责管理硬件资源（如CPU、内存、硬盘等），并为上层软件提供服务。</summary>
      
    
    
    
    <category term="os basic" scheme="https://mackz-maxw.github.io/categories/os-basic/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-动态规划2</title>
    <link href="https://mackz-maxw.github.io/2025/06/17/kamacode29/"/>
    <id>https://mackz-maxw.github.io/2025/06/17/kamacode29/</id>
    <published>2025-06-18T00:46:52.955Z</published>
    <updated>2025-06-20T17:02:03.168Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不同路径">62.不同路径</h3><p>想清楚要怎么推导每个格子，可以怎么推导 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span> || n == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="不同路径-ii">63. 不同路径 II</h3><h4 id="问题分析">问题分析</h4><ol type="1"><li><strong>起点<code>(0,0)</code>未特殊处理</strong>：<ul><li>当<code>i=0, j=0</code>时（起点），您的代码会进入<code>else</code>分支（因为不满足前三个条件）。</li><li>在<code>else</code>分支中，它计算<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>，但<code>i-1 = -1</code>、<code>j-1 = -1</code>（<strong>非法索引</strong>），导致未定义行为（崩溃或错误结果）。</li></ul></li><li><strong>边界条件不完整</strong>：<ul><li>当起点有障碍物时，虽能设为0，但后续计算仍可能依赖无效索引。</li><li>初始化<code>dp</code>为全1是冗余的，且可能掩盖问题（实际值会被覆盖）。</li></ul></li></ol><h4 id="修复后的代码">修复后的代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="整数拆分-可跳过">343. 整数拆分 （可跳过）</h3><p>我直接用贪心法，辗转减去3来写了 动态规划思路如下：</p><ul><li>遍历 <span class="math inline">\(j\)</span>（<spanclass="math inline">\(1 \leq j &lt; i\)</span>），比较 <spanclass="math inline">\((i - j) \times j\)</span> 和 <spanclass="math inline">\(dp[i - j] \times j\)</span>，取最大值。</li><li><code>j * (i - j)</code> 是把整数拆分为两个数相乘。</li><li><code>j * dp[i - j]</code> 是把整数拆分为两个及以上的数相乘。</li><li>如果用<code>dp[i - j] * dp[j]</code>，则相当于强制把一个数拆成四份及以上。</li></ul><p>递推公式为：<code>dp[i] = max(&#123;dp[i], (i - j) * j, dp[i - j] * j&#125;);</code></p><p>为什么还要比较 <code>dp[i]</code> 呢？<br />因为每次计算 <code>dp[i]</code> 时，都要保证它是当前的最大值。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">3</span>)<span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> pd = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">4</span>)&#123;</span><br><span class="line">                pd = pd * <span class="number">4</span>;</span><br><span class="line">                n = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                n = n - <span class="number">3</span>;</span><br><span class="line">                pd = pd * <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            pd = pd * n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="不同的二叉搜索树-可跳过">96.不同的二叉搜索树 （可跳过）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numTrees</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)<span class="keyword">return</span> n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">// 方便计算</span></span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i&lt;=n ;i++)&#123;</span><br><span class="line">            <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=i; j++)&#123;</span><br><span class="line">                cnt += dp[j<span class="number">-1</span>] * dp[i-j];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;不同路径&quot;&gt;62.不同路径&lt;/h3&gt;
&lt;p&gt;想清楚要怎么推导每个格子，可以怎么推导 &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/sp</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-动态规划1</title>
    <link href="https://mackz-maxw.github.io/2025/06/16/kamacode28/"/>
    <id>https://mackz-maxw.github.io/2025/06/16/kamacode28/</id>
    <published>2025-06-16T17:22:04.541Z</published>
    <updated>2025-06-17T16:16:12.768Z</updated>
    
    <content type="html"><![CDATA[<h3 id="斐波那契数">509. 斐波那契数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n &gt; <span class="number">1</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">fib</span>(n<span class="number">-1</span>)+<span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="爬楼梯">70. 爬楼梯</h3><p>递归超时了，得用数组算。如果用两个有效数字的数组重复计算还能再省空间<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">3</span>; i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="使用最小花费爬楼梯">746. 使用最小花费爬楼梯</h3><p>重点是跟着输出的dp数组看推导过程哪里有错 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> stairs = cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(stairs == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(stairs == <span class="number">2</span>)<span class="keyword">return</span> <span class="built_in">min</span>(cost[<span class="number">0</span>], cost[<span class="number">1</span>]);</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(cost.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        dp[stairs<span class="number">-1</span>] = cost[stairs<span class="number">-1</span>];<span class="comment">//back()</span></span><br><span class="line">        dp[stairs<span class="number">-2</span>] = cost[stairs<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = (stairs<span class="number">-3</span>); i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            dp[i] = cost[i]+ <span class="built_in">min</span>(dp[i+<span class="number">1</span>], dp[i+<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(auto i: dp)&#123;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;i&lt;&lt;&quot; &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[<span class="number">0</span>], dp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;斐波那契数&quot;&gt;509. 斐波那契数&lt;/h3&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-贪心算法5</title>
    <link href="https://mackz-maxw.github.io/2025/06/14/kamacode27/"/>
    <id>https://mackz-maxw.github.io/2025/06/14/kamacode27/</id>
    <published>2025-06-14T15:39:31.805Z</published>
    <updated>2025-06-14T22:34:14.043Z</updated>
    
    <content type="html"><![CDATA[<h3 id="合并区间">56. 合并区间</h3><h4 id="错误分析">错误分析</h4><ol type="1"><li><strong>合并逻辑错误</strong>（关键问题）： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intervals[i] = (intervals[i<span class="number">-1</span>][<span class="number">0</span>], intervals[i][<span class="number">1</span>]); <span class="comment">// 错误写法</span></span><br></pre></td></tr></table></figure><ul><li><strong>语法错误</strong>：使用逗号运算符 <code>(a, b)</code>实际返回 <code>b</code>，导致区间被错误赋值为<code>[0, intervals[i][1]]</code>（起始点丢失）。</li><li><strong>逻辑错误</strong>：合并时结束点未取两者最大值。正确做法：结束点应为<code>max(intervals[i-1][1], intervals[i][1])</code>，否则可能丢失覆盖范围（如合并<code>[1,5]</code> 和 <code>[2,3]</code> 会得到 <code>[1,3]</code> 而非<code>[1,5]</code>）。</li></ul></li><li><strong>重叠条件不精确</strong>： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(intervals[i<span class="number">-1</span>][<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]) <span class="comment">// 边界情况处理不当</span></span><br></pre></td></tr></table></figure><ul><li>题目要求：若前区间结束点 <strong>等于</strong> 后区间起始点（如<code>[1,2]</code> 和 <code>[2,3]</code>），应合并为<code>[1,3]</code>。当前条件 <code>&gt;=</code>正确，但合并操作错误导致结果异常。</li></ul></li><li><strong>性能问题</strong>：<ul><li><strong>拷贝开销</strong>：<code>cmp</code>函数参数为传值（<code>vector&lt;int&gt; a, b</code>），应改为<strong>传引用</strong>（<code>const vector&lt;int&gt;&amp; a, b</code>）避免不必要的拷贝。</li><li><strong>额外空间</strong>：使用 <code>incl</code>标记数组非必需，经典解法可优化空间复杂度。</li></ul></li><li><strong>边界处理缺失</strong>：<ul><li>当输入为空时，应直接返回空数组，但代码未显式处理<code>intervals.size() == 0</code> 的情况（依赖<code>size &lt;= 1</code> 返回，逻辑正确但不够清晰）。</li></ul></li></ol><h4 id="比较合并贪心解法可以ac">比较合并贪心解法（可以ac）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123; <span class="comment">// 传引用</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>] || (a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">incl</span><span class="params">(intervals.size(), <span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; intervals.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i<span class="number">-1</span>][<span class="number">1</span>] &gt;= intervals[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// 正确合并：起始点取前一个，结束点取两者最大值</span></span><br><span class="line">                intervals[i][<span class="number">0</span>] = intervals[i<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">                intervals[i][<span class="number">1</span>] = <span class="built_in">max</span>(intervals[i<span class="number">-1</span>][<span class="number">1</span>], intervals[i][<span class="number">1</span>]);</span><br><span class="line">                incl[i<span class="number">-1</span>] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; intervals.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (incl[j]) result.<span class="built_in">push_back</span>(intervals[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="经典贪心解法思路">经典贪心解法思路</h4><ol type="1"><li><strong>按起始点排序区间</strong>。</li><li><strong>动态合并</strong>：<ul><li>初始化结果数组 <code>merged</code>。</li><li>遍历每个区间：<ul><li>若 <code>merged</code> 为空 <strong>或</strong> 当前区间与<code>merged</code>最后一个区间不重叠（<code>current[0] &gt; merged.back()[1]</code>），直接加入。</li><li>否则，<strong>更新 <code>merged</code>最后一个区间的结束点</strong>：<code>max(merged.back()[1], current[1])</code>。</li></ul></li></ul></li></ol><h4 id="经典贪心解法">经典贪心解法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; merged;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; interval : intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span> (merged.<span class="built_in">empty</span>() || merged.<span class="built_in">back</span>()[<span class="number">1</span>] &lt; interval[<span class="number">0</span>]) &#123;</span><br><span class="line">                merged.<span class="built_in">push_back</span>(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                merged.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(merged.<span class="built_in">back</span>()[<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="单调递增的数字">738.单调递增的数字</h3><p>题目要求小于等于N的最大单调递增的整数，那么拿一个两位的数字来举例。例如：98，一旦出现<code>strNum[i - 1] &gt; strNum[i]</code>的情况（非单调递增），首先想<strong>让<code>strNum[i - 1]--</code>，然后<code>strNum[i]</code>给为9</strong>，这样这个整数就是89，即小于98的最大的单调递增整数。&gt; 这一点如果想清楚了，这道题就好办了。</p><p>此时是从前向后遍历还是从后向前遍历呢？从前向后遍历的话，遇到<code>strNum[i - 1] &gt; strNum[i]</code>的情况，让<code>strNum[i - 1]</code>减一，但此时如果<code>strNum[i - 1]</code>减一了，可能又小于<code>strNum[i - 2]</code>。这么说有点抽象，举个例子，数字：332，从前向后遍历的话，那么就把变成了329，此时2又小于了第一位的3了，真正的结果应该是299。那么<strong>从后向前遍历</strong>，就可以重复利用上次比较得出的结果了，从后向前遍历332的数值变化为：332-&gt; 329 -&gt; 299</p><h4 id="处理逻辑易错"><strong>处理逻辑易错</strong></h4><ul><li>当发现 <code>digits[i-1] &lt; digits[i]</code>时，代码只修改了<strong>当前低位</strong>（设为9）和<strong>当前高位</strong>（减1），但<strong>没有处理更高位的影响</strong><ul><li>高位减1后可能破坏与更前高位的单调性（例：<code>100</code>的处理）</li><li>未将<strong>所有受影响低位</strong>置为<code>9</code>（例：<code>100</code> 的个位未置9）</li></ul></li><li><strong>示例验证</strong>（输入 <code>n=100</code>）： 分解 digits =[0, 0, 1] # 个位=0, 十位=0, 百位=1 遍历 i=1：0==0 → 跳过 遍历i=2：0&lt;1 → 十位置9, 百位减1 → digits=[0,9,0] 结果 = 0<em>10⁰ +9</em>10¹ + 0*10² = 90 # 预期应为99</li></ul><h4 id="数字组合计算易错"><strong>数字组合计算易错</strong></h4><ul><li><strong>错误代码</strong>：<code>res += 10 * (i-1) * digits[i-1]</code></li><li><strong>问题</strong>：<ul><li>错误使用乘法 <code>10*(i-1)</code> 而非指数<code>10^(i-1)</code></li><li>导致计算结果完全错误（如个位贡献<code>10*0*digits[0]=0</code>）</li></ul></li><li><strong>正确计算</strong>：应使用<code>pow(10, i-1) * digits[i-1]</code></li></ul><blockquote><p>💡 <strong>黄金法则</strong>：需要修改数字的每一位时，优先考虑<code>to_string</code> → 字符串处理 → <code>stoi</code>流程，比数学运算更直观可靠！</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">monotoneIncreasingDigits</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        string str = <span class="built_in">to_string</span>(n);</span><br><span class="line">        <span class="type">int</span> flag = str.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = (str.<span class="built_in">size</span>() - <span class="number">1</span>);i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i<span class="number">-1</span>] &gt; str[i])&#123;</span><br><span class="line">                flag = i;</span><br><span class="line">                str[i<span class="number">-1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;str.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= flag)&#123;</span><br><span class="line">                str[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">stoi</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="监控二叉树">968.监控二叉树</h3><p>其实我的思路和题解的想法已经很接近了，但是总结地没有那么到位，导致缺漏数量的情况</p><h4 id="确定遍历顺序">确定遍历顺序</h4><p>在二叉树中可以使用后序遍历也就是左右中的顺序，这样就可以在回溯的过程中从下到上进行推导了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">traversal</span><span class="params">(TreeNode* cur)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 空节点，该节点有覆盖</span></span><br><span class="line">    <span class="keyword">if</span> (终止条件) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> left = <span class="built_in">traversal</span>(cur-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">    <span class="type">int</span> right = <span class="built_in">traversal</span>(cur-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">    逻辑处理                            <span class="comment">// 中</span></span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="返回状态类型">返回状态类型</h4><ul><li>0：该节点不在摄像头覆盖范围</li><li>1：本节点有摄像头</li><li>2：本节点在摄像头覆盖范围</li></ul><p>递归的终止条件应该是遇到了空节点，此时应该返回2（有覆盖），这样就可以在叶子节点的父节点放摄像头了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空节点，该节点有覆盖</span></span><br><span class="line"><span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure> 完整代码： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> cmr = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coverStat</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">coverStat</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">coverStat</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">2</span> &amp;&amp; right == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> || right == <span class="number">0</span>)&#123;</span><br><span class="line">            cmr++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">1</span> || right == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCameraCover</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> rcv = <span class="built_in">coverStat</span>(root);</span><br><span class="line">        <span class="keyword">if</span>(rcv == <span class="number">0</span>)cmr++;</span><br><span class="line">        <span class="keyword">return</span> cmr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;合并区间&quot;&gt;56. 合并区间&lt;/h3&gt;
&lt;h4 id=&quot;错误分析&quot;&gt;错误分析&lt;/h4&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;strong&gt;合并逻辑错误&lt;/strong&gt;（关键问题）： &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-贪心算法4</title>
    <link href="https://mackz-maxw.github.io/2025/06/13/kamacode26/"/>
    <id>https://mackz-maxw.github.io/2025/06/13/kamacode26/</id>
    <published>2025-06-13T17:04:32.728Z</published>
    <updated>2025-06-14T02:14:04.351Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用最少数量的箭引爆气球">452. 用最少数量的箭引爆气球</h3><h4 id="题解逻辑如下">💡 题解逻辑如下：</h4><ul><li>如果当前气球的 <strong>起点 &gt;上一个交集的最右端点</strong>，说明它<strong>不能和之前的箭共用</strong>，需要再发一支箭。<ul><li>更新 <code>end</code> 为当前气球的<code>end</code>，建立新的交集窗口。</li></ul></li><li>否则，当前气球和前面的箭是<strong>重叠的</strong>，它们能一起被射中。<ul><li>更新 <code>end = min(end, points[i][1])</code>是为了<strong>缩小交集范围</strong>，因为未来能共用这支箭的气球，必须跟所有已合并气球都有交集。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMinArrowShots</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(points.<span class="built_in">begin</span>(), points.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="type">int</span> arr = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(points.<span class="built_in">size</span>() == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;points.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(end &lt; points[i][<span class="number">0</span>])&#123;</span><br><span class="line">                end = points[i][<span class="number">1</span>];</span><br><span class="line">                arr++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end = <span class="built_in">min</span>(end, points[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="无重叠区间">435. 无重叠区间</h3><h4 id="思路步骤">思路步骤：</h4><ol type="1"><li><strong>排序区间</strong>（预处理）：<ul><li>使用自定义比较器 <code>cmp</code> 对所有区间进行排序。</li><li>排序规则：<strong>按起始点升序</strong>（优先比较<code>intervals[i][0]</code>）。若起始点相同，则<strong>按结束点升序</strong>（比较<code>intervals[i][1]</code>）。</li><li>按结束点排序效率可以更高</li></ul></li><li><strong>初始化关键变量</strong>：<ul><li>最大不重叠区间计数器<code>intv = 1</code>（至少包含第一个区间）。</li><li>当前覆盖的结束点<code>end = intervals[0][1]</code>（以第一个区间的结束点作为初始基准）。</li></ul></li><li><strong>遍历处理每个区间</strong>（从第二个区间开始，即<code>i = 1</code>）：<ul><li><strong>检查重叠</strong>：比较当前区间起始点<code>intervals[i][0]</code> 与当前结束点 <code>end</code>。<ul><li><strong>情况1：有重叠</strong>（<code>intervals[i][0] &lt; end</code>）：<ul><li>更新<code>end = min(end, intervals[i][1])</code>（关键贪心选择：取最小结束点）。</li><li><strong>不增加计数器</strong><code>intv</code>（因为重叠区间不能同时保留，这里隐含选择了结束点更小的区间以正确计算无重叠区间个数）。</li></ul></li><li><strong>情况2：无重叠</strong>（<code>intervals[i][0] &gt;= end</code>）：<ul><li>更新<code>end = intervals[i][1]</code>（将结束点设为当前区间的结束点）。</li><li>增加计数器<code>intv++</code>（表示成功添加一个新的不重叠区间）。</li></ul></li></ul></li></ul></li><li><strong>计算结果</strong>：<ul><li>需要移除的最小区间数 = 总区间数 <code>intervals.size()</code> -最大不重叠区间数 <code>intv</code>。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a, vector&lt;<span class="type">int</span>&gt;b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] &lt; b[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="comment">// for(auto i: intervals)&#123;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;i[0]&lt;&lt;&quot; &quot;&lt;&lt;i[1]&lt;&lt;&quot;, &quot;;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="type">int</span> intv = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> end = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(intervals.<span class="built_in">size</span>() &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt; intervals.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(intervals[i][<span class="number">0</span>] &lt; end)&#123;</span><br><span class="line">                end = <span class="built_in">min</span>(end, intervals[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                end = intervals[i][<span class="number">1</span>];</span><br><span class="line">                intv++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intervals.<span class="built_in">size</span>() - intv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="划分字母区间">763.划分字母区间</h3><p>由题解：在遍历的过程中相当于是要找每一个字母的边界，如果找到之前遍历过的所有字母的最远边界，说明这个边界就是分割点了。此时前面出现过所有字母，最远也就到这个边界了。可以分为如下两步：</p><ul><li>统计每一个字符最后出现的位置</li><li>从头遍历字符，并更新字符的最远出现下标，如果找到字符最远出现位置下标和当前下标相等了，则找到了分割点</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash[<span class="number">27</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            hash[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            right = <span class="built_in">max</span>(right, hash[s[i] - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">            <span class="keyword">if</span>(right == i)&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(right - end +<span class="number">1</span>);</span><br><span class="line">                right++;</span><br><span class="line">                end = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;用最少数量的箭引爆气球&quot;&gt;452. 用最少数量的箭引爆气球&lt;/h3&gt;
&lt;h4 id=&quot;题解逻辑如下&quot;&gt;💡 题解逻辑如下：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;如果当前气球的 &lt;strong&gt;起点 &amp;gt;
上一个交集的最右端点&lt;/strong&gt;，说明它&lt;stro</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-贪心算法3</title>
    <link href="https://mackz-maxw.github.io/2025/06/12/kamacode25/"/>
    <id>https://mackz-maxw.github.io/2025/06/12/kamacode25/</id>
    <published>2025-06-12T21:58:06.162Z</published>
    <updated>2025-06-13T17:02:57.545Z</updated>
    
    <content type="html"><![CDATA[<h3 id="加油站">134. 加油站</h3><h4 id="初始思路">初始思路：</h4><ol type="1"><li><strong>先找一段正收益连续区间（油量盈余最大的起点）</strong><ul><li>用 <code>curMax</code> 累加正收益段，记录最大盈余时的起点<code>maxSt</code>。</li><li>如果遇到油不够的站点，就重置 <code>curMax</code> 并将<code>start</code> 改为下一个站点。</li><li>如果到最后一站没找完，循环一圈回来继续查找。</li></ul></li><li><strong>再从 <code>maxSt</code> 模拟绕一圈</strong><ul><li>从 <code>maxSt</code> 出发，逐站加减油量，确认是否能绕完整圈。</li><li>只要中途油量不足就返回 <code>-1</code>。</li></ul></li></ol><h4 id="存在的问题">⚠️ 存在的问题：</h4><p>其实这种逻辑完善完善也是可以做出来的，题解中有，就是比较繁琐</p><h4 id="更优的做法贪心-一次遍历">✅ 更优的做法（贪心 + 一次遍历）：</h4><p>只要 <strong>总油量 ≥总花费</strong>，一定有解。解的起点是：当前累加油量一旦为负，就从下一个站点重启。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">canCompleteCircuit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; gas, vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tank = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> startInd = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; gas.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> store = gas[i] - cost[i];</span><br><span class="line">            total += store;</span><br><span class="line">            tank += store;</span><br><span class="line">            <span class="keyword">if</span>(tank &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                startInd = i + <span class="number">1</span>;</span><br><span class="line">                tank = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total &lt; <span class="number">0</span> ? <span class="number">-1</span> : startInd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="分发糖果">135. 分发糖果</h3><p>这在leetcode上是一道困难的题目，其难点就在于贪心的策略，如果在考虑局部的时候想两边兼顾，就会顾此失彼。题解采用了两次贪心的策略： *一次是从左到右遍历，只比较右边孩子评分比左边大的情况。 *一次是从右到左遍历，只比较左边孩子评分比右边大的情况。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; ratings)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; candy;</span><br><span class="line">        candy.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;ratings.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i] &gt; ratings[i<span class="number">-1</span>])&#123;</span><br><span class="line">                candy.<span class="built_in">push_back</span>(candy[i<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                candy.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = (ratings.<span class="built_in">size</span>()<span class="number">-1</span>); i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ratings[i<span class="number">-1</span>] &gt; ratings[i] &amp;&amp; candy[i<span class="number">-1</span>] &lt;= candy[i])&#123;</span><br><span class="line">                candy[i<span class="number">-1</span>] = candy[i] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            total += candy[i];</span><br><span class="line">        &#125;</span><br><span class="line">        total += candy[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="柠檬水找零">860.柠檬水找零</h3><p>这题不用map,用两个整数表示5和10的钞票数也是可以的 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">lemonadeChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; bills)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; changes;</span><br><span class="line">        changes[<span class="number">5</span>] = <span class="number">0</span>;</span><br><span class="line">        changes[<span class="number">10</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;bills.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> exc = bills[i] - <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">if</span>(exc == <span class="number">0</span>)&#123;</span><br><span class="line">                changes[<span class="number">5</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exc == <span class="number">5</span>)&#123;</span><br><span class="line">                changes[<span class="number">5</span>]--;</span><br><span class="line">                changes[<span class="number">10</span>]++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(exc == <span class="number">15</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(changes[<span class="number">10</span>] &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">                    changes[<span class="number">10</span>]--;</span><br><span class="line">                    changes[<span class="number">5</span>]--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    changes[<span class="number">5</span>] -= <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(changes[<span class="number">5</span>] &lt; <span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="根据身高重建队列">406.根据身高重建队列</h3><p>看题解可知，当身高是按照从高到矮，第二个数字从小到大排列的时候，按顺序插入即可满足条件<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; a, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[<span class="number">0</span>] &gt; b[<span class="number">0</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a[<span class="number">0</span>] == b[<span class="number">0</span>] &amp;&amp; a[<span class="number">1</span>] &lt; b[<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">reconstructQueue</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; people) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(people.<span class="built_in">begin</span>(), people.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        list&lt;vector&lt;<span class="type">int</span>&gt;&gt; que;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;people.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> insPos = people[i][<span class="number">1</span>];</span><br><span class="line">            std::list&lt;vector&lt;<span class="type">int</span>&gt;&gt;::iterator p = que.<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">while</span>(insPos &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                p++;</span><br><span class="line">                insPos--;</span><br><span class="line">            &#125;</span><br><span class="line">            que.<span class="built_in">insert</span>(p, people[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(que.<span class="built_in">begin</span>(), que.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;加油站&quot;&gt;134. 加油站&lt;/h3&gt;
&lt;h4 id=&quot;初始思路&quot;&gt;初始思路：&lt;/h4&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;strong&gt;先找一段正收益连续区间（油量盈余最大的起点）&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;用 &lt;code&gt;curMax&lt;/</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-贪心算法2</title>
    <link href="https://mackz-maxw.github.io/2025/06/09/kamacode24/"/>
    <id>https://mackz-maxw.github.io/2025/06/09/kamacode24/</id>
    <published>2025-06-10T02:01:13.652Z</published>
    <updated>2025-06-12T00:25:24.754Z</updated>
    
    <content type="html"><![CDATA[<h3 id="买卖股票的最佳时机ii">122.买卖股票的最佳时机II</h3><p>和之前的贪心算法题目一样，注意到局部最佳和整体的关系<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> prof = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> left = prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(left &gt; <span class="number">0</span>)prof += left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prof;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="跳跃游戏">55. 跳跃游戏</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxi = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; nums.<span class="built_in">size</span>()<span class="number">-1</span> &amp;&amp; nums[i] == <span class="number">0</span> &amp;&amp; maxi &lt;= i)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> fari = i + nums[i];</span><br><span class="line">            maxi = <span class="built_in">max</span>(maxi, fari);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxi &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="跳跃游戏ii">45.跳跃游戏II</h3><h4 id="最开始的思路"><strong>最开始的思路：</strong></h4><ul><li>定义了一个 <code>minJumps</code> 数组，其中 <code>minJumps[i]</code>表示到达位置 <code>i</code> 所需的最少跳跃次数。</li><li>初始用 <code>minJumps[i] = i</code>，默认每一步都跳一步。</li><li>然后你从前向后遍历每个位置 <code>i</code>，对于它可以跳到的最远位置<code>reach = i + nums[i]</code>，尝试用 <code>minJumps[i] + 1</code>来更新 <code>minJumps[reach]</code>。</li><li>最后返回的是 <code>minJumps[n - 1]</code>。</li></ul><h4 id="问题和可改进点">❌ <strong>问题和可改进点：</strong></h4><ol type="1"><li><strong>只更新了 <code>reach</code>，没更新从 <code>i+1</code> 到<code>reach</code> 的所有中间位置</strong>：<ul><li>你只更新了 <code>minJumps[reach]</code>，但跳到<code>[i+1, reach]</code> 的每一个点其实都可能是通过 <code>i</code>达到的，因此都可能能更新为 <code>minJumps[i] + 1</code>。</li></ul></li><li><strong>时间复杂度仍是 <code>O(n^2)</code> 的最坏情况</strong>：<ul><li>因为如果要更新 <code>[i+1, reach]</code>中的所有点需要嵌套循环。</li></ul></li></ol><h4 id="题解思路遍历过程">✅ <strong>题解思路遍历过程</strong>：</h4><p>每次跳跃的起点在哪里不重要，关键是这次最远跳跃是否可以次数内完成 *对每个位置 <code>i</code>，更新<code>far = max(far, i + nums[i])</code>，表示当前范围内下一跳能跳到的最远位置。* 当遍历到边界 <code>i == beg</code>时，说明当前跳跃结束，需要再跳一次，并更新新的边界<code>beg = far</code>。 * 如果新的 <code>beg</code>已经到达或超过数组末尾，则可以提前 <code>break</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minJump = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> beg = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> far = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            far = <span class="built_in">max</span>(far, i + nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i == beg)&#123;</span><br><span class="line">                minJump++;</span><br><span class="line">                beg = far;</span><br><span class="line">                <span class="keyword">if</span>(beg &gt;= nums.<span class="built_in">size</span>()<span class="number">-1</span>)<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minJump;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="k次取反后最大化的数组和">1005.K次取反后最大化的数组和</h3><h4 id="最开始的思路-1"><strong>最开始的思路</strong></h4><p>用了一个递归函数 <code>lsum(nums, k)</code> 来处理问题，思路如下： 1.<strong>遍历数组找出最小值 <code>minN</code> 及其下标<code>minI</code></strong>； 2. <strong>将 <code>nums[minI]</code>取反</strong>（也就是对当前最小值执行一次取反操作）； 3.<strong>继续递归调用 <code>lsum(nums, k - 1)</code></strong>； 4.<strong>递归终止条件</strong>：<code>k == 0</code>，此时返回整个数组的和；5. <strong>优化点尝试</strong>：当数组中最小值已经 ≥ 0，尝试用<code>k % 2</code>代替多余的取反操作（只取反一次或不取反）以减少递归次数。</p><h4 id="当前实现存在的问题">❌<strong>当前实现存在的问题：</strong></h4><ol type="1"><li><strong>每次递归都重新遍历整个数组，效率低</strong>：<ul><li>时间复杂度接近 <code>O(k * n)</code>，最坏情况下可能是<code>10^5 * 10^3</code>，会超时。</li></ul></li><li><strong>递归开销大</strong>：<ul><li>每次递归都复制 <code>nums</code>数组（因为是传引用再递归），可能带来严重的性能瓶颈。</li></ul></li><li><strong>贪心策略不够高效</strong>：</li></ol><h4 id="推荐的优化思路">✅ <strong>推荐的优化思路：</strong></h4><p>采用<strong>排序 + 贪心策略</strong>来完成任务，流程如下： 1.<strong>先将数组按绝对值从大到小排序</strong>； 2.<strong>从左到右遍历数组，把负数取反，直到 k用完或者没有负数了</strong>； 3. <strong>如果还有剩余的 k且是奇数，说明还有一次取反机会，把当前最小值（绝对值最小的数）再取反一次</strong>；4. 最后返回数组的总和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestSumAfterKNegations</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b)&#123;<span class="keyword">return</span> <span class="built_in">abs</span>(a) &gt; <span class="built_in">abs</span>(b);&#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] = <span class="number">0</span> - nums[i];</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">1</span>)nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>] = <span class="number">0</span> - nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n: nums)&#123;</span><br><span class="line">            sum += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;买卖股票的最佳时机ii&quot;&gt;122.买卖股票的最佳时机II&lt;/h3&gt;
&lt;p&gt;和之前的贪心算法题目一样，注意到局部最佳和整体的关系
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-贪心算法1</title>
    <link href="https://mackz-maxw.github.io/2025/06/08/kamacode23/"/>
    <id>https://mackz-maxw.github.io/2025/06/08/kamacode23/</id>
    <published>2025-06-08T16:29:37.030Z</published>
    <updated>2025-06-09T01:09:52.192Z</updated>
    
    <content type="html"><![CDATA[<h3 id="分发饼干">455.分发饼干</h3><p>这题题解上两个思路：</p><ul><li>思路1：优先考虑饼干，小饼干先喂饱小胃口</li><li>思路2：优先考虑胃口，先喂饱大胃口</li></ul><p>我这里优先考虑饼干 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findC</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s, <span class="type">int</span> gStart, <span class="type">int</span> sStart)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(gStart == g.<span class="built_in">size</span>() || sStart == s.<span class="built_in">size</span>())<span class="keyword">return</span> count;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = sStart; i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] &gt;= g[gStart])&#123;</span><br><span class="line">                count += <span class="number">1</span>;</span><br><span class="line">                count += <span class="built_in">findC</span>(g, s, gStart+<span class="number">1</span>, i+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findContentChildren</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; g, vector&lt;<span class="type">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(g.<span class="built_in">begin</span>(), g.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> cnt = <span class="built_in">findC</span>(g, s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="摆动序列">376. 摆动序列</h3><p>按题解思路，因为题目要求的是最长摆动子序列的长度，所以只需要统计数组的峰值数量就可以了（相当于是删除单一坡度上的节点，然后统计长度）这就是贪心所贪的地方，让峰值尽可能的保持峰值，然后删除单一坡度上的节点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">wiggleMaxLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> waveCnt = <span class="number">1</span>;</span><br><span class="line">        vector&lt;<span class="type">bool</span>&gt; isPos;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> waveCnt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>] == nums[i])<span class="keyword">continue</span>; <span class="comment">// 需要跳过相等的情况，不计入后面的判断条件中</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i<span class="number">-1</span>] &lt; nums[i])&#123;</span><br><span class="line">                isPos.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[i<span class="number">-1</span>] &gt; nums[i])&#123;</span><br><span class="line">                isPos.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; !isPos.<span class="built_in">empty</span>() &amp;&amp; isPos.<span class="built_in">size</span>() == <span class="number">1</span>)waveCnt++;</span><br><span class="line">            <span class="keyword">if</span>(!isPos.<span class="built_in">empty</span>() &amp;&amp; isPos.<span class="built_in">size</span>() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(isPos[isPos.<span class="built_in">size</span>()<span class="number">-1</span>] != isPos[isPos.<span class="built_in">size</span>()<span class="number">-2</span>])waveCnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> waveCnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="最大子序和">53.最大子序和</h3><p>由题解可以得知 如果 -2 1 在一起，计算起点的时候，一定是从 1开始计算，因为负数只会拉低总和，这就是贪心贪的地方！</p><ul><li>局部最优：当前“连续和”为负数的时候立刻放弃，从下一个元素重新计算“连续和”，因为负数加上下一个元素“连续和”只会越来越小。</li><li>全局最优：选取最大“连续和”</li></ul><p>区间的终止位置，其实就是如果 count 取到最大值了，及时记录下来</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxCnt = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            cnt = cnt + nums[i];</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt; maxCnt)&#123;<span class="comment">// 要先赋值，再判断是否小于零，不然全是负数的情况会不正确</span></span><br><span class="line">                maxCnt = cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;分发饼干&quot;&gt;455.分发饼干&lt;/h3&gt;
&lt;p&gt;这题题解上两个思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;思路1：优先考虑饼干，小饼干先喂饱小胃口&lt;/li&gt;
&lt;li&gt;思路2：优先考虑胃口，先喂饱大胃口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我这里优先考虑饼干 &lt;figure</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>模拟面试 | 云架构平台后台开发岗</title>
    <link href="https://mackz-maxw.github.io/2025/06/06/mockintv/"/>
    <id>https://mackz-maxw.github.io/2025/06/06/mockintv/</id>
    <published>2025-06-07T01:37:42.383Z</published>
    <updated>2025-06-11T03:00:09.700Z</updated>
    
    <content type="html"><![CDATA[<p>把面试可能遇到的题目和回答存一下，面完来看看有哪些问到了</p><p>我的简历项目有四个：通用操作系统框架（Rust，研究生阶段跟着导师组里做的项目），多线程TCP服务器开发（Rust），基于贝叶斯优化的系统参数自动化调优框架（Python），智能菜市场物联网数据平台后端（SpringBoot，本科阶段实习的项目）</p><h1 id="模拟面试题目"><strong>模拟面试题目：</strong></h1><h2 id="一-自我介绍与简历深挖"><strong>一、自我介绍与简历深挖</strong></h2><h3id="请用3分钟左右的时间介绍一下你自己-考察总结和表达能力引导面试官关注你的亮点">1.<strong>请用3分钟左右的时间介绍一下你自己</strong>(考察总结和表达能力，引导面试官关注你的亮点)</h3><pre><code>面试官您好！我是来自XX大学计算机科学专业的硕士研究生XX，非常荣幸能参加贵公司云架构平台部后台开发岗位的面试。(背景 &amp; 核心项目 - 1 min) 在研究生阶段，我的核心研究聚焦于构建高性能、可扩展的**操作系统框架**。我主导了其中**调度算法模块**的设计与实现。我的任务是将导师提出的新型**联合调度模型**落地到基于Rust开发的**微内核**框架中。该模型的核心是根据任务的**CPU占用**特征（高/低利用率）**动态匹配**最优调度策略（如EDF或Rate-Monotonic），以提升系统在超负荷以及**实时调度**场景下的整体效用。为了实现并验证该模型：充分利用**Rust的所有权机制**实现安全高效的**任务状态管理**我设计了模块化的调度器接口，支持灵活集成和对比不同策略，并通过Linux内核工程实践（在Raspberry Pi上进行**内核模块定制**、交叉编译） 搭建了真实的测试环境。我利用**perf**等工具采集并分析任务响应时间、CPU利用率等指标，量化验证了该联合调度模型在极端负载下的性能优势，达到了理论预期。这个项目不仅锻炼了我系统级编程（Rust）、内核原理和性能调优的能力，也让我深刻理解了高并发、实时性保障的挑战。(其他项目经验 - 突出相关技术 - 45 sec) 除了研究项目，我也积极将技术应用于实践：我独立设计并开发了一个高性能多线程TCP服务器（Rust）。采用Reactor模式和**非阻塞I/O**处理并发连接，精心设计了**线程安全的任务队列**和共享数据模型，降低了系统调度开销。通过优化，服务器在压力测试下峰值处理能力达到300+请求/秒，并保持了99.9%的运行时间可靠性。这强化了我对网络编程、并发控制和系统稳定性的理解。在XX公司实习期间，我参与了智能菜市场物联网数据平台后端（Spring Boot/Java） 的开发。针对日均5000+设备数据的高并发接入场景，我参与了**分库分表方案设计**，并通过优化复杂查询（使用联合索引）降低关键接口耗时。我还负责了服务的Docker容器化部署，实现了资源的有效利用和快速扩容。这让我熟悉了企业级Java开发、数据库性能优化（MySQL/MyBatis）和容器化技术。(技能总结 &amp; 匹配岗位 - 30 sec) 通过这些经历，我熟练掌握**C++、Python**，并具备扎实的**Rust系统级开发**经验；深入理解操作系统、网络、并发编程原理；在分布式系统设计（分库分表）、高并发优化等方面有实际项目积累；并具备良好的问题定位和解决能力。(结尾 - 表达热情与匹配 - 15 sec) 我了解到贵部门专注于**构建和优化云平台**的核心服务与基础设施，这正是我的兴趣所在。我的系统底层经验、性能优化意识、对分布式和云原生技术的热情，以及扎实的后端开发技能，都与这个岗位高度契合。我非常渴望能加入团队，贡献我的力量，并持续学习成长。谢谢</code></pre><h3 id="通用操作系统框架rust">2.<strong>通用操作系统框架（Rust）：</strong></h3><pre><code>*   你提到“**使用联合调度模型，为不同资源占用的任务匹配调度方式**”。能具体解释一下这个模型的设计思路吗？如何定义“不同资源占用”？调度策略具体有哪些？如何“匹配”？&gt; “好的，面试官。这个联合调度模型的设计核心思想是**根据周期性实时任务的特性，将其分类并分配到最适合其特性的调度策略上运行，以最大化整体系统的调度效率和资源利用率**。&gt;&gt; 1.  **定义‘不同资源占用’：** 我们主要依据任务的 **CPU占用率 (Utilization `U_i = C_i / T_i`)** 来区分任务类型。&gt;     *   **‘高资源占用’任务：** 通常指 `U_i` 较高（例如，接近或超过经典RM调度可调度上限~69%）的任务。这类任务往往是 **CPU密集型** 且对 **时间要求严格（如关键控制循环）**。&gt;     *   **‘低资源占用’任务：** 指 `U_i` 较低的任务。这类任务通常计算量小、周期相对较短，属于 **轻量级周期性任务（如数据采集、状态监控）**。&gt;&gt; 2.  **调度策略：** 我们为两类任务分别应用最匹配的经典实时调度算法：&gt;     *   **对于高资源占用/CPU密集型任务：** 采用 **EDF (最早截止时间优先)** 算法。EDF **动态地** 选择当前就绪队列中截止时间 (`D_i`) 最早的任务执行。它能在可调度条件下 **达到最高的CPU利用率（理论100%）**，非常适合于需要高利用率保障的关键任务。&gt;     *   **对于低资源占用/轻量级任务：** 采用 **RM (单调速率)** 算法。RM **静态地** 根据任务周期 (`T_i`) 分配优先级——周期越短（速率越高），优先级越高。它实现 **简单**，并且在满足可调度性条件下（`ΣU_i &lt;= n(2^(1/n) - 1)`）能保证所有任务满足截止时间，特别适合大量低开销的周期任务。&gt;&gt; 3.  **如何‘匹配’：**&gt;     *   **任务分类与分配：** 在任务创建时（或系统初始化时），根据其声明的周期 (`T_i`) 和最坏执行时间 (`WCET, C_i`)，计算其占用率 `U_i`。&gt;     *   **划分调度域：** 系统维护 **两个逻辑上的调度域 (Scheduling Domains)**：&gt;         *   **EDF 域：** 容纳所有被分类为“高资源占用”的任务。该域内部使用 **纯EDF算法** 进行调度。&gt;         *   **RM 域：** 容纳所有被分类为“低资源占用”的任务。该域内部使用 **纯RM算法** 进行调度。&gt;     *   **域间调度 (关键点)：** 两个域之间的任务如何竞争CPU资源？我们采用了一种 **全局固定优先级仲裁** 策略：&gt;         *   **EDF域被赋予比RM域更高的全局固定优先级。** 这意味着，只要EDF域中有就绪任务，就先调度EDF域的任务（由EDF算法在其域内选一个）。仅当EDF域没有就绪任务时，才调度RM域的任务（由RM算法在其域内选一个）。&gt;         *   *(注：这是常见策略之一，也可以设计其他策略如全局EDF，但固定优先级隔离更简单，利于分析域间干扰)*。&gt;&gt; **设计思路总结与优势：**&gt; *   **核心目标：** 让 **CPU密集型且时间关键的任务 (高`U_i`) 享受EDF的高利用率优势**，同时让 **大量轻量级任务 (低`U_i`) 在RM的简单、鲁棒框架下运行**。&gt; *   **优势：** 相比于单一使用RM，该模型 **允许系统整体承载更高利用率** 的任务集（因为高U任务用了EDF）。相比于单一使用EDF，该模型对 **大量低U任务的管理可能更简单、更鲁棒**（RM的静态优先级在任务数多时开销可能更低，行为更易预测），并且 **天然隔离了不同SLA要求的任务**。通过这种‘分而治之’的策略，**联合模型旨在结合EDF和RM各自的优点，达到系统整体效用的帕累托优化**。*   “**Rust异步I/O机制优化任务处理速度，减少20%-40%系统调用开销**”：请详细说明你是如何使用Rust异步I/O（比如`async/await` + `tokio`/`async-std`）来实现优化的？具体减少了哪些类型的系统调用？如何测量和验证这个20-40%的提升？*   “**实现调度策略对比测试...完成内核恐慌日志分析与修复**”：你测试了哪些调度策略？对比的指标是什么？遇到了什么样的内核恐慌（Kernel Panic）？你是如何定位和修复的？请描述调试过程。*   这个框架的“**适应性**”和“**扩展性**”具体体现在哪些方面？架构上是如何设计的？*   为什么选择Rust而不是C/C++来做这个项目？Rust在系统编程中的优势（所有权、生命周期、无畏并发）在你的项目中是如何体现的？    **“面试官，我们选择Rust而非C/C++主要基于三个核心优势，这些优势在**系统级开发**中直接解决了传统语言的痛点：**    #### **1. 所有权机制（Ownership）与内存安全：**    * **项目痛点：** 在开发**操作系统微内核**和**多线程TCP服务器**时，手动管理内存（如C/C++）极易引入`use-after-free`、`double-free`或内存泄漏，导致内核崩溃或服务宕机。    * **Rust解决方案：**          * 通过**编译期所有权规则**（移动语义、借用检查器），强制保证：        * 每个值只有一个所有者，避免悬垂指针。        * 作用域结束时自动释放资源（无GC开销）。        * **项目体现：**          * 在**TCP服务器的线程安全队列**中，`Arc&lt;Mutex&lt;T&gt;&gt;` 在编译期保证多线程共享数据的安全性，避免竞态条件（Race Conditions）。        * 在**操作系统任务调度器**中，任务句柄的所有权转移确保资源不被非法访问。    #### **2. 无畏并发（Fearless Concurrency）：**    * **项目痛点：** C/C++的并发需依赖开发者经验（如手动加锁），调试难度大，易死锁。    * **Rust解决方案：**          * 所有权机制天然支持并发安全：        * `Send` trait 允许跨线程传递所有权。        * `Sync` trait 允许多线程安全共享引用。        * **项目体现：**          * **TCP服务器**采用 `tokio` 异步运行时，基于 `async/await` 实现非阻塞I/O。编译器确保**异步任务间无数据竞争**，我们轻松实现 **300+ QPS 高并发处理** 且 **99.9% 可用性**。        * **OS调度器**的联合调度模型中，Rust保证跨核任务调度无并发错误。    #### **3. 零成本抽象与性能：**    * **项目痛点：** C++的抽象可能引入运行时开销（如虚函数），C则缺乏现代抽象能力。    * **Rust解决方案：**          * 所有权、trait、模式匹配等特性在**编译期优化**，生成代码效率匹敌C/C++。        * **项目体现：**          * 在**OS框架中**，用Rust异步I/O减少 **20%-40% 系统调用开销**（对比同步阻塞模型）。        * **TCP服务器**的Reactor模式通过 `mio` 库实现**零额外开销**的事件驱动。    #### **对比C/C++的额外优势：**    * **工具链现代化：** `Cargo` 管理依赖、构建、测试（对比Makefile/CMake）。    * **模式匹配与错误处理：** `Result`/`Option` 强制处理错误（避免C/C++未检查错误）。    * **无未定义行为（Undefined Behavior）：** 编译期拦截空指针、越界访问（内核开发关键）。</code></pre><ul><li><h3 id="多线程-tcp-服务器开发rust">1. <strong>多线程 TCP服务器开发（Rust）：</strong></h3><ul><li>“<strong>采用Reactor模式实现非阻塞I/O</strong>”：请解释一下你实现的Reactor模式的核心组件（Reactor,Demultiplexer, EventHandlers）是如何工作的？你使用了哪个库（如<code>mio</code>,<code>tokio</code>）？</li><li>“<strong>设计线程安全的任务队列和数据共享</strong>”：你具体采用了什么机制来保证线程安全？（如<code>Arc&lt;Mutex&lt;T&gt;&gt;</code>,<code>Arc&lt;RwLock&lt;T&gt;&gt;</code>, <code>crossbeam-channel</code>,<code>tokio::sync::mpsc</code>等）选择它们的理由？有没有考虑无锁队列？</li><li>“<strong>峰值处理能力达300+请求/秒</strong>”：这个测试是在什么环境下进行的（硬件配置、并发客户端数、请求类型/大小）？瓶颈主要在哪里？CPU、内存、网络I/O？</li><li>“<strong>解决竞争条件</strong>”：你遇到了什么样的竞争条件？是如何发现（如死锁、数据错乱）和解决的？</li><li>“<strong>分层架构实现模块解耦</strong>”：具体分成了哪几层？层与层之间如何通信？这样设计的好处？</li><li>如何确保“<strong>99.9%运行时间</strong>”（高可用）？做了哪些容错或恢复机制？</li></ul></li></ul><ol start="2" type="1"><li><strong>基于贝叶斯优化的系统参数自动化调优框架（Python）：</strong><ul><li>这个框架是用来优化什么系统的参数？目标性能指标是什么？（如延迟、吞吐量、资源利用率）</li><li>“<strong>提高贝叶斯优化的超参数搜索效率</strong>”：你具体采用了什么技术或策略来提高效率？（如代理模型选择、采集函数优化、并行化、热启动等）</li><li>“<strong>数据变换和核函数优化，使 BIC评分优化30%</strong>”：具体做了哪些数据变换？优化了哪个贝叶斯优化模型的核函数？为什么这些优化能提升BIC评分？BIC评分在这里代表什么？</li><li>对比贝叶斯优化和随机搜索，在<strong>学习曲线</strong>和<strong>均值差距</strong>上具体有哪些显著差异？说明了什么问题？</li></ul></li><li><strong>智能菜市场物联网数据平台后端（Spring Boot）：</strong><ul><li>“<strong>针对高并发数据接入场景（日均5000+条设备数据）...采用分库分表策略</strong>”：日均5000+条数据并不算特别大，当时为什么决定采用分库分表？是基于对未来增长的预估吗？具体如何设计分片键（ShardingKey）？采用了什么分库分表中间件（如ShardingSphere）还是自研？</li><li>“<strong>通过联合索引将查询耗时从300-400ms降低至80-150ms</strong>”：请描述这个慢查询的具体场景（SQL语句片段、表结构、数据量）？你创建的联合索引是哪些字段？为什么这个索引有效？（结合最左前缀原则、覆盖索引等解释）</li><li>“<strong>设计模块化分层架构（Controller-Service-DAO）</strong>”：在“设备管理、数据管理、告警处理等模块”的抽象过程中，如何保证模块间的边界清晰？有没有使用到设计模式（如工厂模式、策略模式）？</li><li>“<strong>Docker容器化部署...单节点资源占用减少30%</strong>”：相比传统部署方式，容器化是如何实现资源占用减少的？（资源隔离、更轻量级、避免环境差异等）有使用编排工具（如K8s）吗？</li><li>作为实习生，你在整个项目中承担的具体职责和贡献的比例大概是多少？遇到的最大的挑战是什么？</li></ul></li></ol><p><strong>二、 核心技术基础(重点考察“必须具备的”和“加分项”)</strong></p><ol type="1"><li><strong>编程语言：</strong><ul><li><strong>C++：</strong>你熟悉到什么程度？了解RAII、智能指针、移动语义、多态、模板元编程吗？能简单举例说明。</li><li><strong>Rust：</strong>所有权和生命周期机制的核心思想是什么？它们如何帮助解决内存安全和数据竞争问题？<code>Send</code>和<code>Sync</code>trait的作用？你在项目中遇到的最典型的借用检查器挑战是什么，如何解决的？</li><li><strong>Java：</strong> SpringBoot的核心优势是什么？IoC和AOP是如何工作的？你了解的垃圾回收算法有哪些？（如G1,CMS, ZGC的特点）</li><li><strong>Python：</strong>主要用在什么地方？（脚本、数据分析、框架）了解GIL吗？对多线程编程有什么影响？</li></ul></li><li><strong>网络：</strong><ul><li>TCP和UDP的核心区别是什么？各自适用于什么场景？</li><li>详细描述TCP三次握手和四次挥手的过程。为什么需要三次握手？<code>TIME_WAIT</code>状态的作用是什么？</li><li>什么是TCP粘包/拆包？常见的解决方案有哪些？（如消息头包含长度、特定分隔符）</li><li>在Rust TCP服务器项目中，如何处理大量并发连接？（Reactor/Proactor,线程池）</li><li>HTTP协议是基于TCP还是UDP？HTTP/1.1, HTTP/2, HTTP/3的主要区别？</li><li>了解常见的RPC框架（如gRPC, Thrift）吗？它们解决了什么问题？</li></ul></li><li><strong>操作系统：</strong><ul><li>进程和线程的区别？协程（Coroutine）呢？Rust的<code>async/await</code>底层可以看作协程吗？</li><li>进程间通信（IPC）有哪些方式？（管道、消息队列、共享内存、信号量、Socket）各有什么优缺点？你在项目中用过哪些？</li><li>线程同步机制有哪些？（互斥锁、读写锁、条件变量、信号量、原子操作）解释死锁及其必要条件、预防/避免方法。</li><li>虚拟内存是什么？有什么作用？（内存管理、内存保护、内存共享）</li><li>系统调用（SystemCall）是什么？用户态和内核态切换的代价是什么？为什么Rust异步I/O能减少系统调用开销？（批处理、用户态调度）</li><li>你理解的“微内核”架构和“宏内核”（如Linux）的主要区别是什么？各自的优缺点？</li></ul></li><li><strong>数据结构与算法：</strong><ul><li>数组和链表的区别？各自的适用场景？</li><li>哈希表（HashTable）的原理是什么？如何解决哈希冲突？（开放寻址法、链地址法）影响哈希表性能的关键因素？</li><li>常见的树结构有哪些？（二叉树、二叉搜索树、平衡二叉树如AVL/红黑树、B树/B+树）MySQL索引通常用什么结构？（B+树）为什么？</li><li>描述快速排序（QuickSort）的思想和平均/最坏时间复杂度。如何优化最坏情况？</li><li>写一个简单的算法题（面试官现场出题，可能涉及数组、字符串、链表、树、二分查找、简单DP等）。</li></ul></li><li><strong>数据库：</strong><ul><li>数据库事务的ACID特性是什么？</li><li>MySQL的InnoDB存储引擎有哪些特性？（事务、行锁、MVCC）</li><li>数据库索引的作用？什么情况下索引会失效？（如对索引列进行函数操作、使用<code>!=</code>或<code>NOT IN</code>、未满足最左前缀原则等）</li><li>解释一下MVCC（多版本并发控制）是如何工作的？</li><li>数据库锁有哪些类型？（共享锁、排他锁、意向锁）什么是死锁？如何避免？</li><li>分库分表是为了解决什么问题？（水平扩展、性能瓶颈）会带来哪些挑战？（分布式事务、跨库查询、全局唯一ID）</li><li>NoSQL数据库（如Redis,MongoDB）的特点和适用场景？Redis常用数据类型及其应用场景？</li></ul></li><li><strong>软件工程 &amp; 设计模式：</strong><ul><li>你如何理解面向对象编程（OOP）的四大特性（抽象、封装、继承、多态）？</li><li>了解哪些设计模式？能在你的项目经历中找到应用吗？（如SpringBoot项目中的分层架构体现了关注点分离，工厂模式可能用于创建对象，策略模式可能用于选择不同算法/策略）</li><li>什么是SOLID设计原则？能简要解释每个原则吗？</li><li>如何保证代码质量？（单元测试、集成测试、代码评审、静态代码分析、CI/CD）</li></ul></li><li><strong>分布式系统 &amp; 高可用 &amp; 云原生 (加分项重点)：</strong><ul><li>解释一下CAP定理和BASE理论。</li><li>什么是分布式事务？常见的解决方案有哪些？（两阶段提交2PC、三阶段提交3PC、TCC、基于消息队列的最终一致性）</li><li>如何设计一个高可用（HighAvailability）的服务？有哪些常用手段？（冗余/集群、负载均衡、故障转移Failover、熔断、降级、限流）</li><li>负载均衡有哪些常见的算法？（轮询、加权轮询、最少连接、源IP哈希）</li><li>什么是服务发现？为什么在微服务架构中需要它？</li><li>你提到了“<strong>系统容灾设计</strong>”，谈谈你的理解？常见的容灾方案？（同城多活、异地多活、备份与恢复）</li><li>“<strong>对云原生相关技术有所了解</strong>”：你理解的云原生是什么？它的关键技术包括哪些？（容器化Docker、编排Kubernetes、服务网格Istio、微服务、声明式API、不可变基础设施）你用过哪些？</li><li>你在简历中提到AmazonEC2，主要用它来做什么？（部署、测试）了解其他AWS服务吗？（如S3, RDS,Lambda）</li></ul></li></ol><p><strong>三、 系统设计与场景题 (重点考察分析和设计能力)</strong></p><ol type="1"><li><strong>设计一个短链接生成系统（类似TinyURL）：</strong><ul><li>核心功能：将长URL转成短URL；访问短URL重定向到原始长URL。</li><li>需要考虑：高并发生成与访问、短URL的生成算法（如何保证不重复、长度短）、存储设计（用什么数据库？如何设计表？）、重定向性能（缓存？）、如何防止恶意攻击（刷接口）？</li></ul></li><li><strong>设计一个简单的消息队列：</strong><ul><li>核心功能：生产者发送消息、消费者订阅并消费消息、消息持久化（可选）。</li><li>需要考虑：如何保证消息不丢失？如何保证消息顺序（如果需要）？消费者如何处理失败的消息（重试、死信队列）？如何实现多消费者？如何扩展？</li></ul></li><li><strong>你开发的Rust TCP服务器，如果流量突然增长10倍（3000+req/s），可能遇到哪些瓶颈？你会如何优化？</strong>(结合你的项目经验)</li><li><strong>智能菜市场平台的后端，如果数据库写入成为瓶颈（比如大量设备同时上报数据），除了分库分表，还有哪些优化思路？</strong>(如消息队列削峰填谷、批量写入、优化数据库配置、使用更快的存储硬件/SSD、考虑时序数据库TSDB)</li></ol><p><strong>四、 问题排查与性能优化 (考察实战能力)</strong></p><ol type="1"><li><strong>线上服务突然响应变慢，甚至部分超时，你会如何一步步排查定位问题？</strong>(思路：监控指标查看 - CPU/内存/磁盘IO/网络带宽、日志分析 -错误/慢查询日志、链路追踪分析、数据库状态检查、代码Review最近变更、压测复现等)</li><li><strong>数据库查询变慢，如何排查和优化？</strong>(思路：<code>EXPLAIN</code>分析SQL执行计划、检查索引是否有效/缺失、优化SQL语句、调整数据库配置参数、考虑读写分离、升级硬件)</li><li><strong>在Rust项目中解决内核恐慌（KernelPanic）的经历，体现了你的问题排查能力。能再举一个你解决过的复杂线上或开发中问题的例子吗？描述现象、分析过程和最终解决方案。</strong></li></ol><p><strong>五、 软技能与职业发展</strong></p><ol type="1"><li>你如何理解这个岗位的职责？（结合岗位描述复述并加入自己的理解）</li><li>为什么选择我们公司/这个部门（云架构平台部）？你对云计算/云原生平台哪方面最感兴趣？</li><li>你平时是如何学习新技术的？最近在学习或关注什么技术？</li><li>在团队协作中，如果和产品经理或前端工程师在需求或实现方式上有分歧，你会如何处理？</li><li>你的职业发展规划是什么？（短期1-2年，长期3-5年）</li><li>你有什么问题想问我们？（<strong>务必准备2-3个有深度的问题</strong>，体现你对岗位和公司的兴趣和思考，例如：团队当前的技术栈和主要挑战？部门对云原生技术的落地规划？新人的培养机制？）</li></ol><p><strong>面试准备建议：</strong></p><ol type="1"><li><strong>STAR法则强化项目描述：</strong>针对简历上的每一个项目点（尤其是你贡献最大的部分），用STAR法则（Situation,Task, Action,Result）准备清晰、具体的回答，<strong>重点突出你的思考、行动和可量化的成果</strong>。</li><li><strong>基础知识复盘：</strong>系统复习操作系统、网络、数据库、数据结构算法、设计模式的核心概念。不仅要懂是什么，还要理解为什么。</li><li><strong>Rust深度准备：</strong>作为你简历的显著亮点，务必深入理解Rust的核心特性（所有权、生命周期、借用检查、并发模型<code>async/await</code>）、常用库（<code>tokio</code>,<code>serde</code>等）以及你在项目中应用它们的细节和遇到的挑战。</li><li><strong>分布式/云原生概念梳理：</strong>理解CAP、负载均衡、服务发现、熔断降级限流、容器化、K8s核心概念等。即使没有深入项目经验，也要能清晰表达概念和基本原理。</li><li><strong>设计题练习：</strong>找一些经典的系统设计面试题进行思路练习，注意沟通、需求澄清、逐步推导的过程。</li><li><strong>量化成果再确认：</strong>回顾项目中的性能提升、资源节省等数据，确保清晰记得是如何得出的，并能解释其意义。</li><li><strong>模拟面试：</strong>找同学或朋友进行模拟面试，重点练习表达流畅度、项目描述的清晰度和应对压力问题的能力。</li><li><strong>公司/部门研究：</strong>深入了解目标公司云架构平台部的业务、技术博客（如果有）、使用的技术栈（如果能了解到），在回答“为什么选择我们”和提问环节体现出来。</li><li><strong>准备问题：</strong>准备好要问面试官的问题，展示你的主动性和兴趣。</li></ol><p><strong>特别注意：</strong></p><ul><li><strong>诚实第一：</strong>对于不了解的知识点，坦诚承认并表示愿意学习，切忌不懂装懂。</li><li><strong>突出亮点：</strong>反复强调Rust系统级开发、分布式架构设计（分库分表、高并发优化）、云原生实践（Docker）这几个核心竞争力。</li><li><strong>沟通清晰：</strong>表达要有条理，技术术语使用准确，语速适中。</li><li><strong>展现热情：</strong>表现出对后台开发、云技术、解决复杂技术问题的热情。</li></ul><p>祝你面试顺利，拿到心仪的Offer！加油！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;把面试可能遇到的题目和回答存一下，面完来看看有哪些问到了&lt;/p&gt;
&lt;p&gt;我的简历项目有四个：通用操作系统框架（Rust，研究生阶段跟着导师组里做的项目），多线程
TCP
服务器开发（Rust），基于贝叶斯优化的系统参数自动化调优框架（Python），智能菜市场物联网数</summary>
      
    
    
    
    <category term="interview" scheme="https://mackz-maxw.github.io/categories/interview/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-回溯算法4</title>
    <link href="https://mackz-maxw.github.io/2025/06/06/kamacode22/"/>
    <id>https://mackz-maxw.github.io/2025/06/06/kamacode22/</id>
    <published>2025-06-06T17:26:48.385Z</published>
    <updated>2025-06-06T22:49:28.880Z</updated>
    
    <content type="html"><![CDATA[<h3 id="递增子序列">491.递增子序列</h3><p>题解说这里用数组做哈希，效率会更高 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">findSS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt; path, <span class="type">int</span> left)</span></span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; used; <span class="comment">// 当前层去重</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left; i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used.<span class="built_in">find</span>(nums[i]) != used.<span class="built_in">end</span>())<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(path.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                used.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">                <span class="built_in">findSS</span>(nums, path, i+<span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!path.<span class="built_in">empty</span>() &amp;&amp; nums[i]&gt;=path.<span class="built_in">back</span>())&#123;</span><br><span class="line">                <span class="comment">// if(i&gt;left &amp;&amp; nums[i-1] == nums[i])continue; // 重复元素不一定相邻</span></span><br><span class="line">                path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                result.<span class="built_in">push_back</span>(path);</span><br><span class="line">                used.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">                <span class="built_in">findSS</span>(nums, path, i+<span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">findSS</span>(nums, path, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="全排列">46.全排列</h3><ol type="1"><li><strong>索引限制错误</strong>：<ul><li>使用 <code>left</code>参数限制选择范围，导致只能生成<strong>索引递增的子序列</strong>而非全排列</li><li>例如输入 <code>[1,2,3]</code> 时，代码只能生成<code>[1,2,3]</code>，无法生成 <code>[2,1,3]</code> 等排列</li></ul></li><li><strong>缺少元素使用状态跟踪</strong>：<ul><li>排列需要从<strong>所有未使用元素</strong>中选择，而不仅仅是当前索引后的元素</li><li>没有记录哪些元素已被使用，导致：<ul><li>无法重新选择左侧元素</li><li>无法避免重复使用同一元素</li></ul></li></ul></li><li><strong>递归逻辑错误</strong>：<ul><li>每次递归都从 <code>i+1</code> 开始，使得路径只能向右扩展</li><li>排列需要任意顺序组合，需能回头选择左侧元素</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">perm</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt;&amp; path, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;  <span class="comment">// 必须遍历所有元素</span></span><br><span class="line">            <span class="keyword">if</span> (used[i]) <span class="keyword">continue</span>;  <span class="comment">// 跳过已用元素</span></span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">perm</span>(nums, path, used);  <span class="comment">// 注意：这里递归时不限制索引</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;  <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;  <span class="comment">// 添加使用状态数组</span></span><br><span class="line">        <span class="built_in">perm</span>(nums, path, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="全排列-ii">47.全排列 II</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">perm</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt; path, vector&lt;<span class="type">bool</span>&gt;&amp; used)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="comment">// return;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(used[i] == <span class="literal">true</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// used[i - 1] == true，说明同一树枝nums[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span></span><br><span class="line">            <span class="comment">// 👇同一层使用过则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; used[i<span class="number">-1</span>] == <span class="literal">false</span>)<span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">perm</span>(nums, path, used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">perm</span>(nums, path, used);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;递增子序列&quot;&gt;491.递增子序列&lt;/h3&gt;
&lt;p&gt;题解说这里用数组做哈希，效率会更高 &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-回溯算法3</title>
    <link href="https://mackz-maxw.github.io/2025/06/05/kamacode21/"/>
    <id>https://mackz-maxw.github.io/2025/06/05/kamacode21/</id>
    <published>2025-06-05T19:13:40.053Z</published>
    <updated>2025-06-05T22:59:03.385Z</updated>
    
    <content type="html"><![CDATA[<h3 id="复原ip地址">93.复原IP地址</h3><p>手动写了<code>to_string()</code>和<code>stoi()</code>,发现字符串给整反了，改过来了也发现效率不如用现有函数这题需要注意的限制条件确实很多 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="function">string <span class="title">pathToIp</span><span class="params">(vector&lt;<span class="type">int</span>&gt; path)</span></span>&#123;</span><br><span class="line">        string ip;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;path.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            ip += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">            <span class="keyword">if</span>(i != (path.<span class="built_in">size</span>()<span class="number">-1</span>))ip.<span class="built_in">push_back</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resIp</span><span class="params">(string s, vector&lt;<span class="type">int</span>&gt; path, <span class="type">int</span> div)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.<span class="built_in">size</span>() == <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(div == s.<span class="built_in">size</span>())result.<span class="built_in">push_back</span>(<span class="built_in">pathToIp</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = div; i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            string cur = s.<span class="built_in">substr</span>(div, i-div+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(cur.<span class="built_in">size</span>() &gt; <span class="number">3</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> curN = <span class="built_in">stoi</span>(cur);</span><br><span class="line">            <span class="keyword">if</span>(cur.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; cur[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(curN &gt; <span class="number">255</span>)<span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(curN);</span><br><span class="line">            <span class="built_in">resIp</span>(s, path, i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &gt; <span class="number">12</span>) <span class="keyword">return</span> result;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">resIp</span>(s, path, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="子集">78. 子集</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ssets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt; path, <span class="type">int</span> left)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// if(i&gt;left &amp;&amp; nums[i] == nums[i-1])continue;</span></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="built_in">ssets</span>(nums, path, i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path); <span class="comment">// 带上空集</span></span><br><span class="line">        <span class="built_in">ssets</span>(nums, path, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="子集ii">90.子集II</h3><p>和上一篇中的40题一样，题解的used数组和<code>i&gt;left</code>去重都可以，不过这回似乎<code>i&gt;left</code>去重runtime也不低<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ssets</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;<span class="type">int</span>&gt; path, <span class="type">int</span> left)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;left &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="built_in">ssets</span>(nums, path, i+<span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path); <span class="comment">// 带上空集</span></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">ssets</span>(nums, path, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;复原ip地址&quot;&gt;93.复原IP地址&lt;/h3&gt;
&lt;p&gt;手动写了&lt;code&gt;to_string()&lt;/code&gt;和&lt;code&gt;stoi()&lt;/code&gt;,发现字符串给整反了，改过来了也发现效率不如用现有函数
这题需要注意的限制条件确实很多 &lt;figure clas</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-回溯算法2</title>
    <link href="https://mackz-maxw.github.io/2025/06/04/kamacode20/"/>
    <id>https://mackz-maxw.github.io/2025/06/04/kamacode20/</id>
    <published>2025-06-04T15:50:22.283Z</published>
    <updated>2025-06-05T22:57:56.733Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组合总和">39. 组合总和</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">combSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; path, <span class="type">int</span> left, vector&lt;<span class="type">int</span>&gt;&amp; candi, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="number">0</span>)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(candi[<span class="number">0</span>] &gt; t)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left;i&lt; candi.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(candi[i] &lt;= t)&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(candi[i]);</span><br><span class="line">                <span class="built_in">combSum</span>(path, i, candi, t-candi[i]);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123; <span class="comment">// candidate不是递增的</span></span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">combSum</span>(path, <span class="number">0</span>, candidates, target);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="introsortintrosort">✅<strong>Introsort</strong>（IntroSort）</h4><p>C++ 中的 <code>std::sort()</code>（定义在<code>&lt;algorithm&gt;</code> 中）默认使用的是一种由<strong>三种排序算法组合而成的混合排序算法</strong></p><h4 id="introsort-的组成">🔧 Introsort 的组成：</h4><ol type="1"><li><p><strong>快速排序（Quicksort）</strong>：在数据量大、分布均匀时使用，速度快，期望时间复杂度是O(n log n)。</p></li><li><p><strong>堆排序（Heapsort）</strong>：当递归深度超过一定阈值（防止最坏情况O(n²)）时退化为堆排序，保证最坏时间复杂度也是 O(n log n)。</p></li><li><p><strong>插入排序（Insertion Sort）</strong>：在小数据范围（如&lt;16）时使用，性能优于快速排序。</p></li></ol><h3 id="组合总和ii">40.组合总和II</h3><p><code>i &gt; left &amp;&amp; candi[i] == candi[i-1]</code>和题解中创建candidate长度的<code>i &gt; 0 &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == false</code>都可以达到剪去重复，代码AC的效果如果使用<code>i &gt; left &amp;&amp; candidates[i] == candidates[i - 1] &amp;&amp; used[i - 1] == false</code>可以提高代码效率</p><p>注意题解中used数组只用来剪去同一层的重复数字，所以递归调用后<code>used[i]</code>要设置回<code>false</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">comb</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candi, <span class="type">int</span> left, vector&lt;<span class="type">int</span>&gt; path, <span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t == <span class="number">0</span>)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left; i&lt; candi.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(candi[i] &gt; t)<span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; left &amp;&amp; candi[i] == candi[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(candi[i]);</span><br><span class="line">            <span class="built_in">comb</span>(candi, i+<span class="number">1</span>, path, t-candi[i]);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">comb</span>(candidates, <span class="number">0</span>, path, target);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="分割回文串">131.分割回文串</h3><p>如题解所说，难点在于认识到切割问题和组合问题类似——每个位置是否“切”——每种切法就是一条树枝，还有求是否是回文串部分的优化<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; pal;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">isPal</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        pal.<span class="built_in">resize</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = (s.<span class="built_in">size</span>()<span class="number">-1</span>); i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j&lt;= (s.<span class="built_in">size</span>()<span class="number">-1</span>);j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == i)&#123;</span><br><span class="line">                    pal[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>((j - i) == <span class="number">1</span>)&#123;</span><br><span class="line">                    pal[i][j] = s[i] == s[j] ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    pal[i][j] = (s[i] == s[j] &amp;&amp; pal[i+<span class="number">1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">partPal</span><span class="params">(vector&lt;string&gt; path, string s, <span class="type">int</span> div)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(div == s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = div; i &lt; s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pal[div][i] == <span class="literal">true</span>)&#123;</span><br><span class="line">                path.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(div, i-div+<span class="number">1</span>));</span><br><span class="line">                <span class="built_in">partPal</span>(path, s, i+<span class="number">1</span>);</span><br><span class="line">                path.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; path;</span><br><span class="line">        <span class="built_in">isPal</span>(s);</span><br><span class="line">        <span class="built_in">partPal</span>(path, s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;组合总和&quot;&gt;39. 组合总和&lt;/h3&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;li</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-回溯算法1</title>
    <link href="https://mackz-maxw.github.io/2025/06/03/kamacode19/"/>
    <id>https://mackz-maxw.github.io/2025/06/03/kamacode19/</id>
    <published>2025-06-03T22:42:17.876Z</published>
    <updated>2025-06-06T22:55:47.526Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组合">77. 组合</h3><p>虽然runtime离谱地高，但是俺居然自己寻思出了怎么回溯，可喜可贺：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">comb</span><span class="params">(vector&lt;<span class="type">int</span>&gt; curNums, <span class="type">int</span> l, <span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(curNums.<span class="built_in">size</span>() == k)&#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(curNums);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// for(int i = l; i&lt;= r;i++)&#123;// 能想明白l和r的关系我已经很不容易了</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = l; i&lt;= r-(k-curNums.<span class="built_in">size</span>())+<span class="number">1</span>;i++)&#123; </span><br><span class="line">                <span class="comment">// 👆 看了题解发现我想不明白的地方（i最大取多少）应该每次循环重新算而不是代入递归，用于剪枝</span></span><br><span class="line">                curNums.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="built_in">comb</span>(curNums, i+<span class="number">1</span>, r, k);</span><br><span class="line">                curNums.<span class="built_in">pop_back</span>();<span class="comment">// 最重要的一句</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; cur;</span><br><span class="line">            <span class="built_in">comb</span>(cur, <span class="number">1</span>, n, k);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 这种写法的时间复杂度<strong>不是</strong><code>O(n * 2^n)</code></p><h4 id="实际代码做的事情">🚩实际代码做的事情：</h4><p>这段代码实现的是 <strong>从 <code>1</code> 到 <code>n</code> 中选择<code>k</code> 个数的所有组合</strong>，即 <strong>组合数 C(n,k)</strong>。</p><p>所以：</p><h4 id="正确时间复杂度是">✅ 正确时间复杂度是：</h4><p><span class="math inline">\(O(C(n, k) \cdot k)\)</span></p><p>解释如下：</p><ul><li><p>一共会生成 <span class="math inline">\(C(n, k)\)</span>个组合，每个组合长度是 <code>k</code></p></li><li><p>每次 <code>curNums</code> 达到长度 <code>k</code> 就复制一次<code>curNums</code> 到结果 <code>res</code> 中</p></li><li><p>每次复制 <code>k</code> 个元素，因此时间复杂度为 <spanclass="math inline">\(O(k)\)</span></p></li><li><p>总时间复杂度为： <span class="math inline">\(O(C(n, k) \cdotk)\)</span></p></li></ul><h4 id="那为什么会看到-on-2n-的说法">❓那为什么会看到<code>O(n * 2^n)</code> 的说法？</h4><p>这个复杂度常出现在<strong>子集枚举</strong>问题（powerset）中，比如“所有子集”或“子集和”等问题，使用类似回溯结构但<strong>允许选择/不选择每个元素</strong>，即二叉树结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) &#123; </span><br><span class="line">   <span class="comment">// include or skip i —&gt; 2^n branches</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选出来的每个子集的<strong>长度</strong>是<strong>从1到n</strong>的，而本题组合问题选出来的组合长度固定为<strong>K</strong></p><h3 id="组合总和iii">216.组合总和III</h3><p>和上题基本思想差不多，多了一些限制条件 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">comb</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> k, <span class="type">int</span> l, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(nums);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">min</span>(<span class="number">9</span>, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = l; i&lt;=r;i++)&#123;</span><br><span class="line">            nums.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="built_in">comb</span>(nums, k<span class="number">-1</span>,i+<span class="number">1</span>, n-i);</span><br><span class="line">            nums.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="built_in">comb</span>(nums,k,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="电话号码的字母组合">17.电话号码的字母组合</h3><p>注意终止条件是索引数加一 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> string digToStr[<span class="number">10</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">        <span class="string">&quot;def&quot;</span>,</span><br><span class="line">        <span class="string">&quot;ghi&quot;</span>,</span><br><span class="line">        <span class="string">&quot;jkl&quot;</span>,</span><br><span class="line">        <span class="string">&quot;mno&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pqrs&quot;</span>,</span><br><span class="line">        <span class="string">&quot;tuv&quot;</span>,</span><br><span class="line">        <span class="string">&quot;wxyz&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;string&gt; result;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">comb</span><span class="params">(string str, string digits, <span class="type">int</span> ind)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ind == digits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> d = digits[ind] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        ind++;</span><br><span class="line">        string s = digToStr[d];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s)&#123;</span><br><span class="line">            str.<span class="built_in">push_back</span>(c);</span><br><span class="line">            <span class="built_in">comb</span>(str, digits, ind);</span><br><span class="line">            str.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">empty</span>())<span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">comb</span>(str, digits, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;组合&quot;&gt;77. 组合&lt;/h3&gt;
&lt;p&gt;虽然runtime离谱地高，但是俺居然自己寻思出了怎么回溯，可喜可贺：
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-二叉树8</title>
    <link href="https://mackz-maxw.github.io/2025/06/01/kamacode18/"/>
    <id>https://mackz-maxw.github.io/2025/06/01/kamacode18/</id>
    <published>2025-06-02T01:09:33.056Z</published>
    <updated>2025-06-02T21:20:58.161Z</updated>
    
    <content type="html"><![CDATA[<h3 id="修剪二叉搜索树">669.修剪二叉搜索树</h3><p>重点是理解当某个节点要删除时，返回的节点的逻辑我的思路是觉得剪除根两边的孩子节点和只取一个子树中的部分节点应该分开讨论，看了题解发现部分代码是可以一起的题解的思路也可以理解为先处理<code>root-&gt;val</code>自身，后处理子树</p><blockquote><p>如果root（当前节点）的元素小于low的数值，那么应该递归右子树，并返回右子树符合条件的头结点。如果root(当前节点)的元素大于high的，那么应该递归左子树，并返回左子树符合条件的头结点。将下一层处理完左子树的结果赋给root-&gt;left，处理完右子树的结果赋给root-&gt;right。最后返回root节点</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="type">int</span> low, <span class="type">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt; low)&#123;</span><br><span class="line">            TreeNode* right = <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &gt; high)&#123;</span><br><span class="line">            TreeNode* left = <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        root-&gt;left = <span class="built_in">trimBST</span>(root-&gt;left, low, high);</span><br><span class="line">        root-&gt;right = <span class="built_in">trimBST</span>(root-&gt;right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="将有序数组转换为二叉搜索树">108.将有序数组转换为二叉搜索树</h3><h4 id="问题一cen-取值错误">🔍 问题一：<code>cen</code> 取值错误</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cen = (r - l) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>这会导致<strong>始终只取左半段的中点</strong>，<strong>没有加上<code>l</code></strong>，导致选到的 <code>nums[cen]</code> 不是<code>l</code> 到 <code>r</code> 区间的中点，而是从头算的。</p><p>🔧 应该写为： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> cen = l + (r - l) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><h4 id="问题二递归边界判断不正确">🔍 问题二：递归边界判断不正确</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((cen - l) &gt; <span class="number">1</span>) ...</span><br></pre></td></tr></table></figure><p>这样写会漏掉一层子节点，导致不完整构建树。例如当子区间只剩一个元素时（<code>cen - l == 1</code>），你就跳过了构建那一侧的节点。</p><p>🔧 正确的写法是直接递归调用，只要 <code>l &lt;= r</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root-&gt;left = <span class="built_in">arrayToBST</span>(nums, l, cen - <span class="number">1</span>);</span><br><span class="line">root-&gt;right = <span class="built_in">arrayToBST</span>(nums, cen + <span class="number">1</span>, r);</span><br></pre></td></tr></table></figure> 已经在函数开头判断了 <code>l &gt; r</code> 就<code>return nullptr;</code>，所以不需要重复判断。</p><p>最终解法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">arrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt; r)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> cen = l + (r-l) / <span class="number">2</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(nums[cen]);</span><br><span class="line">        root-&gt;left = <span class="built_in">arrayToBST</span>(nums, l, cen<span class="number">-1</span>);</span><br><span class="line">        root-&gt;right = <span class="built_in">arrayToBST</span>(nums, cen+<span class="number">1</span>, r);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        TreeNode* root = <span class="built_in">arrayToBST</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="把二叉搜索树转换为累加树">538.把二叉搜索树转换为累加树</h3><p>题解提示用双指针，给我吓一跳，用回溯其实是可以解决的<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sumVal = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cvt</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">cvt</span>(root-&gt;right);</span><br><span class="line">        sumVal += root-&gt;val;</span><br><span class="line">        root-&gt;val = sumVal;</span><br><span class="line">        <span class="built_in">cvt</span>(root-&gt;left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">convertBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cvt</span>(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;修剪二叉搜索树&quot;&gt;669.修剪二叉搜索树&lt;/h3&gt;
&lt;p&gt;重点是理解当某个节点要删除时，返回的节点的逻辑
我的思路是觉得剪除根两边的孩子节点和只取一个子树中的部分节点应该分开讨论，看了题解发现部分代码是可以一起的
题解的思路也可以理解为先处理&lt;code&gt;ro</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-二叉树7</title>
    <link href="https://mackz-maxw.github.io/2025/06/01/kamacode17/"/>
    <id>https://mackz-maxw.github.io/2025/06/01/kamacode17/</id>
    <published>2025-06-01T15:18:04.114Z</published>
    <updated>2025-06-01T21:30:16.654Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉搜索树的最近公共祖先">235. 二叉搜索树的最近公共祖先</h3><p>相对二叉树的最近公共祖先简单多了 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// min 和 max</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> rt = root-&gt;val;</span><br><span class="line">        <span class="type">int</span> minV = <span class="built_in">min</span>(p-&gt;val, q-&gt;val);</span><br><span class="line">        <span class="type">int</span> maxV = <span class="built_in">max</span>(p-&gt;val, q-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(rt&gt;=minV &amp;&amp; rt&lt;=maxV)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rt &lt; minV)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p,q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="二叉搜索树中的插入操作">701.二叉搜索树中的插入操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        TreeNode* insNode = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> insNode;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; val)&#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="删除二叉搜索树中的节点">450.删除二叉搜索树中的节点</h3><p>我的想法是：先找到应该删除的节点子树-找到它的左子树最右节点-找到最右节点的父节点-将最右节点的值替换给应该删除的节点并删除最右节点题解虽然也类似地需要分情况讨论，但是简洁地多：</p><ul><li>第一种情况：没找到删除的节点，遍历到空节点直接返回了</li><li>找到删除的节点<ul><li>第二种情况：左右孩子都为空（叶子节点），直接删除节点，返回NULL为根节点</li><li>第三种情况：删除节点的左孩子为空，右孩子不为空，删除节点，右孩子补位，返回右孩子为根节点</li><li>第四种情况：删除节点的右孩子为空，左孩子不为空，删除节点，左孩子补位，返回左孩子为根节点</li><li>第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val == key)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;left)<span class="keyword">return</span> root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(!root-&gt;right)<span class="keyword">return</span> root-&gt;left;</span><br><span class="line">            TreeNode* minR = root-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(minR-&gt;left)minR = minR-&gt;left;</span><br><span class="line">            minR-&gt;left = root-&gt;left;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; key)&#123;</span><br><span class="line">            root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;二叉搜索树的最近公共祖先&quot;&gt;235. 二叉搜索树的最近公共祖先&lt;/h3&gt;
&lt;p&gt;相对二叉树的最近公共祖先简单多了 &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 八股-HTTP请求2</title>
    <link href="https://mackz-maxw.github.io/2025/06/01/kamabagu3/"/>
    <id>https://mackz-maxw.github.io/2025/06/01/kamabagu3/</id>
    <published>2025-06-01T15:16:58.534Z</published>
    <updated>2025-05-31T20:34:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="http中常见的状态码有哪些">HTTP中常见的状态码有哪些？</h3><p>HTTP 状态码用于表明特定HTTP请求是否完成</p><h4 id="xx-信息响应100199">1xx 信息响应（100–199）</h4><blockquote><p>✅“我听到了，继续吧”</p></blockquote><p>表示请求已接收，继续处理</p><ul><li><strong>100Continue</strong>：初始部分已接收，客户端应继续发送。</li><li><strong>101 SwitchingProtocols</strong>：服务器：同意更改协议。</li><li><strong>102 Processing</strong>：服务器：已收到，正在处理。</li></ul><h4 id="xx-成功响应200299">2xx 成功响应（200–299）</h4><p>表示请求已成功接收</p><blockquote><p>🎉“你请求的事我办妥了”</p></blockquote><ul><li><strong>200 OK</strong>：请求成功。</li><li><strong>201Created</strong>：请求成功并创建了新的资源（例如注册）</li><li><strong>202 Accepted</strong>：请求已接受，但未响应-不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求</li><li><strong>204 No Content</strong>：请求成功，但无返回内容。</li><li><strong>206 PartialContent</strong>：当从客户端发送Range范围标头以只请求资源的一部分时，使用此响应代码（例如断点续传）</li></ul><hr /><h4 id="xx-重定向300399">3xx 重定向（300–399）</h4><p>表示需要进一步操作以完成请求。</p><blockquote><p>🔀“去别处找”</p></blockquote><ul><li><strong>301 MovedPermanently</strong>：请求的资源已永久移动到新位置。</li><li><strong>302 Found</strong>：请求的资源临时从不同的 URI响应请求。</li><li><strong>303 See Other</strong>：请求应使用另一个 URI 获取资源。</li><li><strong>304 Not Modified</strong>：资源未修改，可使用缓存。</li><li><strong>307 Temporary Redirect</strong>：请求的资源临时从不同的 URI响应请求，方法不变。</li><li><strong>308 PermanentRedirect</strong>：请求的资源已永久移动到新位置，方法不变。</li></ul><h4 id="xx-客户端错误400499">4xx 客户端错误（400–499）</h4><p>表示请求包含语法错误或无法完成</p><ul><li><strong>400 Bad Request</strong>：请求无效，服务器无法理解。</li><li><strong>401 Unauthorized</strong>：请求要求客户端身份认证。</li><li><strong>403Forbidden</strong>：服务器知道客户端身份，但客户端没有访问权限</li><li><strong>404 Not Found</strong>：请求的资源未找到。</li><li><strong>405 Method Not Allowed</strong>：请求方法被禁止。</li><li><strong>408 Request Timeout</strong>：请求超时。</li><li><strong>429 Too ManyRequests</strong>：客户端发送的请求过多，已被限制。</li></ul><h4 id="xx-服务器错误500599">5xx 服务器错误（500–599）</h4><p>表示服务器未能完成合法的请求。</p><ul><li><strong>500 Internal ServerError</strong>：服务器内部错误，无法完成请求。</li><li><strong>501 Not Implemented</strong>：服务器不支持请求的功能。</li><li><strong>502 BadGateway</strong>：服务器作为网关或代理，从上游服务器收到错误响应。</li><li><strong>503 ServiceUnavailable</strong>：服务器当前无法处理请求。</li><li><strong>504 GatewayTimeout</strong>：服务器作为网关或代理，未及时从上游服务器收到响应。</li></ul><h3 id="什么是强缓存和协商缓存">什么是强缓存和协商缓存</h3><h4 id="一强缓存完全不发请求">🌟一、强缓存（完全不发请求）</h4><blockquote><p>关键词：<strong>直接使用缓存，不访问服务器</strong></p></blockquote><h5 id="特点">✅ 特点：</h5><ul><li>浏览器<strong>直接使用本地缓存资源</strong>。</li><li>不向服务器发请求。</li><li>若命中强缓存，状态码为 <code>200 (from memory cache)</code> 或<code>200 (from disk cache)</code>。</li></ul><h5 id="实现方式">📌 实现方式：</h5><table><colgroup><col style="width: 50%" /><col style="width: 50%" /></colgroup><thead><tr><th>字段</th><th>说明</th></tr></thead><tbody><tr><td><strong>Cache-Control: max-age=秒数</strong></td><td>（相对时间，更准确）当前资源在 N 秒内有效✅推荐</td></tr><tr><td><strong>Expires: GMT时间</strong></td><td>（绝对时间，受本地时间影响）指定资源过期时间❌已过时</td></tr></tbody></table><ol type="1"><li><p><strong>首次访问资源</strong>：<br />服务器返回资源时在响应头加上<code>Cache-Control: max-age=秒数</code>，告知浏览器这个资源可以缓存多久。</p></li><li><p><strong>再次访问时</strong>：<br />浏览器会用“当前时间 - 缓存时间”与 <code>max-age</code> 做比较：</p><ul><li>没过期 → <strong>直接用缓存，不发请求</strong>。</li><li>过期 → <strong>发起新请求，向服务器重新获取资源</strong>。</li></ul></li><li><p><strong>服务器响应更新</strong>：<br />每次服务器响应时都会更新<code>Cache-Control</code>，供下一轮缓存使用。</p></li></ol><h4id="二协商缓存发请求服务器决定是否使用缓存">🔄二、协商缓存（发请求，服务器决定是否使用缓存）</h4><blockquote><p>关键词：<strong>发请求，比较“资源是否改过”</strong></p></blockquote><h5 id="特点-1">✅ 特点：</h5><ul><li>请求时会向服务器询问资源是否有更新。</li><li>如果没变，返回 <strong>304 NotModified</strong>，继续用本地缓存。</li><li>如果变了，返回 <strong>200 + 新资源</strong>。</li></ul><h5 id="两种主流方式">📌 两种主流方式：</h5><table><colgroup><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /><col style="width: 20%" /></colgroup><thead><tr><th>方式</th><th>请求头字段</th><th>响应头字段</th><th>原理</th><th>优缺点简析</th></tr></thead><tbody><tr><td><strong>Last-Modified</strong></td><td><code>If-Modified-Since</code></td><td><code>Last-Modified</code></td><td>比较“上次修改时间”</td><td>⛔秒级精度、不改内容也可能变时间</td></tr><tr><td><strong>ETag</strong></td><td><code>If-None-Match</code></td><td><code>ETag</code></td><td>比较“文件指纹/哈希”</td><td>✅更精准，内容变才更新</td></tr></tbody></table><hr /><h4 id="三常见误区与补充">🔁三、常见误区与补充</h4><ul><li><strong>强缓存命中 → 不发请求</strong></li><li><strong>强缓存失效 → 发请求，进入协商缓存阶段</strong></li><li>如果协商缓存也失效，才真正下载新资源。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;http中常见的状态码有哪些&quot;&gt;HTTP中常见的状态码有哪些？&lt;/h3&gt;
&lt;p&gt;HTTP 状态码用于表明特定HTTP请求是否完成&lt;/p&gt;
&lt;h4 id=&quot;xx-信息响应100199&quot;&gt;1xx 信息响应（100–199）&lt;/h4&gt;
&lt;blockquote&gt;
</summary>
      
    
    
    
    <category term="comp basic" scheme="https://mackz-maxw.github.io/categories/comp-basic/"/>
    
    
  </entry>
  
</feed>
