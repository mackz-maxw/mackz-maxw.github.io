<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maxw的小站</title>
  
  <subtitle>Maxw学习记录</subtitle>
  <link href="https://mackz-maxw.github.io/atom.xml" rel="self"/>
  
  <link href="https://mackz-maxw.github.io/"/>
  <updated>2025-10-26T01:28:12.781Z</updated>
  <id>https://mackz-maxw.github.io/</id>
  
  <author>
    <name>Mackz-Maxw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码随想录 | 刷题-单调栈1</title>
    <link href="https://mackz-maxw.github.io/2025/10/25/kamacode41monos/"/>
    <id>https://mackz-maxw.github.io/2025/10/25/kamacode41monos/</id>
    <published>2025-10-26T01:27:51.591Z</published>
    <updated>2025-10-26T01:28:12.781Z</updated>
    
    <content type="html"><![CDATA[<h3 id="每日温度">739. 每日温度</h3><p>维护一个栈来记录未更新的数组值<code>using xx = xxxx</code>仅可用于为现有变量创建别名，如果数组变量名太长请创建引用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">out_v</span><span class="params">(temperatures.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; temperatures.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(temperatures[i] &lt;= temperatures[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                    out_v[st.<span class="built_in">top</span>()] = i - st.<span class="built_in">top</span>();</span><br><span class="line">                    st.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> out_v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="下一个更大元素-i">496.下一个更大元素 I</h3><p>和上一题很像的思路，但是需要借助两个数组都没有重复数字的假设构造map，使答案不超时<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums1.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            mp[nums1[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ng</span><span class="params">(nums1.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums2.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; nums2[i] &gt; nums2[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                <span class="type">int</span> ntop = nums2[st.<span class="built_in">top</span>()];</span><br><span class="line">                <span class="keyword">if</span>(mp.<span class="built_in">find</span>(ntop) != mp.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    ng[mp[ntop]] = nums2[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ng;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="下一个更大元素ii">503.下一个更大元素II</h3><p>我想的是找到最大的元素，从下一个数开始遍历一遍，不过看题解直接遍历两遍数组即可<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nextGreaterElements</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// int max_n = nums[0];</span></span><br><span class="line">        <span class="comment">// int max_i = 0;</span></span><br><span class="line">        <span class="comment">// for(int i = 0; i &lt; nums.size(); i++)&#123;</span></span><br><span class="line">        <span class="comment">//     if(nums[i] &gt; max_n)&#123;</span></span><br><span class="line">        <span class="comment">//         max_n = nums[i];</span></span><br><span class="line">        <span class="comment">//         max_i = i;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>()*<span class="number">2</span>; j++)&#123;</span><br><span class="line">            <span class="type">int</span> n_i = j % nums.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; nums[n_i] &gt; nums[st.<span class="built_in">top</span>()])&#123;</span><br><span class="line">                res[st.<span class="built_in">top</span>()] = nums[n_i];</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(n_i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;每日温度&quot;&gt;739. 每日温度&lt;/h3&gt;
&lt;p&gt;维护一个栈来记录未更新的数组值
&lt;code&gt;using xx = xxxx&lt;/code&gt;仅可用于为现有变量创建别名，如果数组变量名太长请创建引用
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;t</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-动态规划13</title>
    <link href="https://mackz-maxw.github.io/2025/10/24/kamacode40palin/"/>
    <id>https://mackz-maxw.github.io/2025/10/24/kamacode40palin/</id>
    <published>2025-10-24T14:50:36.603Z</published>
    <updated>2025-10-24T14:50:45.924Z</updated>
    
    <content type="html"><![CDATA[<h3 id="回文子串">647. 回文子串</h3><p>首先是找到递推关系，对于字符串中下标i-j的字串，如果<code>s[i] == s[j]</code>则可以由<code>dp[i+1][j-1]</code>推出<code>dp[i][j]</code>然后是遍历顺序，因为要先知道<code>dp[i+1][j-1]</code>，所以要从下往上，从左至右遍历<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(),<span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = s.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] != s[j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        cnt++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                        <span class="keyword">if</span>(dp[i][j] == <span class="literal">true</span>)cnt++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="最长回文子序列">516.最长回文子序列</h3><p>和上一题思路类似 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>(),<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = s.<span class="built_in">size</span>()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] != s[j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i+<span class="number">1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i == j)&#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i - j == <span class="number">1</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="number">2</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = dp[i+<span class="number">1</span>][j<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;回文子串&quot;&gt;647. 回文子串&lt;/h3&gt;
&lt;p&gt;首先是找到递推关系，对于字符串中下标i-j的字串，如果&lt;code&gt;s[i] == s[j]&lt;/code&gt;则可以由&lt;code&gt;dp[i+1][j-1]&lt;/code&gt;推出&lt;code&gt;dp[i][j]&lt;/code&gt;
然</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 八股-DNS与CDN</title>
    <link href="https://mackz-maxw.github.io/2025/10/21/kamabagu8/"/>
    <id>https://mackz-maxw.github.io/2025/10/21/kamabagu8/</id>
    <published>2025-10-21T23:38:41.797Z</published>
    <updated>2025-10-21T23:41:44.017Z</updated>
    
    <content type="html"><![CDATA[<h3 id="dns查询过程">DNS查询过程</h3><p>DNS 用来将主机名和域名转换为IP地址, 其查询过程一般通过以下步骤：</p><p>本地DNS缓存检查：首先查询本地DNS缓存，如果缓存中有对应的IP地址，则直接返回结果。如果本地缓存中没有，则会向本地的DNS服务器（通常由你的互联网服务提供商（ISP）提供，比如中国移动）发送一个DNS查询请求。如果本地DNS解析器有该域名的ip地址，就会直接返回，如果没有缓存该域名的解析记录，它会向根DNS服务器发出查询请求。根DNS服务器并不负责解析域名，但它能告诉本地DNS解析器应该向哪个顶级域（.com/.net/.org）的DNS服务器继续查询。本地DNS解析器接着向指定的顶级域名DNS服务器发出查询请求。顶级域DNS服务器也不负责具体的域名解析，但它能告诉本地DNS解析器应该前往哪个权威DNS服务器查询下一步的信息。本地DNS解析器最后向权威DNS服务器发送查询请求。权威DNS服务器是负责存储特定域名和IP地址映射的服务器。当权威DNS服务器收到查询请求时，它会查找"example.com"域名对应的IP地址，并将结果返回给本地DNS解析器。本地DNS解析器将收到的IP地址返回给浏览器，并且还会将域名解析结果缓存在本地，以便下次访问时更快地响应。浏览器发起连接：本地DNS解析器已经将IP地址返回给您的计算机，您的浏览器可以使用该IP地址与目标服务器建立连接，开始获取网页内容。</p><h3 id="cdn是什么有什么作用">CDN是什么，有什么作用？</h3><p>CDN是一种分布式网络服务，通过将内容存储在分布式的服务器上，使用户可以从距离较近的服务器获取所需的内容，从而加速互联网上的内容传输。</p><p>就近访问：CDN在全球范围内部署了多个服务器节点，用户的请求会被路由到距离最近的 CDN节点，提供快速的内容访问。 内容缓存：CDN节点会缓存静态资源，如图片、样式表、脚本等。当用户请求访问这些资源时，CDN会首先检查是否已经缓存了该资源。如果有缓存，CDN节点会直接返回缓存的资源，如果没有缓存所需资源，它会从源服务器（原始服务器）回源获取资源，并将资源缓存到节点中，以便以后的请求。通过缓存内容，减少了对原始服务器的请求，减轻了源站的负载。可用性：即使某些节点出现问题，用户请求可以被重定向到其他健康的节点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;dns查询过程&quot;&gt;DNS查询过程&lt;/h3&gt;
&lt;p&gt;DNS 用来将主机名和域名转换为IP地址, 其查询过程一般通过以下步骤：&lt;/p&gt;
&lt;p&gt;本地DNS缓存检查：首先查询本地DNS缓存，如果缓存中有对应的IP地址，则直接返回结果。
如果本地缓存中没有，则会向本地</summary>
      
    
    
    
    <category term="comp basic" scheme="https://mackz-maxw.github.io/categories/comp-basic/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-模拟笔试1</title>
    <link href="https://mackz-maxw.github.io/2025/10/21/kamapentest_data/"/>
    <id>https://mackz-maxw.github.io/2025/10/21/kamapentest_data/</id>
    <published>2025-10-21T16:22:01.115Z</published>
    <updated>2025-10-21T16:21:42.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="卡码笔试-263.数据重删">卡码笔试 263.数据重删</h3><p>题目描述：输入一串存储的数据，用N表示数据个数，用K表示数据块的大小，设计一个方法判断当前数据块是否和前面的数据块有重复，两个数据块内容完全一样则表示重复，如果重复则将这个数据块删除，并且在第一个出现数据块的后面增加重复数据的计数，输出经过重删之后的数据内容。输入示例： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8 </span><br><span class="line">3 </span><br><span class="line">3 4 5 3 4 5 5 4</span><br></pre></td></tr></table></figure> 输出示例： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 5 2 5 4 1</span><br></pre></td></tr></table></figure> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> total;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    cin&gt;&gt;total&gt;&gt;len;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;c)&#123;</span><br><span class="line">        data.<span class="built_in">push_back</span>(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    map&lt;vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt; mp;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; uniqueBlock;</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; isUnique;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; data.<span class="built_in">size</span>(); i+=len)&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; block;</span><br><span class="line">        <span class="keyword">while</span>(cnt &lt; len &amp;&amp; (i+cnt) &lt; data.<span class="built_in">size</span>())&#123;</span><br><span class="line">            block.<span class="built_in">push_back</span>(data[i+cnt]);</span><br><span class="line">            <span class="comment">// cout&lt;&lt;&quot;pushed in block: &quot;&lt;&lt;data[i+cnt]&lt;&lt;endl;</span></span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">        mp[block]++;</span><br><span class="line">        <span class="keyword">if</span>(mp[block] == <span class="number">1</span>)&#123;</span><br><span class="line">            isUnique.<span class="built_in">push_back</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            isUnique.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        uniqueBlock.<span class="built_in">push_back</span>(block);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; uniqueBlock.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isUnique[i] == <span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> n: uniqueBlock[i])&#123;</span><br><span class="line">                cout&lt;&lt;n&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;mp[uniqueBlock[i]]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;total data: &quot;&lt;&lt;total&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;len of blocks: &quot;&lt;&lt;len&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">// for(int i: data)&#123;</span></span><br><span class="line">    <span class="comment">//     cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;卡码笔试-263.数据重删&quot;&gt;卡码笔试 263.数据重删&lt;/h3&gt;
&lt;p&gt;题目描述：
输入一串存储的数据，用N表示数据个数，用K表示数据块的大小，设计一个方法判断当前数据块是否和前面的数据块有重复，两个数据块内容完全一样则表示重复，如果重复则将这个数据块删除，</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>算法笔试 | 某厂后端复盘</title>
    <link href="https://mackz-maxw.github.io/2025/10/21/intv_xp/"/>
    <id>https://mackz-maxw.github.io/2025/10/21/intv_xp/</id>
    <published>2025-10-21T16:18:49.849Z</published>
    <updated>2025-10-20T16:54:44.309Z</updated>
    
    <content type="html"><![CDATA[<p>这回笔试，我选择寄得比算法多（好久没刷八股题了=_=||），某境外电商的算法还是相对简单的</p><h3 id="mysql的默认事务隔离级别">MySQL的默认事务隔离级别</h3><p>REPEATABLE READ</p><h3 id="算法">算法</h3><h4 id="我ac了">我ac了：</h4><ul><li>求杨辉三角指定行指定区间的和（暴力就可以了）</li><li>给定一个数组，这个数组的每一项是一个模块的单元测试，每次合并两个模块都需要执行两个模块单元测试数之和，问合并所有模块需要的最小测试数是多少（从小到大sort一下，再相加即可）</li></ul><h4 id="考试时发现我忘记了">考试时发现我忘记了：</h4><p>sort库函数怎么传递比较参数（比如我不需要默认的从小到大，而是从大到小该怎么办）怎么构造并使用大/小顶堆</p><h4 id="我没有ac">我没有ac:</h4><p>打包员有m个相同重量上限k的袋子，需要打包weights数组个物品，这些物品一定是从前向后依次打包的，已知物品个数n,每个物品重量的数组weights,求k的最小值</p><p>这个我本来以为需要背包算法，后来发现二分查找就可以了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这回笔试，我选择寄得比算法多（好久没刷八股题了=_=||），某境外电商的算法还是相对简单的&lt;/p&gt;
&lt;h3 id=&quot;mysql的默认事务隔离级别&quot;&gt;MySQL的默认事务隔离级别&lt;/h3&gt;
&lt;p&gt;REPEATABLE READ&lt;/p&gt;
&lt;h3 id=&quot;算法&quot;&gt;算法&lt;/h</summary>
      
    
    
    
    <category term="interview" scheme="https://mackz-maxw.github.io/categories/interview/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-动态规划12</title>
    <link href="https://mackz-maxw.github.io/2025/10/21/kamacode39editd/"/>
    <id>https://mackz-maxw.github.io/2025/10/21/kamacode39editd/</id>
    <published>2025-10-21T16:17:10.448Z</published>
    <updated>2025-10-21T16:23:32.802Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不同的子序列">115.不同的子序列</h3><p>这题我想到要对于t的每个字符，一在s里匹配到，就从两串的下一个字符开始往后匹配。这么一看感觉开始递归了，不太动态规划。</p><p>题解的递推公式如下： 这一类问题，基本是要分析两种情况 -<code>s[i - 1]</code> 与 <code>t[j - 1]</code>相等 -<code>s[i - 1]</code> 与 <code>t[j - 1]</code> 不相等</p><p>当<code>s[i - 1]</code> 与<code>t[j - 1]</code>相等时，<code>dp[i][j]</code>可以有两部分组成。 -一部分是用<code>s[i - 1]</code>来匹配，那么个数为<code>dp[i - 1][j - 1]</code>。即不需要考虑当前s子串和t子串的最后一位字母，所以只需要<code>dp[i-1][j-1]</code>。 -一部分是不用<code>s[i - 1]</code>来匹配，个数为<code>dp[i - 1][j]</code>。当<code>s[i - 1]</code> 与<code>t[j - 1]</code>不相等时，<code>dp[i][j]</code>只有一部分组成，不用<code>s[i - 1]</code>来匹配（就是模拟在s中删除这个元素），即：<code>dp[i - 1][j]</code></p><p>注意上限长度且所有字符一样的s和t，会使得dp超<code>long long</code>的限制，此时使用<code>uint64_t</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numDistinct</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">uint64_t</span>&gt;&gt; <span class="built_in">dp</span>(t.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">uint64_t</span>&gt;(s.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// dp[0][0] = 1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == t[<span class="number">0</span>])dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=t.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=s.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[j<span class="number">-1</span>] == t[i<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="comment">// if(i == 1)dp[i][j] = max(dp[i][j], 1);</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(auto c:dp)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int c_i : c)&#123;</span></span><br><span class="line">        <span class="comment">//         cout&lt;&lt;c_i&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> dp[t.<span class="built_in">size</span>()][s.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="两个字符串的删除操作">583. 两个字符串的删除操作</h3><p>和上一题有些类似的思路 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word2.<span class="built_in">size</span>()+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++)dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++)dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>] == word2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(auto line : dp)&#123;</span></span><br><span class="line">        <span class="comment">//     for(auto i : line)&#123;</span></span><br><span class="line">        <span class="comment">//         cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> dp[word1.<span class="built_in">size</span>()][word2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="编辑距离">72. 编辑距离</h3><p>跟上两题差不多的思路，差点就写对了 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word2.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; word1.<span class="built_in">size</span>(); i++)dp[i+<span class="number">1</span>][<span class="number">0</span>] = (i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; word2.<span class="built_in">size</span>(); i++)dp[<span class="number">0</span>][i+<span class="number">1</span>] = (i+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// dp[0][0] = 1;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= word1.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= word2.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(word1[i<span class="number">-1</span>] != word2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j]+<span class="number">1</span>, dp[i][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// for(auto line : dp)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int i : line)&#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; i &lt;&lt; &#x27; &#x27;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> dp[word1.<span class="built_in">size</span>()][word2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;不同的子序列&quot;&gt;115.不同的子序列&lt;/h3&gt;
&lt;p&gt;这题我想到要对于t的每个字符，一在s里匹配到，就从两串的下一个字符开始往后匹配。这么一看感觉开始递归了，不太动态规划。&lt;/p&gt;
&lt;p&gt;题解的递推公式如下： 这一类问题，基本是要分析两种情况 -
&lt;code</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-动态规划11</title>
    <link href="https://mackz-maxw.github.io/2025/10/02/kamacode38seq2/"/>
    <id>https://mackz-maxw.github.io/2025/10/02/kamacode38seq2/</id>
    <published>2025-10-02T21:48:44.109Z</published>
    <updated>2025-10-11T15:30:22.702Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最长公共子序列">1143.最长公共子序列</h3><p>按照动态规划，每次比较成功就加一，取所有值最大的思路是错的，这种会把乱序但是相同的字符也算进去。于是我想了半天怎么先循环以i,j为右下角的正方形，本来想的是记忆化将i,j赋值为比较后相等的值，看了题解发现得在递推公式上作更改因为字符中间可能会插入别的字符，所以ac,ace的比较结果和ac,aced的比较结果是一样的<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(text1.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (text2.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= text1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= text2.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text1.<span class="built_in">size</span>()][text2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="不相交的线">1035.不相交的线</h3><p>既然一个数只能连一根线，那么其实和上一题是一个意思了<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums1.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (nums2.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums1.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= nums2.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i<span class="number">-1</span>] == nums2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums1.<span class="built_in">size</span>()][nums2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="最大子序和">53. 最大子序和</h3><p>我想的是，<code>dp[i]</code>由<code>dp[i-1]</code>,<code>dp[i-1]+nums[i]</code>,<code>nums[i]</code>中的最大值决定，但是这样解会算出不连续的最大值</p><p>题解的推算法是这样的： <code>dp[i]</code>只有两个方向可以推出来： -<code>dp[i-1] + nums[i]</code>，即：<code>nums[i]</code>加入当前连续子序列和- <code>nums[i]</code>，即：从头开始计算当前连续子序列和再找每个的<code>dp[i]</code>最大值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>]+nums[i], nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; res)res = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="判断子序列">392.判断子序列</h3><p>常规做的话双指针法即可，按照动态规划来做是和第一题是差不多的思路<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()] == s.<span class="built_in">size</span>() ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;最长公共子序列&quot;&gt;1143.最长公共子序列&lt;/h3&gt;
&lt;p&gt;按照动态规划，每次比较成功就加一，取所有值最大的思路是错的，这种会把乱序但是相同的字符也算进去。
于是我想了半天怎么先循环以i,j为右下角的正方形，本来想的是记忆化将i,j赋值为比较后相等的值，看了题</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 八股-TCP连接</title>
    <link href="https://mackz-maxw.github.io/2025/10/02/kamabagu7/"/>
    <id>https://mackz-maxw.github.io/2025/10/02/kamabagu7/</id>
    <published>2025-10-02T21:29:05.157Z</published>
    <updated>2025-10-02T21:48:16.113Z</updated>
    
    <content type="html"><![CDATA[<h3id="tcp连接三次握手的过程为什么是三次可以是两次或者更多吗">TCP连接三次握手的过程，为什么是三次，可以是两次或者更多吗？</h3><ol type="1"><li>三次握手的过程</li></ol><p>第一次握手：客户端向服务器发送一个SYN（同步序列编号）报文，请求建立连接，客户端进入SYN_SENT 状态。第二次握手：服务器收到SYN 报文后，如果同意建立连接，则会发送一个SYN-ACK（同步确认）报文作为响应，同时进入SYN_RCVD 状态。第三次握手：客户端收到服务器的SYN-ACK 报文后，会发送一个ACK（确认）报文作为最终响应，之后客户端和服务器都进入ESTABLISHED状态，连接建立成功。</p><p>(2)为什么需要三次握手因为TCP需要简历双向的数据连接。通过三次握手，客户端和服务器都能够确认对方的接收和发送能力。第一次握手确认了客户端到服务器的通道是开放的；第二次握手确认了服务器到客户端的通道是开放的；第三次握手则确认了客户端接收到服务器的确认，从而确保了双方的通道都是可用的。</p><p>而如果仅使用两次握手，服务器可能无法确定客户端的接收能力是否正常，比如客户端可能已经关闭了连接，但之前发送的连接请求报文在网络上延迟到达了服务器，服务器就会主动去建立一个连接，但是客户端接收不到，导致资源的浪费。而四次握手可以优化为三次。</p><h3id="tcp连接四次挥手的过程为什么是四次">TCP连接四次挥手的过程，为什么是四次？</h3><p>（1）四次挥手的过程</p><p>第一次挥手：客户端发送一个FIN报文给服务端，表示自己要断开数据传送，报文中会指定一个序列号(seq=x)。然后,客户端进入FIN-WAIT-1 状态。第二次挥手：服务端收到FIN报文后，回复ACK报文给客户端，且把客户端的序列号值+1，作为ACK报文的序列号(seq=x+1)。然后，服务端进入CLOSE-WAIT(seq=x+1)状态，客户端进入FIN-WAIT-2状态。第三次挥手：服务端也要断开连接时，发送FIN报文给客户端，且指定一个序列号(seq=y+1)，随后服务端进入LAST-ACK状态。第四次挥手：客户端收到FIN报文后，发出ACK报文进行应答，并把服务端的序列号值+1作为ACK报文序列号(seq=y+2)。此时客户端进入TIME-WAIT状态。服务端在收到客户端的ACK报文后进入CLOSE 状态。如果客户端等待2MSL没有收到回复，才关闭连接。</p><p>（2）为什么需要四次挥手</p><p>TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后才会完全关闭TCP连接。因此两次挥手可以释放一端到另一端的TCP连接，完全释放连接一共需要四次挥手。</p><p>只有通过四次挥手，才可以确保双方都能接收到对方的最后一个数据段的确认，主动关闭方在发送完最后一个ACK后进入TIME-WAIT状态，这是为了确保被动关闭方接收到最终的ACK，如果被动关闭方没有接收到，它可以重发FIN报文，主动关闭方可以再次发送ACK 。</p><p>而如果使用三次挥手，被动关闭方可能在发送最后一个数据段后立即关闭连接，而主动关闭方可能还没有接收到这个数据段的确认。</p><h3id="http的keep-alive是什么tcp-的-keepalive-和-http-的-keep-alive-是一个东西吗">HTTP的Keep-Alive是什么？TCP的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？</h3><p>HTTP 的 Keep-Alive，是由应用层实现的，称为 HTTP 长连接每次请求都要经历这样的过程：建立 TCP连接 -&gt; HTTP请求资源 -&gt;响应资源 -&gt;释放连接，这就是HTTP短连接，但是这样每次建立连接都只能请求一次资源，所以HTTP的 Keep-Alive实现了使用同一个 TCP 连接来发送和接收多个 HTTP请求/应答，避免了连接建立和释放的开销，就就是 HTTP长连接。通过设置HTTP头Connection: keep-alive来实现。</p><p>TCP 的 Keepalive，是由TCP 层（内核态）实现的，称为 TCP保活机制，是一种用于在 TCP 连接上检测空闲连接状态的机制当TCP连接建立后，如果一段时间内没有任何数据传输，TCPKeepalive会发送探测包来检查连接是否仍然有效。</p><p>补充说明：</p><p>其实这里tcp的keepalive，不只是支持http，还可以支持ftp和smtp的，他是一个能力，类似于gc。</p><p>http的这个keepalive感觉更是一种策略吧，比如你有一个http用了keepalive，然后过了一会，你不传输数据了，这个时候没有通知对方close，这个时候tcp的keepalive就会起到用处去关闭这次链接。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3
id=&quot;tcp连接三次握手的过程为什么是三次可以是两次或者更多吗&quot;&gt;TCP连接三次握手的过程，为什么是三次，可以是两次或者更多吗？&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;三次握手的过程&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一次握手：客户端向服务器发送一个SYN</summary>
      
    
    
    
    <category term="comp basic" scheme="https://mackz-maxw.github.io/categories/comp-basic/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统基础 | 5.8 进程实验</title>
    <link href="https://mackz-maxw.github.io/2025/09/26/oper_sys28lab_process/"/>
    <id>https://mackz-maxw.github.io/2025/09/26/oper_sys28lab_process/</id>
    <published>2025-09-27T01:27:32.248Z</published>
    <updated>2025-09-30T16:27:46.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程家族树-process-family-tree"><strong>进程家族树 (ProcessFamily Tree)</strong></h3><ol type="1"><li><p><strong>实验报告</strong>：准备好实验报告</p></li><li><p><strong>simple_fork.c</strong>：编写一个名为<code>simple_fork.c</code> 的简短程序，使用 <code>fork()</code>函数从父进程生成一个子进程。父进程应在 <code>fork</code>之前打印一条语句，并在 <code>fork</code> 之后打印出子进程的PID。子进程应在被生成后打印一条语句，使用 <code>getpid()</code> 和<code>getppid()</code> 函数打印出其自身的 PID 及其父进程的PID。在您的树莓派上编译并运行您的程序，并将程序的输出作为此问题的答案。提示：gcc编译<code>gcc [source] -o [destination]</code></p></li><li><p><strong>tree_fork.c</strong>：编写第二个名为<code>tree_fork.c</code>的程序，该程序将一个整数作为命令行参数，并在最多 10代的固定限制内，生成一个具有指定代数的“二进制家族树”进程。这将创建<code>2^n - 1</code> 个进程，其中 <code>n</code> 是代数。对于n=1，程序将创建 1 个进程；对于 n=5，将创建 31 个进程；对于 n=10，将创建1023 个进程，依此类推。我们将代数限制为最多10，因为更大的数字会运行很长时间，甚至可能冻结您的树莓派！</p><ul><li>如果未提供命令行参数，程序应输出有用的用法消息并退出。</li><li>否则，它应将命令行参数转换为整数并存储在 <code>generations</code>变量中。</li><li>如果 <code>generations</code> 变量小于 1 或大于10，程序应输出有用的用法消息并退出。</li><li>否则，它（以及它生成的任何子进程）应执行以下操作（原始程序为第一代）：<ul><li>打印一行，说明它属于哪一代及其自身的 PID；</li><li>增加当前代数计数器；</li><li>如果已达到最后一代（根据 <code>generations</code> 变量），则直接返回0；否则，生成两个子进程；</li><li>使用 <code>wait(0)</code> 等待任何成功生成的子进程完成；</li><li>如果两个子进程都成功生成，则返回0；如果任一生成（或两者都）失败，则返回 -1。</li></ul></li><li><strong>提示</strong>：仔细检查每次调用<code>fork()</code>（或您用于生成每个子进程的任何调用）返回的<code>pid_t</code> 值非常重要，因为 (1)这些调用可能失败（由负返回值指示），(2) <code>0</code>表示子进程正在运行，(3) 正数表示父进程正在运行。</li><li><strong>提示</strong>：基于此，使用递归，或使用带有几个<code>pid_t</code> 变量（每个子进程一个）的 <code>while</code>循环并明智地在子进程中运行的代码分支使用 <code>continue</code>语句，可以很直接地实现本练习的逻辑。</li><li>作为此练习的答案，请展示您的程序在运行 4代时（如果正确实现，应总共生成 15 个进程）的输出。</li></ul></li><li><p><strong>修改 kobject示例模块</strong>：现在我们将回到使用这些思想进行内核模块设计。首先，从您的linux 源码目录中，找到并将文件<code>samples/kobject/kobject-example.c</code>复制到您保存内核模块代码的目录中。这是一个使用称为 <code>kobjects</code>的功能的内核模块，它提供了一个在内核和用户空间之间交换数据的接口。每个数据项称为一个属性（attribute），对于每个属性，您需要提供一个<code>show</code> 和 <code>store</code>函数，分别在用户空间读取和写入这些值时被调用。</p><ul><li>该特定模块提供三个属性：<code>foo</code>、<code>baz</code> 和<code>bar</code>。加载后，您可以在 sysfs 文件系统中的<code>/sys/kernel/kobject_example/</code> 目录下找到它们。</li><li>修改此文件，以便（通过使用 <code>printk</code>）在更新<code>foo</code>、<code>baz</code> 或 <code>bar</code>中的任何一个时打印一条系统日志消息，并在消息中显示被更新变量的旧值和新值。</li><li>现在我们可以像以前一样构建您修改后的模块。首先，更新您的<code>Makefile</code>，使其包含新模块的相应 <code>.o</code>文件目标，然后为您的模块生成 <code>.ko</code> 文件，如下所示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module add arm-rpi</span><br><span class="line">LINUX_SOURCE=您的Linux内核源代码路径</span><br><span class="line">make -C <span class="variable">$LINUX_SOURCE</span> ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- M=<span class="variable">$PWD</span> modules</span><br></pre></td></tr></table></figure></li><li>然后，使用 <code>sftp</code> 将生成的 <code>.ko</code>文件复制到您的树莓派上，并使用 <code>sudo insmod</code>加载该模块。</li><li>在具有 root 权限的终端中，您可以使用 <code>cat</code>命令读取这些属性的值，并使用 <code>echo</code>命令将值写入这些属性，例如： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo bash</span><br><span class="line"><span class="built_in">cd</span> /sys/kernel/kobject_example/</span><br><span class="line"><span class="built_in">cat</span> foo          <span class="comment"># 显示 foo 属性的当前（原始）值</span></span><br><span class="line"><span class="built_in">echo</span> 42 &gt; foo    <span class="comment"># 将值 42 写入属性 foo</span></span><br><span class="line"><span class="built_in">cat</span> foo          <span class="comment"># 显示属性 foo 的新值</span></span><br></pre></td></tr></table></figure> <em>注意：您必须有一个 root终端（<code>sudo bash</code> 可以给您）才能写入这些命令（即<code>sudo echo</code> 不起作用）。</em></li><li>作为此练习的答案，请展示使用这些命令成功更改<code>foo</code>、<code>bar</code> 和 <code>baz</code>值的输出演示。</li></ul></li><li><p><strong>family_reader.c模块</strong>：现在我们将编写一个内核模块，通过 sysfs 接口读取一个PID，并在系统日志中打印该进程的祖先谱系。</p><ul><li>创建一个基于您修改后的 <code>kobject-example.c</code>文件的新内核模块文件<code>family_reader.c</code>（即，首先请复制它）。该模块应在<code>/sys/kernel/fam_reader/</code>下创建单个系统属性（像上一个练习一样是整数值）。当您向此属性写入一个整数时，您的模块应尝试打印出该PID的祖先谱系（即，它的父进程，然后是父进程的父进程，依此类推，一直追溯到<code>init</code> 任务）。涉及几个步骤：<ul><li><strong>旁注</strong>：现代 Linux内核为了便于在不同虚拟主机之间迁移进程，区分了“真实”PID和“虚拟”PID。虚拟 PID 是进程从用户空间看到的 PID。</li><li>您需要将整数输入转换为合适的内核 PID。使用函数<code>find_vpid()</code>（请参阅 <code>include/linux/pid.h</code> 和<code>kernel/pid.c</code>），它返回一个<code>struct pid *</code>。此函数可能失败，因此在解引用指针之前务必检查其返回值。</li><li>接下来，您可以通过将 <code>struct pid *</code> 和标志<code>PIDTYPE_PID</code> 传递给函数 <code>get_pid_task()</code>（请参阅<code>include/linux/pid.h</code> 和<code>kernel/pid.c</code>）来将其转换为<code>struct task_struct *</code>。此函数可能失败，因此在解引用指针之前务必检查其返回值。</li><li>一旦您有了<code>struct task_struct *</code>，就可以访问它存储的任何数据。特别是，<code>real_parent</code>字段存储了生成它的进程的 <code>struct task_struct *</code>指针，<code>comm</code> 字段是给出命令名称的字符串。<ul><li><strong>注意</strong>：有一个单独的字段叫做<code>parent</code>，这不是我们本练习想要的。<code>parent</code>是共享进程组信号并允许父子进程之间等待的逻辑父进程。</li></ul></li><li>回溯家族树，打印出每个任务的 PID 和命令名称，一直回溯到 PID 为 1 的<code>init</code> 任务。</li></ul></li><li>像上一个模块一样编译您的新内核模块，然后使用 <code>sftp</code>将生成的 <code>.ko</code>文件复制到您的树莓派上。在您的树莓派上，安装该模块，然后使用<code>sudo bash</code> 为您的终端会话提供 root访问权限。在该模块的目录下（将在 <code>/sys/kernel/</code> 下），使用<code>cat</code> 和 <code>echo</code> 读取和写入该模块属性的值，然后使用<code>dmesg</code> 确认系统日志显示您的模块工作正常。</li><li>使用 <code>ps</code> 命令查找在您当前终端窗口中运行的<code>sudo</code> 进程的 PID，使用 <code>echo</code>将您的模块属性设置为该 PID，然后使用 <code>dmesg</code>查看该进程的祖先谱系。作为此练习的答案，请展示显示 <code>sudo</code>进程祖先谱系的系统日志消息。</li></ul></li></ol><hr /><h3 id="可选拓展练习-optional-enrichment-exercises"><strong>可选拓展练习(Optional Enrichment Exercises)</strong></h3><ol start="6" type="1"><li><strong>探索 task_struct</strong>：<code>task_struct</code>包含许多有趣的进程数据和进程记账信息。尝试将其他字段打印到系统日志中，并作为此练习的答案，请简要描述您打印了哪些内容，并展示执行此操作后的一些系统日志消息。</li><li><strong>探索调度程序功能</strong>：<code>kernel/sched</code> 和<code>include/linux/sched</code>中的文件包含许多用于处理任务的功能，包括修改特定任务或迭代系统中每个任务的能力。例如，<code>include/linux/sched/signal.h</code>定义了诸如 <code>for_each_process()</code>之类的宏。尝试使用其中一些功能，并作为此练习的答案，请简要描述您做了什么以及观察到了什么。</li></ol><hr />]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;进程家族树-process-family-tree&quot;&gt;&lt;strong&gt;进程家族树 (Process
Family Tree)&lt;/strong&gt;&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;实验报告&lt;/strong&gt;：准备好实验报告&lt;/</summary>
      
    
    
    
    <category term="os basic" scheme="https://mackz-maxw.github.io/categories/os-basic/"/>
    
    <category term="lab" scheme="https://mackz-maxw.github.io/categories/os-basic/lab/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-动态规划10</title>
    <link href="https://mackz-maxw.github.io/2025/09/26/kamacode37subseq/"/>
    <id>https://mackz-maxw.github.io/2025/09/26/kamacode37subseq/</id>
    <published>2025-09-27T01:25:21.777Z</published>
    <updated>2025-09-26T22:47:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最长递增子序列">300.最长递增子序列</h3><p>这题我一开始想使用回溯找最长子序列，但是我发现需要记录的状态太多，回溯没办法解决；同时对于序列中的相同数字，如何记住遍历前后的状态也是个问题。题解中这题使用的是动态规划，对于每一个索引求它所在的最长递增子序列，再求所有子序列中最长的那个。</p><ul><li>外层循环：遍历序列中每一个索引<code>i</code></li><li>内层循环：求从开头到<code>i</code>之前的数字<code>j</code>中最长的子序列，如果<code>nums[i] &gt; nums[j]</code>，则开头到<code>i</code>所在处最长子序列为<code>j</code>所在处+1</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> mx = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;dp[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">            &#125;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, dp[i]);</span><br><span class="line">            <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="最长连续递增序列">674. 最长连续递增序列</h3><p>这题不要想得太复杂了就行 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lng = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> max_l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                lng++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                lng = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max_l = <span class="built_in">max</span>(max_l, lng);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="最长重复子数组">718. 最长重复子数组</h3><p>这题我想可不可以分别求两个数组的最长相等前后缀表，再找重复子数组。看了动规解法我发现，一个两数组比较表能解决的事情，用前后缀表似乎有点浪费？</p><p>动规解法中，<code>dp[i][j]</code>表示两个数组下标i-1，j-1个数进行比较，这样0行和0列默认初始化为0即可。如果表示下标i，j个数，则需要再初始化一下0行和0列<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums1.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums2.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; (nums1.<span class="built_in">size</span>()+<span class="number">1</span>); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; (nums2.<span class="built_in">size</span>()+<span class="number">1</span>); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i<span class="number">-1</span>] == nums2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &gt; len)len = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(auto line:dp)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int l:line)&#123;</span></span><br><span class="line">        <span class="comment">//         cout&lt;&lt;l&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;最长递增子序列&quot;&gt;300.最长递增子序列&lt;/h3&gt;
&lt;p&gt;这题我一开始想使用回溯找最长子序列，但是我发现需要记录的状态太多，回溯没办法解决；同时对于序列中的相同数字，如何记住遍历前后的状态也是个问题。
题解中这题使用的是动态规划，对于每一个索引求它所在的最长递</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>算法笔试 | 某厂测开复盘</title>
    <link href="https://mackz-maxw.github.io/2025/09/26/intv_tyy/"/>
    <id>https://mackz-maxw.github.io/2025/09/26/intv_tyy/</id>
    <published>2025-09-27T01:24:28.393Z</published>
    <updated>2025-09-27T01:24:16.064Z</updated>
    
    <content type="html"><![CDATA[<p>今天笔试某厂测开岗，选择还行，算法全寄，遂复盘之</p><h3 id="操作系统八股-内存的分页和分段">操作系统八股内存的分页和分段</h3><h4 id="分页">分页</h4><p>分页是一种内存管理方案，它<strong>将程序的虚拟地址空间和物理内存都划分成固定大小的块</strong>。虚拟内存的块称为“页”，物理内存的块称为“页框”或“帧”。页和页框的大小通常相同（例如4KB）。</p><p>虚拟地址 = 页号 + 页内偏移量 物理地址 = 页框号 + 页内偏移量</p><h4 id="分段">分段</h4><p>分段是一种更符合程序员视角的内存管理方案。<strong>一个程序被划分为若干个逻辑段</strong>，例如：代码段、数据段、堆段、栈段等。每个段都有其特定的用途（如代码段可读可执行但不可写）。</p><p>操作系统为每个进程维护一张<strong>段表</strong>，该表记录了每个段的<strong>基地址</strong>（在物理内存中的起始地址）和<strong>段长</strong>（段的界限）。</p><table><colgroup><col style="width: 33%" /><col style="width: 33%" /><col style="width: 33%" /></colgroup><thead><tr><th style="text-align: left;">特性</th><th style="text-align: left;"><strong>分页（一维）</strong></th><th style="text-align: left;"><strong>分段（二维）</strong></th></tr></thead><tbody><tr><td style="text-align: left;"><strong>地址空间视图</strong></td><td style="text-align: left;"><strong>一个</strong>连续的线性空间</td><tdstyle="text-align: left;"><strong>多个</strong>独立的逻辑空间（段）</td></tr><tr><td style="text-align: left;"><strong>“号”的含义</strong></td><tdstyle="text-align: left;">系统管理的<strong>索引号</strong>（第几页）</td><tdstyle="text-align: left;">程序定义的<strong>逻辑标识</strong>（哪个段）</td></tr><tr><td style="text-align: left;"><strong>对程序员可见</strong></td><tdstyle="text-align: left;"><strong>透明</strong>（由硬件和OS管理）</td><tdstyle="text-align: left;"><strong>可见</strong>（通常由编译器管理，但理念上符合程序员思维）</td></tr><tr><td style="text-align: left;"><strong>类比</strong></td><tdstyle="text-align: left;"><strong>一本书</strong>：只需要一个页码和行号</td><tdstyle="text-align: left;"><strong>文件柜</strong>：需要先选抽屉，再选文件</td></tr></tbody></table><h3 id="操作系统八股-银行家算法bankers-algorithm">操作系统八股银行家算法（Banker's Algorithm）。</h3><p>银行家算法用于检查系统是否处于安全状态，即是否存在一个安全序列，每个进程按顺序执行，执行完后释放所有资源，使得所有进程都能完成而不导致死锁。</p><h3 id="算法题-分零食">算法题 分零食</h3><p>题目：小明和弟弟分零食，分零食的次数为c，每次会给到零食的数量n和最便宜的零食价格m,在价目表中，每个零食的价格是前一个零食的m倍（第一个零食价格为m）,小明想给弟弟总和比自己贵的零食，但为了弟弟的自尊心他想自己和弟弟的零食价格差尽量小，每次请输出小明的零食数和小明每个零食的单价</p><h4 id="为什么贪心算法是最优的">为什么贪心算法是最优的？</h4><ol type="1"><li><strong>几何序列的超级递增性质</strong>：当 (m &gt; 1)时，零食价格序列是超级递增的，即每个后续零食的价格都大于之前所有零食价格之和。例如，对于(m=2)，序列为 (2, 4, 8, 16, )，其中 (4 &gt; 2), (8 &gt; 2+4), (16 &gt;2+4+8)，等等。这种性质意味着贪心算法从大到小选择零食可以确保得到最接近总价一半的子集和，从而最小化价格差。</li><li><strong>对于 (m = 1) 的情况</strong>：所有零食价格均为1。小明最多能拿的零食数为 (k = (n-1)/2 )，这样弟弟拿 (n-k)个零食，总价差为 1（最小可能值）。贪心算法在这里本质上是直接计算最大 (k)使得 (k &lt; n/2)。</li></ol><p>因此，贪心算法在两种情况下都能保证找到最优解，使价格差最小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">while</span> (c--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 所有零食价格均为1：小明拿k个，使得k &lt; n/2，且k尽可能大</span></span><br><span class="line">            <span class="type">int</span> k = (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 计算零食价格序列和总价S</span></span><br><span class="line">            vector&lt;ll&gt; <span class="built_in">prices</span>(n);</span><br><span class="line">            ll total_sum = <span class="number">0</span>;</span><br><span class="line">            ll current = m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                prices[i] = current;</span><br><span class="line">                total_sum += current;</span><br><span class="line">                current *= m;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ll小明_sum = <span class="number">0</span>;</span><br><span class="line">            vector&lt;ll&gt; xiaoming_prices;</span><br><span class="line">            <span class="comment">// 从最贵的零食（序列末尾）开始贪心选择</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">2</span> * (小明_sum + prices[i]) &lt;= total_sum) &#123;</span><br><span class="line">                    小明_sum += prices[i];</span><br><span class="line">                    xiaoming_prices.<span class="built_in">push_back</span>(prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 输出小明的零食数量和每个零食的单价（价格从大到小）</span></span><br><span class="line">            cout &lt;&lt; xiaoming_prices.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = xiaoming_prices.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                cout &lt;&lt; xiaoming_prices[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天笔试某厂测开岗，选择还行，算法全寄，遂复盘之&lt;/p&gt;
&lt;h3 id=&quot;操作系统八股-内存的分页和分段&quot;&gt;操作系统八股
内存的分页和分段&lt;/h3&gt;
&lt;h4 id=&quot;分页&quot;&gt;分页&lt;/h4&gt;
&lt;p&gt;分页是一种内存管理方案，它&lt;strong&gt;将程序的虚拟地址空间和物理内</summary>
      
    
    
    
    <category term="interview" scheme="https://mackz-maxw.github.io/categories/interview/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统基础 | 5.7 孤儿进程；错误检查</title>
    <link href="https://mackz-maxw.github.io/2025/09/14/oper_sys27orphan_err/"/>
    <id>https://mackz-maxw.github.io/2025/09/14/oper_sys27orphan_err/</id>
    <published>2025-09-14T15:32:32.574Z</published>
    <updated>2025-09-14T15:32:41.292Z</updated>
    
    <content type="html"><![CDATA[<h3 id="孤儿进程与僵尸进程-orphans-and-zombies"><strong>26.2孤儿进程与僵尸进程 (Orphans and Zombies)</strong></h3><p>父进程和子进程的生命周期通常并不相同——要么父进程比子进程存活时间长，要么相反。这就引出了两个问题：</p><p><strong>1. 孤儿进程由谁接管？</strong>当一个进程的父进程终止后，该进程就变成了“孤儿进程”。这个孤儿进程会被<code>init</code> 进程（所有进程的祖先，其进程 ID 为1）收养。换句话说，在子进程的父进程终止后，调用 <code>getppid()</code>将返回值1。这可以作为一种判断子进程的真正父进程是否仍存活的方法（前提是该子进程并非由<code>init</code> 进程创建）。 使用 Linux 特有的 <code>prctl()</code>系统调用的 <code>PR_SET_PDEATHSIG</code>操作，可以设置一个进程在成为孤儿时接收到一个特定的信号。</p><p><strong>2. 父进程还未执行 wait()子进程就已终止，会发生什么？</strong>关键在于，尽管子进程已经完成了它的工作，但仍应允许父进程在之后的某个时间点执行<code>wait()</code>来获取子进程的终止状态。内核通过将子进程转变为“僵尸进程”（Zombie）来处理这种情况。这意味着子进程持有的大部分资源会被释放回系统，供其他进程重用。进程唯一保留的部分是内核进程表中的一个条目，该条目记录了子进程的进程ID、终止状态以及资源使用统计信息（参见 36.1 节）等信息。</p><p>关于僵尸进程，UNIX系统模仿了电影中的设定——僵尸进程无法被信号杀死，即使是（银弹）<code>SIGKILL</code>信号也不行。这确保了父进程最终总是能够执行 <code>wait()</code>。</p><p>当父进程执行了 <code>wait()</code>后，内核会清除该僵尸进程，因为关于该子进程的最后剩余信息不再需要。另一方面，如果父进程未执行<code>wait()</code> 就终止了，那么 <code>init</code>进程会收养该子进程，并自动执行<code>wait()</code>，从而将僵尸进程从系统中移除。</p><p>如果一个父进程创建了子进程，但未能执行<code>wait()</code>，那么内核进程表中将无限期地保留该僵尸子进程的条目。如果创建了大量这样的僵尸子进程，它们最终会填满内核进程表，从而阻止新进程的创建。由于僵尸进程无法用信号杀死，将它们从系统中移除的唯一方法是杀死它们的父进程（或等待其退出），届时<code>init</code> 进程会收养这些僵尸进程并对它们执行<code>wait()</code>，从而将它们从系统中清除。</p><p>这些语义对于需要创建大量子进程的长生命周期父进程（如网络服务器和Shell）的设计具有重要意义。换句话说，在此类应用程序中，父进程应执行<code>wait()</code>调用，以确保已终止的子进程总是能从系统中被移除，而不是变成长期存在的僵尸进程。如26.3.1 节所述，父进程可以同步执行这些 <code>wait()</code>调用，也可以异步地（例如响应 <code>SIGCHLD</code> 信号的递送）执行。</p><p>以下程序演示了僵尸进程的创建以及僵尸进程无法被 <code>SIGKILL</code>杀死的情况。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libgen.h&gt;</span>             <span class="comment">/* For basename() declaration */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_SIZE 200</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="type">char</span> cmd[CMD_SIZE];</span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);       <span class="comment">/* Disable buffering of stdout */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent PID=%ld\n&quot;</span>, (<span class="type">long</span>) getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (childPid = fork()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:     <span class="comment">/* Child: immediately exits to become zombie */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child (PID=%ld) exiting\n&quot;</span>, (<span class="type">long</span>) getpid());</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line">    <span class="keyword">default</span>:    <span class="comment">/* Parent */</span></span><br><span class="line">        sleep(<span class="number">3</span>);               <span class="comment">/* Give child a chance to start and exit */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(cmd, CMD_SIZE, <span class="string">&quot;ps | grep %s&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        cmd[CMD_SIZE - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;    <span class="comment">/* Ensure string is null-terminated */</span></span><br><span class="line">        system(cmd);            <span class="comment">/* View zombie child */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Now send the &quot;sure kill&quot; signal to the zombie */</span></span><br><span class="line">        <span class="keyword">if</span> (kill(childPid, SIGKILL) == <span class="number">-1</span>)</span><br><span class="line">            errMsg(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);               <span class="comment">/* Give child a chance to react to signal */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After sending SIGKILL to zombie (PID=%ld):\n&quot;</span>, (<span class="type">long</span>) childPid);</span><br><span class="line">        system(cmd);            <span class="comment">/* View zombie child again */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 当我们运行此程序时，会看到以下输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./make_zombie</span><br><span class="line">Parent PID=1013</span><br><span class="line">Child (PID=1014) exiting</span><br><span class="line"> 1013 pts/4   00:00:00 make_zombie</span><br><span class="line"> 1014 pts/4   00:00:00 make_zombie &lt;defunct&gt;       (ps命令的输出)</span><br><span class="line">After sending SIGKILL to zombie (PID=1014):</span><br><span class="line"> 1013 pts/4   00:00:00 make_zombie</span><br><span class="line"> 1014 pts/4   00:00:00 make_zombie &lt;defunct&gt;       (ps命令的输出)</span><br></pre></td></tr></table></figure> 在上面的输出中，我们看到 <code>ps(1)</code> 命令显示字符串<code>&lt;defunct&gt;</code> 来表示一个处于僵尸状态的进程。 示例程序使用<code>system()</code> 函数来执行其字符串参数中给出的 Shell命令。我们将在 27.6 节详细描述 <code>system()</code>。</p><h3 id="linux-进程源代码指引"><strong>Linux 进程源代码指引</strong></h3><p>进程和线程是操作系统中的基本抽象概念。为支持进程和线程，操作系统使用了两个关键数据结构：<code>task_struct</code>和<code>thread_info</code>；以及大量用于管理系统中进程和线程的辅助函数。</p><ul><li><strong><code>arch/arm/include/asm/thread_info.h</code></strong>文件声明了 <code>thread_info</code> 结构体。</li><li><strong><code>include/linux/sched.h</code></strong> 文件声明了<code>task_struct</code> 结构体以及许多进程管理函数。</li><li><strong><code>arch/arm/include/asm/switch_to.h</code></strong>文件为 <code>switch_to</code> 进程切换例程定义了一个特定于 ARM架构的宏，而 <strong><code>arch/arm/kernel/entry-armv.S</code></strong>文件实现了该宏所使用的汇编级进程切换例程 <code>__switch_to</code>。</li></ul><h3 id="linux-内核代码错误检查"><strong>Linux内核代码错误检查</strong></h3><p>在 Linux 用户空间编程中，函数通常返回整数，并约定返回值<code>0</code>表示函数调用成功，而不同的（通常为负的）非零值用于指示不同的错误。然而，在内核编程中，许多函数可能返回指针而非整数，这使问题变得复杂，因为指针可能使用非零值来编码作为函数成功调用结果而返回的有效内存地址。</p><p>Linux 通过利用以下事实来解决这一挑战： 1.有效（虚拟）地址范围的上半部分未被使用。 2.使用负值表示错误会使得其高位比特位非零，无论它们是作为指针还是整数返回。3. 在 <strong><code>include/linux/err.h</code></strong>文件中提供有用的宏和内联函数，这些函数可以以跨不同硬件架构的可移植方式处理指针、整数和布尔类型的不同组合：</p><ul><li><strong><code>IS_ERR_VALUE</code>宏</strong>：检查一个（指针或整数）值的高位范围是否非空（即，包含错误值）。</li><li><strong><code>ERR_PTR</code>函数</strong>：将一个（<code>long</code>类型）整数值转换为（<code>void *</code> 类型）指针值。</li><li><strong><code>PTR_ERR</code>函数</strong>：将一个（<code>const void *</code>类型）指针值转换为（<code>long</code> 类型）整数值。</li><li><strong><code>IS_ERR</code>函数</strong>：将一个（<code>const void *</code>类型）指针值转换为（<code>unsigned long</code> 类型）整数值，使用<code>IS_ERR_VALUE</code>宏检查该值的高位范围是否非空（即，包含错误值），并相应地返回一个<code>bool</code> 值。</li><li><strong><code>IS_ERR_OR_NULL</code> 函数</strong>：返回一个<code>bool</code> 值，如果 (1) 传入的（<code>const void *</code>类型）指针值为 <code>0</code> <strong>或</strong> (2)将其转换为（<code>unsigned long</code> 类型）整数值后使用<code>IS_ERR_VALUE</code>宏检查表明该值的高位范围非空（即，包含错误值），则该函数返回<code>true</code>。</li><li><strong><code>ERR_CAST</code>函数</strong>：将（<code>const void *</code>类型）指针转换为（<code>void *</code> 类型）指针（去除<code>const</code> 属性）。</li><li><strong><code>PTR_ERR_OR_ZERO</code> 函数</strong>：使用<code>IS_ERR</code> 函数检查传入的（<code>const void *</code>类型）指针值是否包含错误，并返回一个（<code>int</code>类型）整数值：如果不包含错误则返回<code>0</code>，如果包含错误则返回通过调用 <code>PTR_ERR</code>函数获取的错误值。</li></ul><h3 id="err_ptr-和-ptr_err-宏"><strong><code>ERR_PTR</code> 和<code>PTR_ERR</code> 宏</strong></h3><p>关于返回值的讨论，你现在明白了内核模块的 <code>init</code>例程必须返回一个整数。但如果你希望返回一个指针呢？<strong><code>ERR_PTR()</code></strong>内联函数为我们提供了解决方案，它允许我们通过将指针类型转换为<code>void *</code>来返回一个伪装成整数的指针。实际上还有更好的方法：你可以使用<strong><code>IS_ERR()</code></strong>内联函数检查错误（该函数实质上判断值是否在 <code>[-1, -4095]</code>范围内），通过 <strong><code>ERR_PTR()</code></strong>内联函数将负的错误值编码到指针中，并使用对应的例程<strong><code>PTR_ERR()</code></strong> 从指针中检索出这个错误值。</p><p>一个简单的例子，参见下面给出的被调用方代码。这次，我们让（示例）函数<code>myfunc()</code> 返回一个（指向名为 <code>mystruct</code>的结构体的）指针，而不是整数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mystruct * <span class="title function_">myfunc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mystruct</span> *<span class="title">mys</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    mys = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> mystruct), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!mys)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM); <span class="comment">/* 示例：返回编码为指针的错误码 */</span></span><br><span class="line">    <span class="comment">/* ... 其他操作 ... */</span></span><br><span class="line">    <span class="keyword">return</span> mys; <span class="comment">/* 返回有效的指针 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何使用-is_err-和-ptr_err它们是什么意思"><strong>如何使用IS_ERR 和 PTR_ERR？它们是什么意思？</strong></h3><p>根据内核定义，有三个宏： * <strong><code>IS_ERR</code></strong> -用于检查。如果 <code>ptr</code> 是一个错误指针则返回非 <code>0</code>值。否则，如果不是错误则返回 <code>0</code>。 *<strong><code>PTR_ERR</code></strong> -用于打印。获取指针中当前（编码的错误）值。 *<strong><code>IS_ERR_VALUE</code></strong> - 在此有更详细的解释(here1)。</p><p>我发现这些宏对于内核空间编程非常有用。用法如下 - 如果<code>ptr</code> 是你要检查的指针，则按如下方式使用： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IS_ERR(ptr))</span><br><span class="line">     printk(<span class="string">&quot;Error here: %ld&quot;</span>, PTR_ERR(ptr)); <span class="comment">/* 打印出错误码 */</span></span><br></pre></td></tr></table></figure>它们在内核中的代码定义如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_ERR_VALUE(x) unlikely((x) &gt;= (unsigned long)-MAX_ERRNO)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> * __must_check <span class="title function_">ERR_PTR</span><span class="params">(<span class="type">long</span> error)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> __must_check <span class="title function_">PTR_ERR</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span>) ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> __must_check <span class="title function_">IS_ERR</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IS_ERR_VALUE((<span class="type">unsigned</span> <span class="type">long</span>)ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> __must_check <span class="title function_">IS_ERR_OR_NULL</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !ptr || IS_ERR_VALUE((<span class="type">unsigned</span> <span class="type">long</span>)ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;孤儿进程与僵尸进程-orphans-and-zombies&quot;&gt;&lt;strong&gt;26.2
孤儿进程与僵尸进程 (Orphans and Zombies)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;父进程和子进程的生命周期通常并不相同——要么父进程比子进程存活时间长，要么</summary>
      
    
    
    
    <category term="os basic" scheme="https://mackz-maxw.github.io/categories/os-basic/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统基础 | 5.6 等待子进程</title>
    <link href="https://mackz-maxw.github.io/2025/09/09/oper_sys26wait/"/>
    <id>https://mackz-maxw.github.io/2025/09/09/oper_sys26wait/</id>
    <published>2025-09-09T17:03:53.123Z</published>
    <updated>2025-09-09T17:04:04.283Z</updated>
    
    <content type="html"><![CDATA[<h3 id="等待子进程-waiting-on-a-child-process"><strong>等待子进程(Waiting on a Child Process)</strong></h3><p>在许多由父进程创建子进程的应用程序中，父进程能够监视子进程以了解它们于何时以及如何终止是非常有用的。<code>wait()</code>系统调用及一系列相关的系统调用提供了这个功能。</p><h3 id="wait-系统调用-the-wait-system-call"><strong><code>wait()</code>系统调用 (The wait() System Call)</strong></h3><p><code>wait()</code> 系统调用等待调用进程的任一子进程终止，并在<code>status</code> 参数所指向的缓冲区中返回该子进程的终止状态。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure><p><strong>返回值：</strong> 成功则返回终止子进程的进程ID(PID)，出错则返回 -1。</p><p><code>wait()</code> 系统调用执行以下操作：</p><ol type="1"><li>如果调用进程的（先前未被等待的）子进程中尚无一个终止，则该调用会<strong>阻塞</strong>，直到某个子进程终止为止。如果在调用时已有子进程终止，<code>wait()</code>则立即返回。</li><li>如果 <code>status</code> 参数不是<code>NULL</code>，则关于子进程如何终止的信息会通过 <code>status</code>指针所指向的整数返回。我们将在第 26.1.3 节描述 <code>status</code>返回的信息。</li><li>内核会将此子进程的 CPU 时间（第 10.7 节）和资源使用统计信息（第 36.1节）添加到其父进程所有子进程的运行总计时长中。</li><li>作为其函数结果，<code>wait()</code> 返回已终止子进程的进程 ID。</li></ol><p>出错时，<code>wait()</code> 返回-1。一个可能的错误是调用进程没有（先前未被等待的）子进程，这由<code>errno</code> 值 <code>ECHILD</code>指示。这意味着我们可以使用以下循环来等待调用进程的所有子进程终止：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((childPid = wait(<span class="literal">NULL</span>)) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (errno != ECHILD)    <span class="comment">/* 发生意外错误... */</span></span><br><span class="line">    errExit(<span class="string">&quot;wait&quot;</span>);  </span><br></pre></td></tr></table></figure><p>以下代码演示了 <code>wait()</code>的用法。该程序创建多个子进程，每个命令行整数参数对应一个子进程。每个子进程休眠其对应命令行参数所指定的秒数，然后退出。与此同时，在创建完所有子进程后，父进程反复调用<code>wait()</code> 来监视其子进程的终止。此循环持续直到<code>wait()</code> 返回-1。（这不是唯一的方法：我们也可以选择当终止的子进程数量<code>numDead</code> 匹配创建的子进程数量时退出循环。）</p><p><strong>创建并等待多个子进程</strong><code>––––––––––––––––––––––––––––––––––––––––––––––––––––– procexec/multi_wait.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;curr_time.h&quot;</span>              <span class="comment">/* Declaration of currTime() */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> numDead;       <span class="comment">/* 目前已等待的子进程数量 */</span></span><br><span class="line">    <span class="type">pid_t</span> childPid;    <span class="comment">/* 被等待的子进程的PID */</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        usageErr(<span class="string">&quot;%s sleep-time...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);           <span class="comment">/* 禁用 stdout 的缓冲 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++) &#123;    <span class="comment">/* 为每个参数创建一个子进程 */</span></span><br><span class="line">        <span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:                     <span class="comment">/* 子进程：休眠一段时间后退出 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s] child %d started with PID %ld, sleeping %s &quot;</span></span><br><span class="line">                    <span class="string">&quot;seconds\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>), j, (<span class="type">long</span>) getpid(), argv[j]);</span><br><span class="line">            sleep(getInt(argv[j], GN_NONNEG, <span class="string">&quot;sleep-time&quot;</span>));</span><br><span class="line">            _exit(EXIT_SUCCESS);</span><br><span class="line">        <span class="keyword">default</span>:                    <span class="comment">/* 父进程：继续循环 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numDead = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                      <span class="comment">/* 父进程等待每个子进程退出 */</span></span><br><span class="line">        childPid = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (childPid == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == ECHILD) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No more children - bye!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                <span class="comment">/* 发生其他（意外）错误 */</span></span><br><span class="line">                errExit(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        numDead++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s] wait() returned child PID %ld (numDead=%d)\n&quot;</span>,</span><br><span class="line">                currTime(<span class="string">&quot;%T&quot;</span>), (<span class="type">long</span>) childPid, numDead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的 shell 会话日志展示了我们使用该程序创建三个子进程时发生的情况：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./multi_wait 7 1 4</span><br><span class="line">[13:41:00] child 1 started with PID 21835, sleeping 7 seconds</span><br><span class="line">[13:41:00] child 2 started with PID 21836, sleeping 1 seconds</span><br><span class="line">[13:41:00] child 3 started with PID 21837, sleeping 4 seconds</span><br><span class="line">[13:41:01] wait() returned child PID 21836 (numDead=1)</span><br><span class="line">[13:41:04] wait() returned child PID 21837 (numDead=2)</span><br><span class="line">[13:41:07] wait() returned child PID 21835 (numDead=3)</span><br><span class="line">No more children - bye!</span><br></pre></td></tr></table></figure> 如果在某个特定时刻有多个子进程已终止，SUSv3 (Single UNIXSpecification, version 3) 未明确规定一系列 <code>wait()</code>调用回收这些子进程的顺序；也就是说，顺序依赖于实现。即使在不同的 Linux内核版本之间，该行为也有所不同。</p><h3id="waitpid-系统调用-the-waitpid-system-call"><strong><code>waitpid()</code>系统调用 (The waitpid() System Call)</strong></h3><p><code>wait()</code> 系统调用有一些局限性，<code>waitpid()</code>的设计正是为了应对这些局限性：</p><ul><li>如果一个父进程创建了多个子进程，使用 <code>wait()</code>无法等待<strong>特定某个子进程</strong>的完成；我们只能等待<strong>下一个终止</strong>的子进程。</li><li>如果尚无子进程终止，<code>wait()</code><strong>总是会阻塞</strong>。有时，更可取的是执行<strong>非阻塞的等待</strong>，这样如果尚无子进程终止，我们可以立即获得相应的指示。</li><li>使用<code>wait()</code>，我们只能获知那些<strong>已经终止</strong>的子进程的信息。无法在一个子进程被信号（如<code>SIGSTOP</code> 或<code>SIGTTIN</code>）<strong>停止</strong>时，或在一个被停止的子进程因收到<code>SIGCONT</code> 信号而<strong>恢复</strong>执行时得到通知。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure><p><strong>返回值：</strong> 成功则返回状态发生变化的子进程的进程ID(PID)；如果指定了 <code>WNOHANG</code> 且未有子进程状态变化则返回0；出错则返回 -1。</p><p><code>waitpid()</code> 的返回值和 <code>status</code> 参数与<code>wait()</code> 相同。（关于通过 <code>status</code>返回值的解释，请参见第 26.1.3 节）。<code>pid</code>参数用于选择要等待的子进程，具体如下：</p><ul><li>如果 <code>pid</code> <strong>大于 0</strong>，则等待进程 ID 等于<code>pid</code> 的那个子进程。</li><li>如果 <code>pid</code> <strong>等于0</strong>，则等待与调用者（父进程）<strong>属于同一进程组</strong>的任何子进程。我们将在第34.2 节描述进程组。</li><li>如果 <code>pid</code> <strong>小于-1</strong>，则等待其<strong>进程组标识符</strong>等于 <code>pid</code>绝对值 (<code>abs(pid)</code>) 的任何子进程。</li><li>如果 <code>pid</code> <strong>等于-1</strong>，则等待<strong>任何</strong>子进程。调用<code>wait(&amp;status)</code> 等价于调用<code>waitpid(-1, &amp;status, 0)</code>。</li></ul><p><code>options</code> 参数是一个位掩码，可以包含（通过 OR操作）以下零个或多个标志（所有这些标志都在 SUSv3 中指定）：</p><ul><li><strong><code>WUNTRACED</code></strong>除了返回关于已终止子进程的信息外，还会在子进程因收到信号而<strong>停止</strong>时返回其信息。</li><li><strong><code>WCONTINUED</code></strong> (自 Linux 2.6.10 起)还会在因收到 <code>SIGCONT</code>信号而<strong>恢复</strong>执行的、之前被停止的子进程的状态信息。</li><li><strong><code>WNOHANG</code></strong> 如果由 <code>pid</code>指定的子进程尚未改变状态，则立即返回而非阻塞（即执行一次“<strong>轮询</strong>”）。在这种情况下，<code>waitpid()</code>的返回值为 <code>0</code>。如果调用进程没有符合 <code>pid</code>指定条件的子进程，则 <code>waitpid()</code> 失败并返回错误<code>ECHILD</code>。</li></ul><p>我们将在清单 26-3 中演示 <code>waitpid()</code> 的用法。</p><hr /><p><strong>附加说明 (关于 WUNTRACED 名称的由来)：</strong></p><p>在其关于 <code>waitpid()</code> 的原理说明中，SUSv3 指出名称<code>WUNTRACED</code> 是该标志源自 BSD 的一个历史产物，在 BSD中，一个进程可以通过两种方式之一被停止：一种是由于被<code>ptrace()</code>系统调用<strong>跟踪</strong>的结果，另一种是被信号<strong>停止</strong>（即未被跟踪）。当一个子进程被<code>ptrace()</code> 跟踪时，<strong>任何信号</strong>（除了<code>SIGKILL</code>）的送达都会导致该子进程被停止，并随之向父进程发送一个<code>SIGCHLD</code>信号。即使子进程<strong>忽略</strong>该信号，此行为也会发生。然而，如果子进程<strong>阻塞</strong>了该信号，则它不会被停止（除非该信号是<code>SIGSTOP</code>，它无法被阻塞）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;等待子进程-waiting-on-a-child-process&quot;&gt;&lt;strong&gt;等待子进程
(Waiting on a Child Process)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在许多由父进程创建子进程的应用程序中，父进程能够监视子进程以了解它们于何</summary>
      
    
    
    
    <category term="os basic" scheme="https://mackz-maxw.github.io/categories/os-basic/"/>
    
    
  </entry>
  
  <entry>
    <title>算法笔试 | acm模式输入输出指南</title>
    <link href="https://mackz-maxw.github.io/2025/09/05/intv_io/"/>
    <id>https://mackz-maxw.github.io/2025/09/05/intv_io/</id>
    <published>2025-09-05T15:18:58.070Z</published>
    <updated>2025-09-04T19:50:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用c++作为笔试语言 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ====== 基础输入输出 ======</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取多个整数</span></span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入三个整数(用空格分隔): &quot;</span>;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;三个整数分别是: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除输入缓冲区</span></span><br><span class="line">    cin.<span class="built_in">ignore</span>(INT_MAX, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ====== 读取整行输入 ======</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n整行输入示例:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    string line;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入一行文本: &quot;</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;你输入的文本是: &quot;</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ====== 处理大数字 ======</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n大数字处理示例:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 32位大整数 (使用long)</span></span><br><span class="line">    <span class="type">long</span> big32;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入一个32位大整数: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; big32;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;32位大整数: &quot;</span> &lt;&lt; big32 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 64位大整数 (使用long long)</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> big64;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入一个64位大整数: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; big64;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;64位大整数: &quot;</span> &lt;&lt; big64 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cin.<span class="built_in">ignore</span>(INT_MAX, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ====== 字符串流处理 ======</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n字符串流处理示例:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入多个用空格分隔的整数: &quot;</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);  <span class="comment">// 使用逗号作为分隔符：getline(ss, line, &#x27;,&#x27;)</span></span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; num) &#123;</span><br><span class="line">        numbers.<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;提取的数字: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : numbers) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ====== 多组输入数据 ======</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n多组输入数据示例:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入多行数据，每行两个整数(输入0 0结束):&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; x &gt;&gt; y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;和: &quot;</span> &lt;&lt; (x + y) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除状态并忽略剩余内容</span></span><br><span class="line">    cin.<span class="built_in">clear</span>();</span><br><span class="line">    cin.<span class="built_in">ignore</span>(INT_MAX, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ====== 文件结束处理 ======</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n文件结束处理示例(输入Ctrl+Z或Ctrl+D结束):&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入多个整数:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; eofNumbers;</span><br><span class="line">    <span class="type">int</span> input;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; input) &#123;</span><br><span class="line">        eofNumbers.<span class="built_in">push_back</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cin.<span class="built_in">clear</span>();</span><br><span class="line">    cin.<span class="built_in">ignore</span>(INT_MAX, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入的数字: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : eofNumbers) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ====== 格式化输出 ======</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n格式化输出示例:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.141592653589793</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;默认输出: &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;保留4位: &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;保留10位: &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 恢复默认精度</span></span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ====== 实战示例 ======</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n实战示例: 计算一系列数字的平均值&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入多个数字(用空格分隔): &quot;</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);</span><br><span class="line">    <span class="function">stringstream <span class="title">ss2</span><span class="params">(line)</span></span>;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ss2 &gt;&gt; num) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;平均值: &quot;</span> &lt;&lt; (sum / count) &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有输入数字&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;使用c++作为笔试语言 &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;b</summary>
      
    
    
    
    <category term="interview" scheme="https://mackz-maxw.github.io/categories/interview/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统基础 | 5.5 终止进程</title>
    <link href="https://mackz-maxw.github.io/2025/09/03/oper_sys25exit/"/>
    <id>https://mackz-maxw.github.io/2025/09/03/oper_sys25exit/</id>
    <published>2025-09-04T00:03:19.864Z</published>
    <updated>2025-09-04T00:03:43.552Z</updated>
    
    <content type="html"><![CDATA[<h3 id="终止进程_exit-和-exit">终止进程：<code>_exit()</code> 和<code>exit()</code></h3><p>进程可以通过两种通用方式终止。其中一种是<strong>异常终止</strong>，由接收到一个默认动作为终止进程（可能伴随核心转储）的信号引起。另一种方式是，进程可以使用<code>_exit()</code> 系统调用进行<strong>正常终止</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure><p>传递给 <code>_exit()</code> 的 <code>status</code>参数定义了进程的<strong>终止状态</strong>，该状态在此进程的父进程调用<code>wait()</code> 时可用。虽然定义为 <code>int</code>类型，但实际上只有 <code>status</code> 的低 <strong>8位</strong>会提供给父进程。按照惯例，终止状态 <strong>0</strong>表示进程<strong>成功完成</strong>，而<strong>非零</strong>状态值表示进程<strong>未成功终止</strong>。对于如何解释非零状态值没有固定规则；不同的应用程序遵循自己的惯例，这些惯例应在它们的文档中描述。SUSv3规定了两个常量 <code>EXIT_SUCCESS</code> (0) 和<code>EXIT_FAILURE</code> (1)，本书中的大多数程序都使用它们。进程总是被<code>_exit()</code> <strong>成功终止</strong>（即 <code>_exit()</code>从不返回）。</p><p>尽管任何在 0 到 255 范围内的值都可以通过 <code>_exit()</code> 的<code>status</code> 参数传递给父进程，但指定大于 128 的值可能会在 shell脚本中引起混淆。原因是，当一个命令被信号终止时，shell 通过将变量<code>$?</code> 的值设置为 <strong>128 加上信号编号</strong>来表明这一事实，而这个值与进程以相同的状态值调用 <code>_exit()</code>所产生的值无法区分。</p><p>程序通常不直接调用 <code>_exit()</code>，而是调用 <code>exit()</code>库函数，该函数在调用 <code>_exit()</code> 之前会执行各种操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure><p><code>exit()</code> 执行以下操作： *调用<strong>退出处理程序</strong>（使用 <code>atexit()</code> 和<code>on_exit()</code>注册的函数），调用顺序与注册顺序<strong>相反</strong>。 *<strong>刷新</strong> stdio 流缓冲区。 * 使用 <code>status</code>中提供的值调用 <code>_exit()</code> 系统调用。</p><p>与 UNIX 特有的 <code>_exit()</code> 不同，<code>exit()</code>被定义为标准 C 库的一部分；也就是说，它在每个 C 实现中都可用。</p><p>进程终止的另一种方式是从 <code>main()</code> 返回，无论是通过显式<code>return</code> 语句，还是通过执行到 <code>main()</code>函数末尾而隐式返回。执行显式的 <code>return n</code> 通常等同于调用<code>exit(n)</code>，因为调用 <code>main()</code> 的运行时函数会在调用<code>exit()</code> 时使用 <code>main()</code> 的返回值。</p><p>在一种情况下，调用 <code>exit()</code> 和从 <code>main()</code>返回并不等效。如果在退出处理期间执行的任何步骤访问了 <code>main()</code>的局部变量，那么从 <code>main()</code>返回会导致<strong>未定义行为</strong>。例如，如果在调用<code>setvbuf()</code> 或 <code>setbuf()</code>（第13.2节）时指定了<code>main()</code> 的局部变量，就可能发生这种情况。</p><p>执行不指定值的 <code>return</code>，或者执行到 <code>main()</code>函数末尾，也会导致 <code>main()</code> 的调用者调用<code>exit()</code>，但结果会根据所支持的 C标准版本和所使用的编译选项而有所不同： * 在 <strong>C89</strong>中，这些情况下的行为是<strong>未定义的</strong>；程序可能以任意状态值终止。这是在Linux 上使用 <code>gcc</code> 时的默认行为，程序的退出状态取自栈上或特定CPU 寄存器中的某个随机值。应避免以这种方式终止程序。 *<strong>C99</strong> 标准要求执行到主程序末尾应等同于调用<code>exit(0)</code>。如果我们在 Linux 上使用 <code>gcc –std=c99</code>编译程序，就会得到这种行为。</p><h3 id="进程终止的细节">进程终止的细节</h3><p>在进程的正常和异常终止期间，会发生以下操作： *打开的<strong>文件描述符</strong>、<strong>目录流</strong>（第18.8节）、<strong>消息目录描述符</strong>（参见<code>catopen(3)</code> 和 <code>catgets(3)</code>手册页）和<strong>转换描述符</strong>（参见 <code>iconv_open(3)</code>手册页）被关闭。 *作为关闭文件描述符的后果，此进程持有的任何<strong>文件锁</strong>（第55章）都会被释放。* 任何附加的 <strong>System V共享内存段</strong>都会被分离（detach），并且相应每个段的<code>shm_nattch</code> 计数器减一（参见第48.8节）。 * 对于进程已设置了<code>semadj</code> 值的每个 <strong>System V 信号量</strong>，该<code>semadj</code> 值会被添加到信号量值中（参见第47.8节）。 *如果此进程是某个控制终端的<strong>控制进程</strong>，则<strong><code>SIGHUP</code>信号</strong>会被发送到该控制终端前台进程组中的每个进程，并且该终端与会话分离。我们将在第34.6节进一步讨论这一点。* 调用进程中打开的任何 <strong>POSIX命名信号量</strong>都会被关闭，就像调用了 <code>sem_close()</code>一样。 * 调用进程中打开的任何 <strong>POSIX消息队列</strong>都会被关闭，就像调用了 <code>mq_close()</code> 一样。 *如果由于此进程退出导致一个进程组变为<strong>孤儿进程组</strong>，并且该组中存在任何<strong>停止的(stopped)</strong> 进程，则该组中的所有进程都会收到一个<code>SIGHUP</code> 信号，随后是一个 <code>SIGCONT</code>信号。我们将在第34.7.4节进一步讨论这一点。 * 此进程使用<code>mlock()</code> 或<code>mlockall()</code>（第50.2节）建立的任何<strong>内存锁</strong>会被移除。* 此进程使用 <code>mmap()</code>建立的任何<strong>内存映射</strong>会被取消映射（unmapped）。</p><h3 id="退出处理程序-exit-handlers">退出处理程序 (Exit Handlers)</h3><p>有时，应用程序需要在进程终止时自动执行一些操作。考虑这样一个例子：一个应用程序库，如果在进程的生命周期中被使用，需要在进程退出时自动执行一些清理操作。由于该库无法控制进程何时以及如何退出，也不能强制主程序在退出前调用库特定的清理函数，因此无法保证清理一定会发生。在这种情况下，一种方法是使用<strong>退出处理程序</strong>（exithandler）（较老的 System V 手册使用术语“程序终止例程”）。</p><p>退出处理程序是由程序员提供的函数，在进程生命周期的某个时间点<strong>注册</strong>，然后在进程通过<code>exit()</code>正常终止时被<strong>自动调用</strong>。如果程序直接调用<code>_exit()</code>或者进程被信号异常终止，则<strong>不会调用</strong>退出处理程序。</p><p>在某种程度上，进程被信号终止时不调用退出处理程序这一事实限制了它们的实用性。我们能做的最好方式是为可能发送给进程的信号建立处理程序，并让这些处理程序设置一个标志，促使主程序调用<code>exit()</code>。（因为 <code>exit()</code>不在表21-1（第426页）列出的异步信号安全函数中，所以我们通常不能从信号处理程序中调用它。）即使这样，也无法处理<code>SIGKILL</code>的情况，因为它的默认动作无法更改。这是我们应避免使用<code>SIGKILL</code> 终止进程（如第20.2节所述）而应使用<code>SIGTERM</code>（这是 <code>kill</code>命令发送的默认信号）的又一个理由。</p><p><strong>注册退出处理程序</strong> GNU C库提供了两种注册退出处理程序的方法。第一种方法，由 SUSv3 规定，是使用<code>atexit()</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure><p>成功返回 0，错误返回非零值</p><p><code>atexit()</code> 函数将 <code>func</code>添加到一个函数列表中，这些函数在进程终止时被调用。函数 <code>func</code>应定义为不接收参数且不返回值，因此具有以下一般形式： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* 执行一些操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意，<code>atexit()</code> 在出错时返回一个非零值（不一定是 -1）。</p><p>可以注册多个退出处理程序（甚至多次注册同一个退出处理程序）。当程序调用<code>exit()</code>时，这些函数按<strong>注册顺序的逆序</strong>被调用。这个顺序是合乎逻辑的，因为通常较早注册的函数执行更基本的清理类型，这些清理可能需要在后注册的函数之后执行。</p><p>本质上，可以在退出处理程序内部执行任何所需的操作，包括注册额外的退出处理程序（这些新处理程序会被放在待调用退出处理程序列表的头部）。但是，如果其中一个退出处理程序<strong>未能返回</strong>——要么是因为它调用了<code>_exit()</code>，要么是因为进程被信号终止（例如，退出处理程序调用了<code>raise()</code>）——那么剩余的退出处理程序将不会被调用。此外，<code>exit()</code>通常会执行的剩余操作（即刷新 stdio 缓冲区）也不会执行。</p><p>SUSv3 规定，如果退出处理程序自身调用<code>exit()</code>，结果是未定义的。在 Linux上，剩余的退出处理程序会正常调用。然而，在一些系统上，这会导致所有退出处理程序再次被调用，这可能引发无限递归（直到栈溢出杀死进程）。可移植的应用程序应避免在退出处理程序内部调用<code>exit()</code>。</p><p>SUSv3 要求实现允许一个进程至少能够注册 32 个退出处理程序。使用调用<code>sysconf(_SC_ATEXIT_MAX)</code>，程序可以确定实现定义的可以注册的退出处理程序数量的上限。（但是，无法查明已经注册了多少退出处理程序。）通过将注册的退出处理程序链入一个动态分配的链表，glibc允许注册几乎无限数量的退出处理程序。在 Linux上，<code>sysconf(_SC_ATEXIT_MAX)</code> 返回2,147,482,647（即最大的有符号 32位整数）。换句话说，在达到可注册函数数量的限制之前，其他东西（例如内存不足）就会先出问题。</p><p>通过 <code>fork()</code>创建的子进程<strong>继承</strong>其父进程的退出处理程序注册的一个副本。当进程执行<code>exec()</code>时，<strong>所有</strong>退出处理程序注册都会被<strong>移除</strong>。（这必然是如此的，因为<code>exec()</code>会替换掉退出处理程序的代码以及现有程序的其余代码。）</p><p>我们无法<strong>注销</strong>一个已经用<code>atexit()</code>（或下面描述的<code>on_exit()</code>）注册的退出处理程序。但是，我们可以让退出处理程序在执行其操作之前检查某个全局标志是否设置，并通过清除该标志来禁用该退出处理程序。</p><p>用 <code>atexit()</code>注册的退出处理程序有<strong>几个局限性</strong>。第一个是当被调用时，退出处理程序<strong>不知道</strong>传递给<code>exit()</code>的状态（status）是什么。偶尔，了解这个状态可能有用；例如，我们可能希望根据进程是成功退出还是不成功退出执行不同的操作。第二个局限性是，我们无法在调用退出处理程序时为其指定<strong>参数</strong>。这种功能可能有助于定义一个根据其参数执行不同操作的退出处理程序，或者用不同的参数多次注册同一个函数。</p><p>为了解决这些局限性，glibc提供了一种（非标准的）注册退出处理程序的替代方法：<code>on_exit()</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE           <span class="comment">/* 或者: #define _SVID_SOURCE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">on_exit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">int</span>, <span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure><p>成功返回 0，错误返回非零值</p><p><code>on_exit()</code> 的 <code>func</code>参数是一个指向如下类型函数的指针： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> status, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">/* 执行清理操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当被调用时，<code>func()</code> 被传入两个参数：提供给<code>exit()</code> 的 <code>status</code> 参数，以及注册该函数时提供给<code>on_exit()</code> 的 <code>arg</code>参数的副本。虽然定义为指针类型，但 <code>arg</code>可由程序员自由解释。它可以被用作指向某个结构的指针；同样地，通过明智地使用类型转换，它可以被视为整数或其他标量类型。</p><p>与 <code>atexit()</code> 一样，<code>on_exit()</code>出错时返回非零值（不一定是 -1）。与 <code>atexit()</code> 一样，可以使用<code>on_exit()</code> 注册多个退出处理程序。使用 <code>atexit()</code>和 <code>on_exit()</code>注册的函数被放在同一个列表中。如果在同一个程序中同时使用这两种方法，则退出处理程序按使用这两种方法<strong>注册顺序的逆序</strong>调用。</p><p>虽然比 <code>atexit()</code> 更灵活，但 <code>on_exit()</code>在旨在可移植的程序中应<strong>避免使用</strong>，因为它不受任何标准涵盖，并且在其他UNIX 实现上很少可用。</p><p><strong>示例程序</strong> 以下代码演示了使用 <code>atexit()</code> 和<code>on_exit()</code> 注册退出处理程序。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE     <span class="comment">/* 从 &lt;stdlib.h&gt; 获取 on_exit() 声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">atexitFunc1</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;atexit function 1 called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">atexitFunc2</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;atexit function 2 called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">onexitFunc</span><span class="params">(<span class="type">int</span> exitStatus, <span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;on_exit function called: status=%d, arg=%ld\n&quot;</span>,</span><br><span class="line">                exitStatus, (<span class="type">long</span>) arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (on_exit(onexitFunc, (<span class="type">void</span> *) <span class="number">10</span>) != <span class="number">0</span>)</span><br><span class="line">        fatal(<span class="string">&quot;on_exit 1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (atexit(atexitFunc1) != <span class="number">0</span>)</span><br><span class="line">        fatal(<span class="string">&quot;atexit 1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (atexit(atexitFunc2) != <span class="number">0</span>)</span><br><span class="line">        fatal(<span class="string">&quot;atexit 2&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (on_exit(onexitFunc, (<span class="type">void</span> *) <span class="number">20</span>) != <span class="number">0</span>)</span><br><span class="line">        fatal(<span class="string">&quot;on_exit 2&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当我们运行这个程序时，会看到以下输出： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./exit_handlers</span><br><span class="line">on_exit function called: status=2, arg=20</span><br><span class="line">atexit function 2 called</span><br><span class="line">atexit function 1 called</span><br><span class="line">on_exit function called: status=2, arg=10</span><br></pre></td></tr></table></figure></p><p><strong>(输出顺序解释)</strong>处理程序按<strong>注册顺序的逆序</strong>调用： * 最后注册的是<code>on_exit</code> (arg=20)，所以最先调用。 * 然后是<code>atexitFunc2</code>。 * 然后是 <code>atexitFunc1</code>。 *最后是第一个注册的 <code>on_exit</code> (arg=10)。</p><h3 id="forkstdio-缓冲区与-_exit-之间的交互"><code>fork()</code>、stdio缓冲区与 <code>_exit()</code> 之间的交互</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;Ciao\n&quot;</span>, <span class="number">5</span>); <span class="comment">// 直接写入当前打开的文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父子进程都会执行到这里 */</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上程序的输出展示了一个起初令人费解的现象。当我们直接在终端运行此程序时，会看到预期的结果：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./fork_stdio_buf</span><br><span class="line">Hello world</span><br><span class="line">Ciao</span><br></pre></td></tr></table></figure> 然而，当我们将标准输出重定向到一个文件时，却看到以下情况：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./fork_stdio_buf &gt; a</span><br><span class="line">$ <span class="built_in">cat</span> a</span><br><span class="line">Ciao</span><br><span class="line">Hello world</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure> 在上面的输出中，我们看到两件奇怪的事情：由<code>printf()</code> 写入的行出现了两次，并且 <code>write()</code>的输出先于 <code>printf()</code> 的输出出现。</p><p>要理解为什么用 <code>printf()</code>写入的消息会出现两次，需要回忆一下：<strong>stdio缓冲区是在进程的用户空间内存中维护的</strong>（参见第13.2节）。因此，这些缓冲区在<code>fork()</code> 时会被<strong>子进程复制</strong>。</p><p>当标准输出指向终端时，默认是<strong>行缓冲</strong>的，因此由<code>printf()</code>写入的以换行符终止的字符串会<strong>立即显示</strong>。然而，当标准输出重定向到文件时，默认是<strong>块缓冲</strong>的。因此，在我们的例子中，在<code>fork()</code> 发生时，由 <code>printf()</code>写入的字符串仍然位于父进程的 stdio缓冲区中，并且这个字符串被子进程复制。当父进程和子进程随后调用<code>exit()</code> 时，它们都会<strong>刷新</strong>各自的 stdio缓冲区副本，从而导致<strong>重复的输出</strong>。</p><p>我们可以通过以下方法之一来防止出现这种重复输出： * 作为解决 stdio缓冲问题的特定方案，我们可以在调用 <code>fork()</code><strong>之前</strong>使用 <code>fflush()</code> 来刷新 stdio缓冲区。或者，我们可以使用 <code>setvbuf()</code> 或<code>setbuf()</code> 来<strong>禁用</strong> stdio 流的缓冲。 *子进程可以调用 <code>_exit()</code> 而不是<code>exit()</code>，这样它就不会刷新 stdio缓冲区。这项技术阐明了一个更通用的原则：在创建子进程的应用程序中，通常<strong>只有一个进程</strong>（最常见的是父进程）应该通过<code>exit()</code> 终止，而其他进程应该通过 <code>_exit()</code>终止。这确保了只有一个进程调用退出处理程序并刷新 stdio缓冲区，这通常是可取的。</p><p>也存在其他允许父进程和子进程都调用 <code>exit()</code>的方法（有时是必要的）。例如，可以设计退出处理程序，使得即使从多个进程调用也能正确运行；或者让应用程序在调用<code>fork()</code><strong>之后</strong>才安装退出处理程序。此外，有时我们可能确实希望所有进程在<code>fork()</code> 后都刷新其 stdio缓冲区。在这种情况下，我们可以选择使用 <code>exit()</code>终止进程，或者根据情况在每个进程中使用显式的 <code>fflush()</code>调用。</p><p>示例程序中 <code>write()</code> 的输出没有出现两次，是因为<code>write()</code>将数据<strong>直接传输到内核缓冲区</strong>，而该缓冲区在<code>fork()</code> 期间<strong>不会被复制</strong>。</p><p>现在，程序输出重定向到文件时的第二个奇怪之处的原因应该很清楚了。<code>write()</code>的输出出现在 <code>printf()</code> 的<strong>输出之前</strong>，是因为<code>write()</code>的输出会<strong>立即</strong>传输到内核缓冲区缓存，而<code>printf()</code> 的输出只有在调用 <code>exit()</code> 刷新 stdio缓冲区时才会被传输。（通常，如第13.7节所述，在同一文件上混合使用 stdio函数和系统调用来执行 I/O 时需要小心。）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;终止进程_exit-和-exit&quot;&gt;终止进程：&lt;code&gt;_exit()&lt;/code&gt; 和
&lt;code&gt;exit()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;进程可以通过两种通用方式终止。其中一种是&lt;strong&gt;异常终止&lt;/strong&gt;，由接收到一个默认动作为终止进</summary>
      
    
    
    
    <category term="os basic" scheme="https://mackz-maxw.github.io/categories/os-basic/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统基础 | 5.3 信号；fork</title>
    <link href="https://mackz-maxw.github.io/2025/08/27/oper_sys24fork/"/>
    <id>https://mackz-maxw.github.io/2025/08/27/oper_sys24fork/</id>
    <published>2025-08-28T01:15:23.649Z</published>
    <updated>2025-08-28T01:17:07.408Z</updated>
    
    <content type="html"><![CDATA[<h3 id="信号的概念">信号的概念</h3><p>信号（Signal）是通知进程已发生某种事件的一种机制。信号有时被描述为<strong>软件中断</strong>（softwareinterrupts）。信号与硬件中断类似，因为它们会中断程序的正常执行流程；在大多数情况下，无法精确预测信号何时到达。一个进程（如果它具有适当的权限）可以向另一个进程发送信号。这种用途下，信号可以作为一种同步技术，甚至作为一种原始的<strong>进程间通信（IPC）</strong>形式。进程也可以向自己发送信号。</p><p>然而，传递给进程的许多信号的通常来源是<strong>内核</strong>（kernel）。导致内核为进程生成信号的事件类型包括：</p><ul><li><strong>发生硬件异常</strong>：这意味着硬件检测到故障条件并通知内核，内核随后向相关进程发送相应的信号。硬件异常的例子包括：执行格式错误的机器语言指令、除以0、或引用了无法访问的内存区域。</li><li><strong>用户键入了能生成信号的终端特殊字符</strong>。这些字符包括中断字符（通常是<code>Control-C</code>）和挂起字符（通常是<code>Control-Z</code>）。</li><li><strong>发生软件事件</strong>。例如：文件描述符上有输入可用、终端窗口大小改变、定时器超时、进程的CPU时间限制已超过、或该进程的一个子进程终止。</li></ul><p>每个信号都被定义为一个唯一的（小）整数，从1开始顺序编号。这些整数在<code>&lt;signal.h&gt;</code> 头文件中用 <code>SIGxxxx</code>形式的符号名定义。由于每个信号使用的实际数字因实现而异，因此在程序中总是使用这些符号名称。例如，当用户键入中断字符时，<code>SIGINT</code>（信号编号2）被传递给进程。</p><p>信号分为两大类。第一组构成了<strong>传统或标准信号</strong>（standardsignals），内核使用它们来通知进程事件。在Linux上，标准信号编号从1到31。本章我们描述标准信号。另一组信号由<strong>实时信号</strong>（realtimesignals）组成，其与标准信号的区别将在第22.8节描述。</p><p>信号被认为是<strong>由某个事件产生</strong>（generated）。一旦产生，信号随后会被<strong>递送</strong>（delivered）给一个进程，该进程随后会采取某些<strong>动作</strong>（action）来响应信号。在信号产生和递送之间的时间段，信号被称为<strong>处于等待状态</strong>（pending）。通常，一个等待中的信号会在进程下一次被调度运行时立即递送，如果进程已经在运行则立即递送（例如，进程向自己发送信号）。</p><p>然而，有时我们需要确保一段代码不会因信号的递送而中断。为此，我们可以将一个信号添加到进程的<strong>信号掩码</strong>（signalmask）中——这是一组当前<strong>被阻塞</strong>（blocked）递送的信号。如果一个信号在阻塞状态下产生，它将保持等待状态，直到后来被<strong>解除阻塞</strong>（unblocked）（从信号掩码中移除）。各种系统调用允许进程向其信号掩码中添加和移除信号。</p><p>根据信号的不同，信号被递送时，进程会执行以下<strong>默认动作</strong>（defaultactions）之一：</p><ul><li><strong>忽略信号</strong>（Ignored）：即信号被内核丢弃，对进程没有影响。（进程甚至不知道它发生了。）</li><li><strong>进程被终止</strong>（Terminated）（杀死）。这有时被称为异常进程终止，与进程使用<code>exit()</code> 终止的正常进程终止相对。</li><li><strong>生成核心转储文件</strong>（Core dumpfile）且进程被终止。核心转储文件包含进程虚拟内存的一个映像，可以将其加载到调试器中，以检查进程终止时的状态。</li><li><strong>进程被停止</strong>（Stopped）——进程的执行被暂停。</li><li><strong>进程被恢复</strong>（Resumed）执行——在之前被停止后恢复执行。</li></ul><p>程序可以改变信号递送时发生的动作，而不是接受特定信号的默认动作。这被称为设置信号的<strong>处置方式</strong>（disposition）。程序可以为信号设置以下处置方式之一：</p><ul><li>发生<strong>默认动作</strong>。这对于撤销之前将信号处置方式更改为非默认值的操作很有用。</li><li><strong>忽略</strong>信号。这对于那些默认动作是终止进程的信号很有用。</li><li>执行一个<strong>信号处理程序</strong>（signalhandler）。信号处理程序是由程序员编写的函数，它执行适当的任务以响应信号的递送。例如，shell有一个用于 <code>SIGINT</code> 信号（由中断字符 <code>Control-C</code>产生）的处理程序，该处理程序使其停止当前正在做的事情并将控制权返回给主输入循环，从而再次向用户显示shell 提示符（用户按下 <code>Control-C</code>-shell中断当前处理-用户可以再次在shell中输入指令了）。通知内核应调用某个处理函数通常被称为<strong>安装</strong>（installing）或<strong>建立</strong>（establishing）一个信号处理程序。当信号处理程序因信号递送而被调用时，我们说信号已被<strong>处理</strong>（handled）或，同义词，被<strong>捕获</strong>（caught）。<em>注意：不可能将信号的处置方式设置为终止或转储核心（除非其中一个是该信号的默认处置方式）。最接近这一点的是为该信号安装一个处理程序，然后该处理程序调用<code>exit()</code> 或 <code>abort()</code>。<code>abort()</code>函数（第21.2.2节）为进程生成一个 <code>SIGABRT</code>信号，这会导致其转储核心并终止。</em></li></ul><p>Linux特有的 <code>/proc/PID/status</code>文件包含各种位掩码字段，可以检查这些字段以确定进程对信号的处理情况。位掩码以十六进制数显示，最低有效位代表信号1，左边下一位代表信号2，依此类推。这些字段是：* <code>SigPnd</code>（线程内等待信号，per-thread pending signals） *<code>ShdPnd</code>（进程范围内等待信号，process-wide pendingsignals；自Linux 2.6起） * <code>SigBlk</code>（阻塞信号，blockedsignals） * <code>SigIgn</code>（忽略信号，ignored signals） *<code>SigCgt</code>（捕获信号，caught signals）。（当我们第33.2节描述多线程进程中的信号处理时，<code>SigPnd</code> 和<code>ShdPnd</code> 字段之间的区别将变得清晰。）同样的信息也可以使用<code>ps(1)</code> 命令的各种选项来获取。</p><h3 id="fork-exit-wait-和-execve-概述"><code>fork()</code>,<code>exit()</code>, <code>wait()</code> 和 <code>execve()</code>概述</h3><ul><li><p><strong><code>fork()</code></strong> <code>fork()</code>系统调用允许一个进程（称为<strong>父进程</strong>）创建一个新的进程（称为<strong>子进程</strong>）。这是通过使新的子进程成为父进程的（近乎）完全副本来实现的：子进程获取父进程栈、数据、堆和文本段（第6.3节）的副本。“Fork”一词源于我们可以将父进程视为<strong>分裂(forking)</strong> 以产生自身的两个副本这一构想。</p></li><li><p><strong><code>exit(status)</code></strong> <code>exit()</code>库函数<strong>终止</strong>一个进程，使该进程使用的所有资源（内存、打开的文件描述符等）可供内核后续重新分配。<code>status</code>参数是一个整数，用于确定进程的<strong>终止状态</strong>。通过<code>wait()</code> 系统调用，父进程可以检索此状态。 <code>exit()</code>库函数是基于 <code>_exit()</code>系统调用构建的。在第25章，我们将解释这两个接口之间的区别。在此我们只需注意，在<code>fork()</code>之后，通常只有父进程和子进程中的<strong>一个</strong>通过调用<code>exit()</code> 终止；<strong>另一个</strong>进程应使用<code>_exit()</code> 终止。</p></li><li><p><strong><code>wait(&amp;status)</code></strong><code>wait(&amp;status)</code>系统调用有两个目的。首先，如果该进程的某个子进程尚未调用<code>exit()</code> 终止，那么 <code>wait()</code>会<strong>暂停</strong>该进程的执行，直到它的一个子进程终止为止。其次，子进程的终止状态通过<code>wait()</code> 的 <code>status</code>参数<strong>返回</strong>。</p></li><li><p><strong><code>execve(pathname, argv, envp)</code></strong><code>execve(pathname, argv, envp)</code>系统调用将一个新的程序（<code>pathname</code>，带有参数列表<code>argv</code> 和环境列表<code>envp</code>）<strong>加载</strong>到一个进程的内存中。现有的程序文本被丢弃，并为新程序<strong>全新创建</strong>栈、数据和堆段。此操作通常被称为<strong>execing</strong> 一个新程序。后面我们会看到，有几个库函数是基于<code>execve()</code>构建的，每个函数都在编程接口上提供了有用的变体。当我们不关心这些接口变体时，我们遵循通用惯例，将这些调用统称为<code>exec()</code>，但请注意，并没有叫这个名字的系统调用或库函数。</p></li></ul><p><strong>与其他系统的对比：</strong> 一些其他操作系统将<code>fork()</code> 和 <code>exec()</code>的功能组合到单个操作中——即所谓的<strong>spawn</strong>——该操作创建一个新进程然后执行指定的程序。相比之下，UNIX的方法通常更简单、更优雅。将这两个步骤分开使得 API更简单（<code>fork()</code>系统调用不需要参数），并且允许程序在两个步骤之间执行的操作具有极大的灵活性。此外，只进行<code>fork()</code> 而不接着执行 <code>exec()</code> 通常也很有用。</p><p>SUSv3 规定了可选的 <code>posix_spawn()</code> 函数，它结合了<code>fork()</code> 和 <code>exec()</code> 的效果。此函数以及 SUSv3规定的几个相关 API 已在 glibc 中为 Linux 实现。SUSv3 规定<code>posix_spawn()</code>是为了允许为那些不提供交换设施或内存管理单元（这在许多嵌入式系统中很典型）的硬件架构编写可移植应用程序。在此类架构上，传统的<code>fork()</code> 难以或无法实现。</p><p><strong>协同工作概述：</strong> <code>fork()</code>,<code>exit()</code>, <code>wait()</code>, 和 <code>execve()</code>通常是如何一起使用的。（shell持续执行一个循环，该循环读取命令、对其进行各种处理，然后 fork一个子进程来 exec 该命令。）</p><h3 id="创建新进程fork">创建新进程：<code>fork()</code></h3><p><code>fork()</code>系统调用创建一个新的进程，即<strong>子进程</strong>，它是调用进程，即<strong>父进程</strong>的一个几乎完全相同的副本。</p><p>理解 <code>fork()</code>的关键在于认识到，在它完成工作后，存在<strong>两个进程</strong>，并且在每个进程中，执行都从<code>fork()</code><strong>返回的地方继续</strong>。两个进程执行相同的程序代码，但它们拥有独立的栈、数据和堆段副本。子进程的栈、数据和堆段最初是父进程内存相应部分的精确副本。在<code>fork()</code>之后，每个进程都可以修改其栈、数据和堆段中的变量，而<strong>不会影响另一个进程</strong>。</p><p>在程序代码中，我们可以通过 <code>fork()</code>的返回值来区分这两个进程：</p><ul><li>对于<strong>父进程</strong>，<code>fork()</code>返回新创建子进程的<strong>进程ID(PID)</strong>。这很有用，因为父进程可能会创建多个子进程，并因此需要（通过<code>wait()</code> 或其相关函数）跟踪它们。</li><li>对于<strong>子进程</strong>，<code>fork()</code> 返回<strong>0</strong>。</li><li>如果无法创建新进程，<code>fork()</code> 返回<strong>-1</strong>。失败的可能原因包括：已达到允许该（真实）用户ID创建的进程数的资源限制（<code>RLIMIT_NPROC</code>，在第36.3节描述），或者已达到系统范围内可创建进程数的上限。</li></ul><p>必要时，子进程可以使用 <code>getpid()</code> 获取自身的进程ID，使用<code>getppid()</code> 获取其父进程的进程ID。</p><p>调用 <code>fork()</code> 时有时会使用以下惯用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> childPid; <span class="comment">/* 在父进程中用于记录成功 fork() 后的子进程 PID */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (childPid = fork()) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">/* fork() 失败 */</span></span><br><span class="line">    <span class="comment">/* 处理错误 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">/* 成功 fork() 后的子进程进入此处 */</span></span><br><span class="line">    <span class="comment">/* 执行子进程特定的操作 */</span></span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 或 exit()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">/* 成功 fork() 后的父进程进入此处 */</span></span><br><span class="line">    <span class="comment">/* 执行父进程特定的操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重要的是要认识到，在 <code>fork()</code>之后，<strong>无法确定接下来是哪个进程被调度使用CPU</strong>。在编写不佳的程序中，这种不确定性可能导致称为<strong>竞争条件(race conditions)</strong> 的错误，我们将在第24.4节进一步描述。</p><p>代码清单24-1演示了 <code>fork()</code>的用法。该程序创建一个子进程，修改它在 <code>fork()</code>期间继承的全局变量和自动变量的副本。在程序中（由父进程执行的代码中）使用<code>sleep()</code>，是为了让子进程能在父进程之前被调度到CPU上，从而使子进程可以在父进程继续执行之前完成其工作并终止。使用<code>sleep()</code>这种方式并<strong>不是</strong>保证此结果的万无一失的方法；我们将在第24.5节探讨一种更好的方法。<strong>代码清单 24-1: 使用 fork()</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> idata = <span class="number">111</span>;             <span class="comment">/* 分配在数据段 (data segment) */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> istack = <span class="number">222</span>;               <span class="comment">/* 分配在栈段 (stack segment) */</span></span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (childPid = fork()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:                         <span class="comment">/* 子进程分支 */</span></span><br><span class="line">        idata *= <span class="number">3</span>;                 <span class="comment">/* 修改继承的变量副本 */</span></span><br><span class="line">        istack *= <span class="number">3</span>;                <span class="comment">/* 修改继承的变量副本 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:                        <span class="comment">/* 父进程分支 */</span></span><br><span class="line">        sleep(<span class="number">3</span>);                   <span class="comment">/* 给子进程一个执行的机会 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程和子进程都会执行到这里 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID=%ld %s idata=%d istack=%d\n&quot;</span>, (<span class="type">long</span>) getpid(),</span><br><span class="line">            (childPid == <span class="number">0</span>) ? <span class="string">&quot;(child) &quot;</span> : <span class="string">&quot;(parent)&quot;</span>, idata, istack);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>当我们运行清单24-1中的程序时，会看到以下输出： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./t_fork</span><br><span class="line">PID=28557 (child)  idata=333 istack=666</span><br><span class="line">PID=28556 (parent) idata=111 istack=222</span><br></pre></td></tr></table></figure>上面的输出证明，子进程在 <code>fork()</code>时获得了栈段和数据段的<strong>自有副本</strong>，并且它能够修改这些段中的变量而<strong>不影响父进程</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;信号的概念&quot;&gt;信号的概念&lt;/h3&gt;
&lt;p&gt;信号（Signal）是通知进程已发生某种事件的一种机制。信号有时被描述为&lt;strong&gt;软件中断&lt;/strong&gt;（software
interrupts）。信号与硬件中断类似，因为它们会中断程序的正常执行流程；在大多</summary>
      
    
    
    
    <category term="os basic" scheme="https://mackz-maxw.github.io/categories/os-basic/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统基础 | 5.2 进程管理详解</title>
    <link href="https://mackz-maxw.github.io/2025/08/23/oper_sys23processMgmt2/"/>
    <id>https://mackz-maxw.github.io/2025/08/23/oper_sys23processMgmt2/</id>
    <published>2025-08-23T15:49:20.949Z</published>
    <updated>2025-08-27T02:13:53.407Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程创建-process-creation"><strong>进程创建 (ProcessCreation)</strong></h3><p>Unix 中的进程创建方式是独特的。大多数操作系统实现一种 <strong>spawn机制</strong>来在新地址空间中创建新进程、读入可执行文件并开始执行。Unix则采用了一种不寻常的方法，将这些步骤分离成两个不同的函数：<code>fork()</code>和 <code>exec()</code>⁷。第一个函数 <code>fork()</code>创建一个作为当前任务副本的<strong>子进程</strong>。它与父进程的区别仅在于其PID（是唯一的）、其 PPID（父进程的 PID，被设置为原始进程的PID）以及某些资源和统计信息（如待处理的信号，这些不被继承）。第二个函数<code>exec()</code>将一个新的可执行文件加载到地址空间中并开始执行。<code>fork()</code> 后接<code>exec()</code> 这种组合，类似于大多数操作系统提供的单一函数。</p><p>⁷ 这里的 <code>exec()</code> 指的是 <code>exec()</code>函数家族中的任何成员。内核实现了 <code>execve()</code>系统调用，基于此实现了 <code>execlp()</code>, <code>execle()</code>,<code>execv()</code>, 和 <code>execvp()</code>。</p><h4 id="写时复制-copy-on-write"><strong>写时复制(Copy-on-Write)</strong></h4><p>传统上，在 <code>fork()</code>时，父进程拥有的所有资源都会被复制，并将副本交给子进程。这种方法很朴素且低效，因为它复制了许多本可以共享的数据。更糟糕的是，如果新进程要立即执行一个新的映像（image），所有这些复制都将被浪费。在Linux 中，<code>fork()</code> 是通过使用<strong>写时复制 (Copy-on-Write或 COW)</strong>页来实现的。写时复制是一种延迟或完全防止数据复制的技术。父进程和子进程可以共享一份单一的副本，而不是复制整个进程地址空间。</p><p>然而，数据会被标记，如果对其进行写入，就会创建一个副本，每个进程都会收到一个独一无二的副本。因此，资源的复制<strong>仅发生在它们被写入时</strong>；在此之前，它们以只读方式共享。这种技术将地址空间中每一页的复制延迟到实际被写入的时候。如果这些页永远不被写入——例如，如果在<code>fork()</code> 之后立即调用<code>exec()</code>——它们就永远不需要被复制。</p><p><code>fork()</code> 产生的唯一开销是复制父进程的<strong>页表 (pagetables)</strong>以及为子进程创建一个唯一的进程描述符。在常见的场景中（进程在 fork后立即执行一个新的可执行映像），这种优化避免了大量数据（整个地址空间，很容易达到几十兆字节）的浪费性复制。这是一个重要的优化，因为Unix 哲学鼓励快速的进程执行。</p><h4 id="forking"><strong>Forking</strong></h4><p>Linux 通过 <code>clone()</code> 系统调用来实现<code>fork()</code>。这个调用接受一系列标志（flags），用以指定父进程和子进程应共享哪些资源（如果有的话）。（关于这些标志的更多信息，请参阅本章后面的“Linux的线程实现”一节。）<code>fork()</code>, <code>vfork()</code>, 和<code>__clone()</code> 库调用都使用必要的标志来调用 <code>clone()</code>系统调用。而 <code>clone()</code> 系统调用又会调用<code>do_fork()</code>。</p><p>forking 的大部分工作由 <code>do_fork()</code> 处理，该函数定义在<code>kernel/fork.c</code> 中。此函数调用<code>copy_process()</code>，然后启动进程运行。有趣的工作是由<code>copy_process()</code> 完成的：</p><ol type="1"><li>它调用<code>dup_task_struct()</code>，该函数为新进程创建一个新的内核栈、<code>thread_info</code>结构和<code>task_struct</code>。新的值与当前任务的值完全相同。此时，子进程和父进程的描述符是完全相同的。</li><li>然后检查确保新的子进程不会超过当前用户所能拥有的进程数量资源限制。</li><li>子进程需要与父进程区分开来。进程描述符的各种成员被清除或设置为初始值。不被继承的进程描述符成员主要是统计信息。<code>task_struct</code>中的大部分值保持不变。</li><li>子进程的状态被设置为 <code>TASK_UNINTERRUPTIBLE</code>以确保它还不会运行。</li><li><code>copy_process()</code> 调用 <code>copy_flags()</code> 来更新<code>task_struct</code> 的 <code>flags</code>成员。<code>PF_SUPERPRIV</code>标志（表示任务是否使用了超级用户权限）被清除。<code>PF_FORKNOEXEC</code>标志（表示进程尚未调用 <code>exec()</code>）被设置。</li><li>它调用 <code>alloc_pid()</code> 为新任务分配一个可用的 PID。</li><li>根据传递给 <code>clone()</code> 的标志，<code>copy_process()</code>要么复制要么共享打开的文件、文件系统信息、信号处理程序、进程地址空间和命名空间。这些资源通常在给定进程的线程之间共享；否则，它们是唯一的，因此在这里被复制。</li><li>最后，<code>copy_process()</code>进行清理工作，并向调用者返回一个指向新子进程的指针。</li></ol><p>回到 <code>do_fork()</code>，如果 <code>copy_process()</code>成功返回，新的子进程会被唤醒并运行。内核有意地让<strong>子进程先运行</strong>⁸。在子进程通常只是立即调用<code>exec()</code>的常见情况下，这消除了如果父进程先运行并开始写入地址空间可能发生的任何写时复制开销。</p><blockquote><p>⁸虽然目标是让子进程先运行，但这目前（指原书写作时）并不能正确运行。</p></blockquote><h4 id="vfork"><strong>vfork()</strong></h4><p><code>vfork()</code> 系统调用与 <code>fork()</code>效果相同，但<strong>不会复制父进程的页表项 (page tableentries)</strong>。相反，子进程作为父进程地址空间中的唯一线程执行，并且<strong>父进程被阻塞</strong>，直到子进程调用<code>exec()</code>或退出。不允许子进程写入地址空间。在引入这个调用的旧版 3BSD时代，这是一个受欢迎的优化，因为当时还没有使用写时复制页来实现<code>fork()</code>。如今，有了写时复制和子进程优先运行的语义，<code>vfork()</code>的唯一好处就是<strong>不复制父进程的页表项</strong>。</p><p>如果 Linux 有一天实现了写时复制页表项，那么 <code>vfork()</code>将不再有任何好处⁹。由于 <code>vfork()</code> 的语义很棘手（例如，如果<code>exec()</code> 失败了会发生什么？），理想情况下系统不需要<code>vfork()</code>，内核也不必实现它。完全可以将 <code>vfork()</code>实现为一个普通的 <code>fork()</code> —— 这就是 Linux 在 2.2版本之前所做的。</p><p><code>vfork()</code> 系统调用是通过向 <code>clone()</code>系统调用传递一个特殊标志来实现的：</p><ol type="1"><li>在 <code>copy_process()</code> 中，<code>task_struct</code> 的成员<code>vfork_done</code> 被设置为 <code>NULL</code>。</li><li>在 <code>do_fork()</code>中，如果给定了特殊标志，<code>vfork_done</code>会被指向一个特定的地址。</li><li>子首次运行后，父进程——不会立即返回——而是等待子进程通过<code>vfork_done</code> 指针向其发出信号。</li><li>在 <code>mm_release()</code>函数中（该函数在任务退出内存地址空间时使用），会检查<code>vfork_done</code> 是否为<code>NULL</code>。如果不是，则向父进程发送信号。</li><li>回到 <code>do_fork()</code>，父进程被唤醒并返回。</li></ol><p>如果这一切都按计划进行，那么子进程现在在新的地址空间中执行，而父进程则在其原始地址空间中恢复执行。开销是降低了，但实现并不优雅。</p><blockquote><p>⁹ 页表写时复制可作为补丁，已大概率加入主流内核</p></blockquote><h3id="linux-的线程实现-the-linux-implementation-of-threads"><strong>Linux的线程实现 (The Linux Implementation of Threads)</strong></h3><p>线程是一种流行的现代编程抽象。它们在同一程序的共享内存地址空间内提供多个执行线程。它们还可以共享打开的文件和其他资源。线程实现了并发编程，并且在多处理器系统上实现了真正的并行。</p><p>Linux 拥有一个独特的线程实现。<strong>对 Linux内核而言，没有“线程”的概念</strong>。Linux将所有线程实现为标准进程。Linux内核并不提供任何特殊的调度语义或数据结构来表示线程。相反，一个线程仅仅是一个与其他进程共享某些资源的进程。每个线程都有一个唯一的<code>task_struct</code>，并且在内核看来就是一个普通的进程——线程只是恰巧与其他进程共享了资源（例如地址空间）。</p><p>这种线程实现方法与 Microsoft Windows 或 Sun Solaris等操作系统形成了巨大对比，这些操作系统在内核中提供了对线程的明确支持（有时称线程为<strong>轻量级进程(Lightweight Processes)</strong>）。“轻量级进程”这个名字概括了 Linux与其他系统在哲学上的差异。对这些其他操作系统而言，线程是一种抽象，旨在提供比笨重进程更轻量、更快速的执行单元。而对Linux而言，线程仅仅是进程之间共享资源的一种方式（而进程本身已经相当轻量）¹⁰。</p><p>例如，假设一个包含四个线程的进程。在具有显式线程支持的系统中，可能会存在一个进程描述符，该描述符又指向四个不同的线程。进程描述符描述共享资源，如地址空间或打开的文件。线程则描述它们独自拥有的资源。相反，在Linux 中，简单地存在四个进程，因而有四个普通的 <code>task_struct</code>结构。这四个进程被设置为共享某些资源。结果非常优雅。</p><blockquote><p>¹⁰ 例如，可以对比 benchmark 一下 Linux的进程创建时间与其他操作系统的进程（甚至线程！）创建时间。结果对 Linux有利。</p></blockquote><h4 id="创建线程-creating-threads"><strong>创建线程 (CreatingThreads)</strong></h4><p>线程的创建方式与普通任务相同，区别在于需要向 <code>clone()</code>系统调用传递一些标志（flags），这些标志指定了要共享的特定资源：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure> 上述代码产生的行为与普通的 <code>fork()</code>相同，但<strong>地址空间、文件系统资源、文件描述符和信号处理程序是共享的</strong>。换句话说，新任务和其父进程就是通常所说的线程。相比之下，一个普通的<code>fork()</code> 可以实现为： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(SIGCHLD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure> 而 <code>vfork()</code>可以实现为： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VFORK | CLONE_VM | SIGCHLD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure> 提供给 <code>clone()</code>的标志有助于指定新进程的行为，并详细说明父进程和子进程将共享哪些资源。表3.1 列出了在 <code>&lt;linux/sched.h&gt;</code> 中定义的 clone标志及其作用。</p><p><strong>(表 3.1 Clone 标志及含义)</strong> | 标志 (Flag) | 含义(Meaning) | | :----------------------- |:-----------------------------------------------------------------------------| | <code>CLONE_FILES</code> | 父子进程共享打开的文件。 | |<code>CLONE_FS</code> |父子进程共享文件系统信息（如根目录、当前工作目录）。 | |<code>CLONE_IDLETASK</code> | 将 PID 设置为零（仅由空闲任务使用）。 | |<code>CLONE_NEWNS</code> | 为子进程创建新的命名空间 (namespace)。 | |<code>CLONE_PARENT</code> |子进程与父进程拥有相同的父进程（即调用者的父进程）。 | |<code>CLONE_PTRACE</code> | 继续跟踪子进程。 | |<code>CLONE_SETTID</code> | 将 TID（线程 ID）写回用户空间。 | |<code>CLONE_SETTLS</code> | 为子进程创建新的 TLS（线程本地存储）。 | |<code>CLONE_SIGHAND</code> | 父子进程共享信号处理程序和阻塞的信号掩码。| | <code>CLONE_SYSVSEM</code> | 父子进程共享 System V SEM_UNDO 语义。 || <code>CLONE_THREAD</code> |父子进程位于同一个线程组中。这是将新进程标识为线程而非普通进程的关键标志。| | <code>CLONE_VFORK</code> | 使用了<code>vfork()</code>，父进程将睡眠直到子进程唤醒它。 | |<code>CLONE_UNTRACED</code> | 不允许跟踪进程强制对子进程使用<code>CLONE_PTRACE</code>。 | | <code>CLONE_STOP</code> | 以<code>TASK_STOPPED</code> 状态启动进程。 | |<code>CLONE_CHILD_CLEARTID</code> | 在子进程中清除 TID。 | |<code>CLONE_CHILD_SETTID</code> | 在子进程中设置 TID。 | |<code>CLONE_PARENT_SETTID</code> | 在父进程中设置 TID。 | |<code>CLONE_VM</code> |父子进程共享地址空间。这是创建线程的关键标志之一。 |</p><h4 id="内核线程-kernel-threads"><strong>内核线程 (KernelThreads)</strong></h4><p>内核在后台执行某些操作通常很有用。内核通过<strong>内核线程 (kernelthreads)</strong>来实现这一点——内核线程是<strong>仅存在于内核空间的标准进程</strong>。内核线程与普通进程的显著区别在于内核线程<strong>没有地址空间</strong>（它们的<code>mm</code> 指针指向它们的地址空间，为<code>NULL</code>）。它们只在内核空间中运行，不会上下文切换到用户空间。然而，内核线程与普通进程一样，是可调度和可抢占的。</p><p>Linux 将一些任务委托给内核线程，最著名的是 <code>flush</code> 任务和<code>ksoftirqd</code> 任务。您可以在 Linux 系统上运行<code>ps -ef</code> 命令来查看内核线程。数量很多！</p><blockquote><p>-ef 是 every full(info) 的简写。在所有进程中，CMD 带 []，TTY 为?，PPID 为 2 或 0， UID是0或者root，是内核线程的特征</p></blockquote><p>内核线程在系统启动时由其他内核线程创建。实际上，内核线程只能由另一个内核线程创建。内核通过从<code>kthreadd</code> 内核进程 <strong>fork</strong>出所有新的内核线程来自动处理此事。在<code>&lt;linux/kthread.h&gt;</code>中声明的，用于从现有内核线程生成新内核线程的接口是： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">kthread_create</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params">                                   <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                                   <span class="type">const</span> <span class="type">char</span> namefmt[], ...)</span>;</span><br></pre></td></tr></table></figure>新任务由 kthread 内核进程通过 <code>clone()</code>系统调用创建。新进程将运行 <code>threadfn</code> 函数，该函数接收<code>data</code> 参数。进程将被命名为<code>namefmt</code>，该参数接受在可变参数列表中的 printf风格格式化参数。进程创建时处于<strong>不可运行状态 (unrunnablestate)</strong>；只有在通过 <code>wake_up_process()</code>显式唤醒后，它才会开始运行。可以使用单个函数 <code>kthread_run()</code>来创建并使进程可运行： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">kthread_run</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params">                                <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">char</span> namefmt[], ...)</span>;</span><br></pre></td></tr></table></figure> 这个例程（作为宏实现）简单地调用了<code>kthread_create()</code> 和 <code>wake_up_process()</code>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kthread_run(threadfn, data, namefmt, ...)                     \</span></span><br><span class="line"><span class="meta">(&#123;                                                                    \</span></span><br><span class="line"><span class="meta">    struct task_struct *k;                                        \</span></span><br><span class="line"><span class="meta">                                                                      \</span></span><br><span class="line"><span class="meta">    k = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__);  \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!IS_ERR(k))                                               \</span></span><br><span class="line"><span class="meta">        wake_up_process(k);                                   \</span></span><br><span class="line"><span class="meta">    k;                                                            \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure> 启动后，内核线程会继续存在，直到它调用<code>do_exit()</code>，或者内核的另一部分调用<code>kthread_stop()</code>（传入由 <code>kthread_create()</code> 返回的<code>task_struct</code> 结构体的地址）： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kthread_stop</span><span class="params">(<span class="keyword">struct</span> task_struct *k)</span>;</span><br></pre></td></tr></table></figure></p><h3 id="进程终止-process-termination"><strong>进程终止 (ProcessTermination)</strong></h3><p>这很遗憾，但进程最终都会消亡。当一个进程终止时，内核会释放该进程所拥有的资源，并通知其父进程关于子进程消亡的消息。</p><p>通常，进程销毁是<strong>自我诱导 (self-induced)</strong>的。当进程调用 <code>exit()</code>系统调用时就会发生，这可以是在它准备终止时显式调用，也可以是在从任何程序的main 子程序返回时隐式调用（即 C 编译器会在 <code>main()</code>返回后放置一个对 <code>exit()</code>的调用）。进程也可能<strong>非自愿地 (involuntarily)</strong>终止。这发生在进程收到一个它无法处理或忽略的信号或异常时。</p><p>无论进程如何终止，大部分工作都由 <code>do_exit()</code> 处理（定义在<code>kernel/exit.c</code> 中），它完成一系列收尾工作：</p><ol type="1"><li>它在 <code>task_struct</code> 的 <code>flags</code> 成员中设置<code>PF_EXITING</code> 标志。</li><li>它调用 <code>del_timer_sync()</code>来移除任何内核定时器。确保返回时没有定时器在排队，也没有定时器处理程序在运行。</li><li>如果启用了 BSD 进程记账 (process accounting)，<code>do_exit()</code>会调用 <code>acct_update_integrals()</code> 来写出记账信息。</li><li>它调用 <code>exit_mm()</code> 来释放该进程持有的<code>mm_struct</code>。如果没有其他进程在使用这个地址空间（即地址空间未被共享），内核就会销毁它。</li><li>它调用 <code>exit_sem()</code>。如果进程正在排队等待一个 IPC信号量，它在这里被移出队列。</li><li>然后它调用 <code>exit_files()</code> 和 <code>exit_fs()</code>来分别递减与文件描述符和文件系统数据相关的对象的引用计数。如果某个引用计数降为零，说明该对象不再被任何进程使用，随即被销毁。</li><li>它将任务的退出码（存储在 <code>task_struct</code> 的<code>exit_code</code> 成员中）设置为 <code>exit()</code>提供的代码或任何强制终止它的内核机制所提供的代码。退出码存储在这里，供父进程选择性检索。</li><li>它调用 <code>exit_notify()</code>来向任务的父进程发送信号，将该任务的任何子进程<strong>重新设定父进程(reparent)</strong> 给其线程组中的另一个线程或 init进程，并将任务的退出状态（存储在 <code>task_struct</code> 结构的<code>exit_state</code> 中）设置为 <code>EXIT_ZOMBIE</code>。</li><li><code>do_exit()</code> 调用 <code>schedule()</code>来切换到新进程（参见第 4章）。因为该进程现在已不可调度，这是该任务将执行的最后代码。<code>do_exit()</code>永不返回。</li></ol><p>至此，与任务关联的所有对象（假设该任务是唯一使用者）都已释放。该任务不可运行（并且不再有地址空间可供运行），并处于<code>EXIT_ZOMBIE</code>（僵尸）退出状态。它占用的唯一内存是它的内核栈、<code>thread_info</code>结构和 <code>task_struct</code>结构。该任务存在的唯一目的是向其父进程提供信息。在父进程检索到信息，或通知内核它不感兴趣之后，进程持有的剩余内存将被释放并返回给系统使用。</p><h4id="移除进程描述符-removing-the-process-descriptor"><strong>移除进程描述符(Removing the Process Descriptor)</strong></h4><p>在 <code>do_exit()</code>完成后，已终止进程的进程描述符仍然存在，但该进程已成为僵尸 (zombie)且无法运行。如前所述，这使得系统能够在子进程终止后获取其信息。因此，清理进程之后和移除其进程描述符是分开的两个步骤。在父进程获取了已终止子进程的信息，或向内核表示不关心之后，子进程的<code>task_struct</code> 才会被释放。</p><p><code>wait()</code> 函数族是通过一个单一（且复杂）的系统调用<code>wait4()</code>实现的。标准行为是<strong>挂起调用任务的执行</strong>，直到它的一个子进程退出，此时函数返回退出子进程的PID。此外，还提供一个指针给该函数，该指针在返回时持有已终止子进程的退出码。</p><p>当最终要释放进程描述符时，会调用<code>release_task()</code>。它执行以下操作： 1. 它调用<code>__exit_signal()</code>，后者又调用<code>__unhash_process()</code>，继而调用 <code>detach_pid()</code>来将进程从 pidhash 中移除，并从任务列表中移除该进程。 2.<code>__exit_signal()</code>释放这个已死亡进程使用的任何剩余资源，并完成统计和簿记工作。 3.如果该任务是线程组的最后一个成员，并且领导者 (leader) 是僵尸进程，那么<code>release_task()</code> 会通知僵尸领导者的父进程。 4.<code>release_task()</code> 调用 <code>put_task_struct()</code>来释放包含进程内核栈和 <code>thread_info</code> 结构的内存页，并释放包含<code>task_struct</code> 的 slab 缓存。</p><p>至此，进程描述符以及仅属于该进程的所有资源都已被释放。</p><h4id="无父任务的困境-the-dilemma-of-the-parentless-task"><strong>无父任务的困境(The Dilemma of the Parentless Task)</strong></h4><p>如果一个父进程在其子进程之前退出，必须存在某种机制来将任何子任务<strong>重新设定父进程(reparent)</strong>给一个新进程，否则，没有父进程的已终止进程将永远保持僵尸状态，浪费系统内存。解决方案是在退出时将一个任务的子进程重新设定父进程给当前线程组中的另一个进程，如果失败，则设定给init 进程。<code>do_exit()</code> 调用<code>exit_notify()</code>，后者调用<code>forget_original_parent()</code>，该函数又调用<code>find_new_reaper()</code> 来执行重新设定父进程的操作：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_struct *<span class="title function_">find_new_reaper</span><span class="params">(<span class="keyword">struct</span> task_struct *father)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns</span> =</span> task_active_pid_ns(father);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    thread = father;</span><br><span class="line">    while_each_thread(father, thread) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread-&gt;flags &amp; PF_EXITING)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(pid_ns-&gt;child_reaper == father))</span><br><span class="line">            pid_ns-&gt;child_reaper = thread;</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> pid_ns-&gt;child_reaper; <span class="comment">// 通常是 init 进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（代码已简化，核心逻辑是查找同一线程组内未退出的线程，或最终返回 init进程）</p><p>这段代码尝试在进程的线程组中查找并返回另一个任务。如果线程组中没有其他任务，它就查找并返回init进程。找到合适的新父进程后，需要找到每个子进程并将其重新设定父进程给这个新的“收割者”(reaper)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reaper = find_new_reaper(father);</span><br><span class="line">list_for_each_entry_safe(p, n, &amp;father-&gt;children, sibling) &#123;</span><br><span class="line">    p-&gt;real_parent = reaper;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;parent == father) &#123;</span><br><span class="line">        BUG_ON(p-&gt;ptrace);</span><br><span class="line">        p-&gt;parent = p-&gt;real_parent;</span><br><span class="line">    &#125;</span><br><span class="line">    reparent_thread(p, father);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用 <code>ptrace_exit_finish()</code>做同样的事情，但是针对一个被 ptrace 跟踪 (ptraced) 的子进程列表。</p><p>同时拥有一个子进程列表 (child list) 和一个被跟踪子进程列表 (ptracedlist) 的基本原理很有趣；这是 2.6 内核的一个新特性。当一个任务被<code>ptrace</code>跟踪时，它被临时重新设定父进程给调试进程。然而，当该任务的原始父进程退出时，它必须与其兄弟姐妹一起被重新设定父进程。在之前的内核中，这会导致需要循环遍历系统中的每个进程来查找子进程。解决方案就是简单地维护一个进程被<code>ptrace</code>跟踪的子进程的独立列表——将查找子进程的范围从系统中的每个进程缩小到仅仅两个相对较小的列表。</p><p>随着进程成功被重新设定父进程，就不再存在 stray zombie processes（stray zombie processes）的风险。init 进程会例行地对其子进程调用<code>wait()</code>，清理分配给它的任何僵尸进程。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;进程创建-process-creation&quot;&gt;&lt;strong&gt;进程创建 (Process
Creation)&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Unix 中的进程创建方式是独特的。大多数操作系统实现一种 &lt;strong&gt;spawn
机制&lt;/strong&gt;来在</summary>
      
    
    
    
    <category term="os basic" scheme="https://mackz-maxw.github.io/categories/os-basic/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统基础 | 5.1 进程管理简介</title>
    <link href="https://mackz-maxw.github.io/2025/08/20/oper_sys22processMgmt/"/>
    <id>https://mackz-maxw.github.io/2025/08/20/oper_sys22processMgmt/</id>
    <published>2025-08-20T16:55:36.174Z</published>
    <updated>2025-08-28T01:19:55.838Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程"><strong>进程</strong></h3><p>一个进程是一个正在执行中的程序（存储在某种介质上的目标代码）。然而，进程不仅仅只是执行的程序代码（在Unix中常称为文本段）。它们还包括一系列资源，例如打开的文件和待处理的信号、内核内部数据、处理器状态、包含一个或多个内存映射的内存地址空间、一个或多个执行线程，以及包含全局变量的数据段。实际上，进程是运行程序代码的动态产物。内核需要高效且透明地管理所有这些细节。</p><p>执行线程（通常简称为线程）是进程内部的活动对象。每个线程包含一个唯一的程序计数器、进程栈和一组处理器寄存器。内核调度的是单个线程，而不是进程。在传统的Unix系统中，每个进程由一个线程组成。然而，在现代系统中，由多个线程组成的多线程程序非常普遍。正如您后面将看到的，Linux对线程的实现很独特：它并不区分线程和进程。对 Linux而言，线程只是一种特殊的进程。</p><p>在现代操作系统上，进程提供了两种虚拟化：虚拟化处理器和虚拟内存。虚拟化处理器给进程一种假象，让它以为自己在独享系统，尽管处理器可能正与数百个其他进程共享。虚拟内存让进程可以分配和管理内存，就好像它独占了系统中的所有内存一样。</p><p>有趣的是，请注意线程共享虚拟内存抽象，而每个线程则拥有自己的虚拟化处理器。</p><p>程序本身并不是一个进程；进程是活动中的程序及其相关资源。实际上，可以存在两个或更多个执行同一程序的进程。事实上，也可以存在两个或更多共享各种资源（如打开的文件或地址空间）的进程。</p><p>毫不奇怪，进程在其创建时开始它的生命周期。在 Linux 中，这是通过<code>fork()</code>系统调用来完成的，该系统调用通过复制一个现有进程来创建一个新进程。调用<code>fork()</code>的进程是父进程，而新进程是子进程。父进程恢复执行，而子进程则在相同的地方开始执行：即从<code>fork()</code> 调用返回的地方。<code>fork()</code>系统调用从内核返回两次：一次在父进程中，一次在新生的子进程中。</p><p>通常，在 <code>fork()</code>之后立即需要执行一个新的、不同的程序。<code>exec()</code>系列函数调用会创建一个新的地址空间并将一个新的程序加载到其中。在当代的Linux 内核中，<code>fork()</code> 实际上是通过 <code>clone()</code>系统调用实现的，这将在后面讨论。</p><p>最后，程序通过 <code>exit()</code>系统调用退出。此函数终止进程并释放其所有资源。父进程可以通过<code>wait4()</code>¹系统调用查询已终止子进程的状态，该系统调用使一个进程能够等待特定进程的终止。当一个进程退出时，它会被置于一种特殊的<strong>僵尸(zombie)</strong> 状态，该状态表示已终止的进程，直到父进程调用<code>wait()</code> 或 <code>waitpid()</code>。</p><blockquote><p>¹ 内核实现了 <code>wait4()</code> 系统调用。Linux 系统通过 C库通常提供 <code>wait()</code>, <code>waitpid()</code>,<code>wait3()</code>, 和 <code>wait4()</code>函数。所有这些函数都返回关于已终止进程的状态信息，尽管语义略有不同。</p></blockquote><p><strong>注意</strong> 进程的另一个名称是<strong>任务(task)</strong>。Linux内核在内部将进程称为任务。在本书中，我会交替使用这两个术语，尽管当我说“任务”时，通常是从内核的角度来指代一个进程。</p><hr /><h3id="进程描述符和任务结构-task-structure"><strong>进程描述符和任务结构(Task Structure)</strong></h3><p>内核在一个称为<strong>任务列表 (task list)</strong>²的环形双向链表中存储进程列表。任务列表中的每个元素都是一个类型为<code>struct task_struct</code> 的进程描述符，该结构定义在<code>&lt;linux/sched.h&gt;</code>中。进程描述符包含了一个特定进程的所有信息。</p><p><code>task_struct</code> 是一个相对较大的数据结构，在 32 位机器上约为1.7千字节。然而，考虑到该结构包含了内核所拥有和需要的关于一个进程的所有信息，这个大小已经相当小了。进程描述符包含了描述正在执行的程序的数据——打开的文件、进程的地址空间、待处理的信号、进程的状态等等。</p><blockquote><p>² 一些操作系统设计文献称此列表为任务数组 (task array)。由于 Linux的实现是链表而非静态数组，因此在 Linux 中它被称为任务列表 (tasklist)。</p></blockquote><hr /><h3 id="分配进程描述符"><strong>分配进程描述符</strong></h3><p><code>task_struct</code> 结构通过 <strong>slab 分配器 (slaballocator)</strong> 进行分配，以提供对象重用和缓存着色。在 2.6系列内核之前，<code>struct task_struct</code>存储在每个进程的内核栈的末端。这使得像 x86这样寄存器数量较少的体系结构，可以通过栈指针计算进程描述符的位置，而无需使用额外的寄存器来存储该位置。由于现在进程描述符是通过slab 分配器动态创建的，因此引入了一个新的结构<code>struct thread_info</code>，该结构再次存在于栈的底部（对于向下增长的栈）或栈的顶部（对于向上增长的栈）³。参见图3.2。</p><blockquote><p>³ 创建 <code>struct thread_info</code>并不仅仅是因为寄存器受限的体系结构。新结构也使得在汇编代码中计算其值的偏移量变得相当容易。</p></blockquote><p><code>thread_info</code> 结构在 x86 上的<code>&lt;asm/thread_info.h&gt;</code> 中定义如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>    *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>    *<span class="title">exec_domain</span>;</span></span><br><span class="line">    __u32                 flags;</span><br><span class="line">    __u32                 status;</span><br><span class="line">    __u32                 cpu;</span><br><span class="line">    <span class="type">int</span>                   preempt_count;</span><br><span class="line">    <span class="type">mm_segment_t</span>          addr_limit;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span>  <span class="title">restart_block</span>;</span></span><br><span class="line">    <span class="type">void</span>                  *sysenter_return;</span><br><span class="line">    <span class="type">int</span>                   uaccess_err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><strong>(图 3.2 示意图说明)</strong> 进程内核栈<br />栈起始处（向低地址方向增长）<br />- 最高内存地址<br />- 栈指针<br />- <code>struct thread_struct</code> (进程的<code>struct task_struct</code>)<br />- 最低内存地址, <code>current_thread_info()</code><br /><code>thread_info</code> 包含一个指向进程描述符的指针</p><blockquote><p>栈的增长方向：x86 体系的栈是向下（向低地址方向）增长的。 - 栈底(Stack Base)：为了充分利用这块内存，栈被初始化为从这块分配区的最高地址(0x10000)开始。这个初始的栈指针位置就是栈底。它是栈的“起点”，但却是分配内存块的“末尾”。- 栈顶 (Stack Top)：随着函数调用、压入参数等操作，%esp寄存器的值会不断减小（向 0xE000 方向移动）。%esp当前指向的位置称为栈顶。它是栈的“当前操作端”，向低地址方向延伸。</p></blockquote><p>每个任务的 <code>thread_info</code> 结构都分配在其栈的末端。该结构的<code>task</code> 元素是一个指向任务实际 <code>task_struct</code>的指针。</p><hr /><h3 id="存储进程描述符"><strong>存储进程描述符</strong></h3><p>系统通过一个唯一的<strong>进程标识值 (process identificationvalue)</strong> 或 <strong>PID</strong> 来识别进程。PID是一个由不透明类型⁴ <code>pid_t</code> 表示的数值，通常是一个<code>int</code>。然而，为了与早期的 Unix 和 Linux版本向后兼容，默认最大值仅为 32,768（一个 <code>short int</code>的值），尽管可以选择将该值增加到高达 400 万（这由<code>&lt;linux/threads.h&gt;</code> 控制）。内核在每个进程描述符的<code>pid</code> 字段中存储此值。</p><blockquote><p>⁴ 不透明类型 (opaquetype)：指其内部细节被隐藏，只通过特定接口访问的数据类型。</p></blockquote><p>这个最大值很重要，因为它本质上是系统上可能同时存在的最大进程数。虽然32,768对于桌面系统可能足够，但大型服务器可能需要多得多的进程。此外，该值越低，数值回绕（wraparound）就越快，这会破坏“数值大的进程比数值小的进程更晚运行”这一有用概念。如果系统愿意打破与旧应用程序的兼容性，管理员可以通过<code>/proc/sys/kernel/pid_max</code> 来增加最大值。</p><p>在内核内部，通常直接通过指向其 <code>task_struct</code>结构的指针来引用任务。事实上，大多数处理进程的内核代码都直接使用<code>struct task_struct</code>。因此，能够快速查找当前正在执行的任务的进程描述符是非常有用的，这是通过<code>current</code>宏来完成的。这个宏必须由每个体系结构独立实现。一些体系结构将当前运行进程的<code>task_struct</code>结构的指针保存在一个寄存器中，以实现高效访问。其他体系结构，如x86（几乎没有多余的寄存器可用），则利用 <code>struct thread_info</code>存储在内核栈上这一条件，来计算 <code>thread_info</code> 的位置，进而找到<code>task_struct</code>。</p><p>在 x86 上，<code>current</code> 是通过滤除栈指针的最低 13 位来获得<code>thread_info</code> 结构计算的。这是由<code>current_thread_info()</code> 函数完成的。汇编代码如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl $-8192, %eax</span><br><span class="line">andl %esp, %eax</span><br></pre></td></tr></table></figure> 这里假设栈大小是 8KB。当启用 4KB 栈时，使用 4096 代替8192。</p><p>最后，<code>current</code> 解引用 <code>thread_info</code> 的<code>task</code> 成员以返回 <code>task_struct</code>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current_thread_info()-&gt;task;</span><br></pre></td></tr></table></figure></p><p>将此方法与 PowerPC（IBM 的现代基于 RISC的微处理器）采用的方法对比，后者将当前的 <code>task_struct</code>存储在一个寄存器中。因此，在 PPC 上 <code>current</code>仅仅返回存储在寄存器 <code>r2</code> 中的值。PPC可以采用这种方法是因为，与 x86不同，它有大量的寄存器。由于访问进程描述符是一项常见且重要的工作，PPC内核开发人员认为使用一个寄存器是值得的。</p><h3 id="进程状态-process-state"><strong>进程状态 (ProcessState)</strong></h3><p>进程描述符中的 <code>state</code> 字段描述了进程的当前状况（参见图3.3）。系统中的每个进程都确切地处于五种不同状态中的一种。该值由以下五个标志之一表示：</p><ul><li><strong>TASK_RUNNING(运行)</strong>：进程是可运行的；它要么正在执行，要么在运行队列（runqueue）中等待运行（运行队列将在第4章讨论）。这是在用户空间执行的进程唯一可能的状态；它也应用于正在内核空间中主动运行的进程。</li><li><strong>TASK_INTERRUPTIBLE(可中断睡眠)</strong>：进程正在睡眠（即被阻塞），等待某个条件的发生。当此条件满足时，内核会将进程的状态设置为<code>TASK_RUNNING</code>。如果进程接收到信号，它也会被提前唤醒并变为可运行状态。</li><li><strong>TASK_UNINTERRUPTIBLE (不可中断睡眠)</strong>：此状态与<code>TASK_INTERRUPTIBLE</code>类似，区别在于即使接收到信号，它也不会被唤醒并变为可运行状态。此状态用于进程必须不受中断地等待，或者预期事件会很快发生的场合。由于处在此状态的任务不响应信号，因此<code>TASK_UNINTERRUPTIBLE</code> 的使用频率低于<code>TASK_INTERRUPTIBLE</code>⁵。</li><li>**__TASK_TRACED (被跟踪)**：进程正被另一个进程（例如调试器通过<code>ptrace</code>）所跟踪。</li><li>**__TASK_STOPPED(停止)**：进程执行已停止；任务既不在运行，也没有资格运行。如果任务收到<code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code> 或<code>SIGTTOU</code>信号，或者在被调试时收到任何信号，就会发生这种状态。</li></ul><blockquote><p>⁵ 这就是为什么在 <code>ps(1)</code> 命令中会出现那些状态为 D (即<code>TASK_UNINTERRUPTIBLE</code>)的、令人头疼的无法杀死的进程。因为该任务不响应信号，你无法向它发送<code>SIGKILL</code>信号。此外，即使你能终止该任务，这样做通常也不明智，因为该任务可能正在进行一项重要操作（并可能持有信号量）。</p></blockquote><h3id="操作当前进程状态-manipulating-the-current-process-state"><strong>操作当前进程状态(Manipulating the Current Process State)</strong></h3><p>内核代码经常需要更改进程的状态。首选机制是使用： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_task_state(task, state);        <span class="comment">/* 将任务 &#x27;task&#x27; 的状态设置为 &#x27;state&#x27; */</span></span><br></pre></td></tr></table></figure>此函数将给定的任务设置为给定的状态。在适用的情况下，它还提供一个<strong>内存屏障(memory barrier)</strong> 以强制在其他处理器上的执行顺序（这仅在 SMP系统上需要）。否则，它等价于： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task-&gt;state = state;</span><br></pre></td></tr></table></figure> 方法<code>set_current_state(state)</code> 等同于<code>set_task_state(current, state)</code>。请参阅<code>&lt;linux/sched.h&gt;</code> 以了解这些及相关函数的实现。</p><hr /><h3 id="进程上下文-process-context"><strong>进程上下文 (ProcessContext)</strong></h3><p>进程最重要的部分之一是正在执行的程序代码。这些代码从可执行文件中读入，并在程序的地址空间内执行。正常的程序执行发生在<strong>用户空间(user-space)</strong>。当程序执行系统调用或触发异常时，它就进入了<strong>内核空间(kernel-space)</strong>。此时，内核被称为“代表进程执行”并处于<strong>进程上下文(process context)</strong> 中。在进程上下文中，<code>current</code>宏是有效的⁶。退出内核后，进程会在用户空间恢复执行，除非在此期间有更高优先级的进程变为可运行状态（这种情况下将调用调度器来选择更高优先级的进程）。</p><blockquote><p>⁶ 除了进程上下文，还有<strong>中断上下文 (interruptcontext)</strong>。在中断上下文中，系统并非代表某个进程运行，而是在执行一个中断处理程序。没有进程与中断处理程序相关联。</p></blockquote><p>系统调用和异常处理程序是进入内核的明确定义的接口。进程只能通过这些接口之一开始在内核空间中执行——所有对内核的访问都是通过这些接口进行的。</p><hr /><h3 id="进程家族树-the-process-family-tree"><strong>进程家族树 (TheProcess Family Tree)</strong></h3><p>在 Unix 系统（Linux也不例外）的进程之间存在着一个清晰的层次结构。所有进程都是 <strong>init进程</strong>（其 PID 为 1）的后代。内核在启动过程的最后步骤中启动<code>init</code>。然后，<code>init</code>进程读取系统初始化脚本并执行更多程序，最终完成启动过程。</p><p>系统中的每个进程都有且只有一个<strong>父进程(parent)</strong>。同样，每个进程有零个或多个<strong>子进程(children)</strong>。同一父进程的所有直接子进程称为<strong>兄弟进程(siblings)</strong>。进程之间的关系存储在进程描述符中。每个<code>task_struct</code> 都有一个指向父进程 <code>task_struct</code>的指针（名为 <code>parent</code>），以及一个子进程的链表（名为<code>children</code>）。</p><p>因此，给定当前进程，可以通过以下代码获取其父进程的描述符：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">my_parent</span> =</span> current-&gt;parent;</span><br></pre></td></tr></table></figure> 类似地，可以这样遍历一个进程的所有子进程：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each(<span class="built_in">list</span>, &amp;current-&gt;children) &#123;</span><br><span class="line">    task = list_entry(<span class="built_in">list</span>, <span class="keyword">struct</span> task_struct, sibling);</span><br><span class="line">    <span class="comment">/* task 现在指向 current 的某个子进程 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>init 任务的进程描述符是静态分配的，名为<code>init_task</code>。所有进程间关系的一个很好例证是下面这段代码总能执行成功：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="keyword">for</span> (task = current; task != &amp;init_task; task = task-&gt;parent)</span><br><span class="line">    ;</span><br><span class="line"><span class="comment">/* 循环结束后，task 指向了 init */</span></span><br></pre></td></tr></table></figure>实际上，你可以从系统中的任何一个进程出发，循着进程层次结构到达任何其他进程。</p><p>然而，通常我们更希望简单地遍历系统中的所有进程。这很容易，因为任务列表是一个<strong>循环双向链表(circular doubly linkedlist)</strong>。给定任何一个有效任务，要获取链表中的下一个任务，可以使用：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_entry(task-&gt;tasks.next, <span class="keyword">struct</span> task_struct, tasks)</span><br></pre></td></tr></table></figure> 获取上一个任务的方式相同： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_entry(task-&gt;tasks.prev, <span class="keyword">struct</span> task_struct, tasks)</span><br></pre></td></tr></table></figure>这两个操作分别由宏 <code>next_task(task)</code> 和<code>prev_task(task)</code> 提供。最后，提供了宏<code>for_each_process(task)</code>用于遍历整个任务列表。每次迭代时，<code>task</code>指向列表中的下一个任务： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">for_each_process(task) &#123;</span><br><span class="line">    <span class="comment">/* 这段代码无意义地打印每个任务的名称和 PID */</span></span><br><span class="line">    printk(<span class="string">&quot;%s[%d]\n&quot;</span>, task-&gt;comm, task-&gt;pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>注意</strong>在拥有大量进程的系统中，遍历每个任务的开销很大；代码在这样做之前应该有充分的理由（并且没有其他替代方案）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;进程&quot;&gt;&lt;strong&gt;进程&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;一个进程是一个正在执行中的程序（存储在某种介质上的目标代码）。然而，进程不仅仅只是执行的程序代码（在
Unix
中常称为文本段）。它们还包括一系列资源，例如打开的文件和待处理的信号、内核内部数据</summary>
      
    
    
    
    <category term="os basic" scheme="https://mackz-maxw.github.io/categories/os-basic/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统基础 | 4.7 内核模块实验</title>
    <link href="https://mackz-maxw.github.io/2025/08/19/oper_sys21lab_kMod/"/>
    <id>https://mackz-maxw.github.io/2025/08/19/oper_sys21lab_kMod/</id>
    <published>2025-08-19T17:15:49.479Z</published>
    <updated>2025-08-20T16:31:13.295Z</updated>
    
    <content type="html"><![CDATA[<h3 id="可加载的内核模块">可加载的内核模块</h3><h4 id="练习-1">练习 1</h4><p>准备好实验报告</p><hr /><h4 id="练习-2-编译内核模块">练习 2: 编译内核模块</h4><ol type="1"><li><strong>步骤</strong>: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Linux Lab 集群上</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /project/scratch01/compile/your-username/modules</span><br><span class="line"><span class="built_in">cd</span> /project/scratch01/compile/your-username/modules</span><br><span class="line"><span class="comment"># 保存 simple_module.c 和 Makefile (内容: obj-m := simple_module.o)</span></span><br><span class="line">module add arm-rpi</span><br><span class="line"><span class="built_in">export</span> LINUX_SOURCE=/path/to/your/linux_source/linux <span class="comment"># 设置内核源码路径</span></span><br><span class="line">make -C <span class="variable">$LINUX_SOURCE</span> ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- M=<span class="variable">$PWD</span> modules</span><br></pre></td></tr></table></figure></li><li><strong>答案</strong>: 提交 <code>make</code> 命令的完整输出。</li></ol><hr /><h4 id="练习-3-加载模块与系统日志">练习 3: 加载模块与系统日志</h4><ol type="1"><li><strong>步骤</strong> (在树莓派上): <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/modules</span><br><span class="line"><span class="comment"># 使用 sftp 将 simple_module.ko 传输到此目录</span></span><br><span class="line">sudo dmesg --clear</span><br><span class="line">sudo insmod ~/modules/simple_module.ko</span><br><span class="line">dmesg <span class="comment"># 查看日志</span></span><br></pre></td></tr></table></figure></li><li><strong>答案</strong>: 提交 <code>dmesg</code>中显示的模块加载信息。</li></ol><hr /><h4 id="练习-4-验证模块列表与卸载">练习 4: 验证模块列表与卸载</h4><ol type="1"><li><strong>步骤</strong>: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsmod <span class="comment"># 确认 simple_module 在列表中</span></span><br><span class="line">sudo rmmod simple_module</span><br><span class="line">lsmod <span class="comment"># 确认已移除</span></span><br><span class="line">dmesg <span class="comment"># 查看卸载信息</span></span><br></pre></td></tr></table></figure></li><li><strong>答案</strong>: 提交 <code>lsmod</code>的输出（证明已卸载）和 <code>dmesg</code> 中显示的模块卸载信息。</li></ol><hr /><h4 id="练习-5-访问内核变量-jiffies">练习 5: 访问内核变量 jiffies</h4><ol type="1"><li><strong>步骤</strong>:<ul><li>复制 <code>simple_module.c</code> 为<code>jiffies_module.c</code>。</li><li>修改其 init 和 exit 函数，使用 <code>printk</code> 打印<code>jiffies</code> 变量（类型<code>extern unsigned long volatile jiffies;</code>）。</li><li>更新 Makefile: <code>obj-m += jiffies_module.o</code>。</li><li>重新编译并传输 <code>jiffies_module.ko</code> 到树莓派。</li><li>加载并卸载模块，观察 <code>dmesg</code>。</li></ul></li><li><strong>答案</strong>:<ul><li>提交 <code>dmesg</code> 中显示加载和卸载时 <code>jiffies</code>值的日志消息。</li><li>计算并说明两条消息之间发生的滴答数（tick count）。</li></ul></li></ol><hr /><h3 id="需提交的内容">需提交的内容</h3><p>请提交一个包含以下内容的压缩包或文档： 1. <strong>答案文件</strong>:包含上述所有练习的答案。 2. <strong>源代码文件</strong>: 你新创建的<code>jiffies_module.c</code> 文件。</p><hr /><h3 id="可选拓展练习">可选拓展练习</h3><h4 id="练习-6-模块初始化返回值实验">练习 6: 模块初始化返回值实验</h4><ul><li><strong>任务</strong>: 修改 init函数，使其分别返回正数和负数（错误码，参见<code>/include/uapi/asm-generic/errno-base.h</code>）。</li><li><strong>提示</strong>:描述加载模块时发生的情况及其在系统日志中的表现。</li></ul><h4 id="练习-7-探查导出的内核符号">练习 7: 探查导出的内核符号</h4><ul><li><strong>任务</strong>: 查看 <code>/proc/kallsyms</code> 文件（例如<code>cat /proc/kallsyms</code>），了解内核符号表。查找带有<code>__kstrtab_</code> 和 <code>__ksymtab_</code>前缀的符号（这些是可供模块使用的导出符号）。</li><li><strong>提示</strong>: 内核符号是 Linux内核代码中定义的函数、变量、数据结构等的名称标签。它们代表了在内核地址空间中的一个特定内存地址。可以将内核符号理解为内核的“公共接口”或“入口点”。主要有两种类型：</li><li>导出的符号：这些是内核明确声明为可以被外部模块使用的符号。例如，printk（内核的printf）、kmalloc（内核的内存分配函数）等。模块通过使用 EXPORT_SYMBOL()或 EXPORT_SYMBOL_GPL() 宏来导出它们的符号，以便其他模块可以使用。</li><li>非导出的符号：这些是内核内部的静态函数或变量，只在它们被定义的文件或内核的特定部分中使用。它们对于内核模块是不可见的，主要用于内核自身的组织</li><li>EXPORT_SYMBOL(printk) 在编译后创建了两个内部符号：__ksymtab_printk和 __kstrtab_printk。<ul><li>__ksymtab_printk 是一个结构体，包含了 printk 的地址和指向__kstrtab_printk 的指针。</li><li>__kstrtab_printk 是一个字符串，存储着 printk 的名字。</li></ul></li><li>内核使用这个结构来高效地通过名字查找函数的地址</li></ul><h4 id="练习-8-实现用户态读取-cpu-周期计数器-ccnt-的模块">练习 8:实现用户态读取 CPU 周期计数器 (CCNT) 的模块</h4><ul><li><strong>任务</strong> (如果之前在系统调用工作室未完成):<ul><li>将提供的驱动文件放入你的内核源码树的<code>arch/arm/include/asm</code> 目录。</li><li>下载 <code>enable_ccnt.c</code> 内核模块代码到你的模块目录。</li><li>编译、传输并加载此模块 (<code>insmod enable_ccnt.ko</code>)。</li><li>使用 <code>dmesg | tail</code> 验证加载成功。</li></ul></li><li><strong>任务</strong> (主要部分):<ul><li>在树莓派上创建一个用户态程序。</li><li>该程序应 <code>#include</code> 你获取的驱动头文件。</li><li>调用 <code>unsigned long long pmccntr_get(void)</code>函数两次。</li></ul></li><li><strong>答案</strong>:<ul><li>说明运行一次 <code>pmccntr_get()</code> 函数大约需要多少 CPU周期（计算两次调用的差值）。</li><li>如果你在系统调用工作室完成过类似的练习，请对比直接调用此函数与通过系统调用获取周期计数所需的周期数。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;可加载的内核模块&quot;&gt;可加载的内核模块&lt;/h3&gt;
&lt;h4 id=&quot;练习-1&quot;&gt;练习 1&lt;/h4&gt;
&lt;p&gt;准备好实验报告&lt;/p&gt;
&lt;hr /&gt;
&lt;h4 id=&quot;练习-2-编译内核模块&quot;&gt;练习 2: 编译内核模块&lt;/h4&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li</summary>
      
    
    
    
    <category term="os basic" scheme="https://mackz-maxw.github.io/categories/os-basic/"/>
    
    <category term="lab" scheme="https://mackz-maxw.github.io/categories/os-basic/lab/"/>
    
    
  </entry>
  
  <entry>
    <title>操作系统基础 | 4.6 内核API重构案例：IDR API</title>
    <link href="https://mackz-maxw.github.io/2025/08/19/oper_sys20rebuildIDRApi/"/>
    <id>https://mackz-maxw.github.io/2025/08/19/oper_sys20rebuildIDRApi/</id>
    <published>2025-08-19T17:07:16.581Z</published>
    <updated>2025-08-19T17:11:57.670Z</updated>
    
    <content type="html"><![CDATA[<p>文章内容来自 LWN.net</p><h3 id="文章摘要-summary">文章摘要 (Summary)</h3><p>这篇发表于 2013 年 2 月的文章讨论了 Linux 内核中 <strong>IDR 子系统API 的一次重大简化改革</strong>，由开发者 Tejun Heo 主导。IDR机制用于高效分配和管理整数 ID（例如设备名、POSIX 定时器 ID 等），其旧API 因其复杂性和潜在的竞争条件而闻名。</p><p><strong>核心问题：旧 API 的缺陷</strong> 1.<strong>两步分配</strong>：需要先调用 <code>idr_pre_get()</code>预分配内存（可休眠），再调用 <code>idr_get_new()</code> 获取ID（可原子上下文）。 2.<strong>必须重试循环</strong>：<code>idr_get_new()</code>可能因预分配内存被其他 CPU 耗尽而失败（返回<code>-EAGAIN</code>），要求调用者编写冗长且易错的循环重试代码。 3.<strong>全局资源竞争</strong>：<code>idr_pre_get()</code>预分配的内存是全局的，多个 CPU 竞争时，后执行的<code>idr_get_new()</code>可能因资源不足而失败，迫使代码退出原子上下文进行重试，这条路径往往缺乏测试。</p><p><strong>解决方案：新 API 的改进</strong> Tejun Heo引入了三个新函数来简化流程： 1.<code>idr_preload(gfp_t gfp_mask)</code>: 为<strong>当前 CPU</strong>预分配内存，并<strong>禁用抢占</strong>以防止预分配的内存被偷。 2.<code>idr_alloc(...)</code>: <strong>单次调用</strong>即可完成 ID分配和关联。它接受 ID范围参数，并仅在真正需要时（未预分配或预分配不足）才使用<code>gfp_mask</code> 分配内存。它只会在内存分配彻底失败时报错，消除了对<code>-EAGAIN</code> 的重试循环需求。 3. <code>idr_preload_end()</code>:在 <code>idr_alloc</code> 后调用，<strong>重新启用抢占</strong>。</p><p><strong>关键优势：</strong> *<strong>更简单</strong>：消除了遍布内核的百余处重复、易错的样板代码。 *<strong>更可靠</strong>：通过每 CPU预分配和禁用抢占，基本消除了在原子上下文中因资源竞争而失败的需要。 *<strong>更灵活</strong>：<code>idr_alloc</code> 可以指定 ID范围，并且如果能在进程上下文调用，甚至可以完全省略<code>idr_preload</code>/<code>idr_preload_end</code>。</p><p><strong>社区反应：</strong> 尽管大部分开发者接受了这个改动（给出了Acked-by），但 Eric Biederman 表达了强烈反对，认为新 API 的<code>idr_preload</code>像是一种难以理解的“魔法”。然而，文章作者（JonathanCorbet）预测，<strong>新 API带来的巨大简化优势将使其最终被内核社区接受</strong>。</p><h3 id="新旧-api-对比总结">新旧 API 对比总结</h3><div class="line-block">特性 | 旧 API (2013 年前) | 新 API (Tejun Heo提议) |<br />：--- | :--- | :--- |<br /><strong>核心函数</strong> | <code>idr_pre_get()</code>,<code>idr_get_new()</code> | <code>idr_preload()</code>,<code>idr_alloc()</code>, <code>idr_preload_end()</code> |<br /><strong>调用模式</strong> |<strong>两步过程</strong>，必须配合<strong>重试循环</strong> |<strong>单次调用</strong>(<code>idr_alloc</code>)，<strong>无需循环</strong> |<br /><strong>预分配内存</strong> | <strong>全局共享</strong>，易被其他 CPU消耗 | <strong>每 CPU独享</strong>，配合<strong>禁用抢占</strong>，不会被偷 |<br /><strong>错误处理</strong> | 可能返回<code>-EAGAIN</code>，要求调用者重试 | 仅在所有内存分配都失败时才报错|<br /><strong>原子上下文</strong> | 支持，但重试时必须退出原子上下文 |更好支持，通过 <code>preload</code>/<code>preload_end</code> 保障|<br /><strong>代码复杂度</strong> | 高，需要大量重复的样板代码 |低，调用逻辑非常简洁 |</div><h3 id="结论">结论</h3><p>这篇文章记录了一个经典的内核优化案例：通过巧妙的设计（利用每 CPU数据和禁用抢占）将一个复杂、易错、充满竞争条件的旧接口，重构为一个简洁、可靠、高效的新接口。尽管存在一些争议，但<strong>简化并提升广泛使用的底层API的价值是极其巨大的</strong>，这很可能是新方案最终被采纳的原因。这正是Linux 内核持续演进的一个缩影。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章内容来自 LWN.net&lt;/p&gt;
&lt;h3 id=&quot;文章摘要-summary&quot;&gt;文章摘要 (Summary)&lt;/h3&gt;
&lt;p&gt;这篇发表于 2013 年 2 月的文章讨论了 Linux 内核中 &lt;strong&gt;IDR 子系统
API 的一次重大简化改革&lt;/strong</summary>
      
    
    
    
    <category term="os basic" scheme="https://mackz-maxw.github.io/categories/os-basic/"/>
    
    
  </entry>
  
</feed>
