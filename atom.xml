<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maxw的小站</title>
  
  <subtitle>Maxw学习记录</subtitle>
  <link href="https://mackz-maxw.github.io/atom.xml" rel="self"/>
  
  <link href="https://mackz-maxw.github.io/"/>
  <updated>2025-05-27T21:51:13.529Z</updated>
  <id>https://mackz-maxw.github.io/</id>
  
  <author>
    <name>Mackz-Maxw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码随想录 | 刷题-二叉树3</title>
    <link href="https://mackz-maxw.github.io/2025/05/27/kamacode13/"/>
    <id>https://mackz-maxw.github.io/2025/05/27/kamacode13/</id>
    <published>2025-05-27T21:50:08.642Z</published>
    <updated>2025-05-27T21:51:13.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="平衡二叉树">110.平衡二叉树</h3><p>看到这题我的思路就是求高度算差值，看了题解才发现可以在求深度的同时就判定是否不平衡并剪枝最后没想到的是居然还能犯打错字符的错，看来以后变量命名还是少偷懒<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        d++;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">depth</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> r = <span class="built_in">depth</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(r == <span class="number">-1</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(l-r)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> d + <span class="built_in">max</span>(l, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">depth</span>(root) == <span class="number">-1</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的所有路径">257. 二叉树的所有路径</h3><p>完全不知道该怎么写回溯啊...看了题解提示，有一次带push的递归，就有一次回溯，似乎有点理解了询问chatgpt,得知如果我一定要用迭代法，应该也是类似递归的逻辑：</p><ol type="1"><li>每次将当前节点和路径压入栈。</li><li>如果当前节点是叶子节点，则把路径加入结果。</li><li>否则，将右子树和左子树（如果存在）分别入栈，并将路径扩展。</li></ol><p>如果删改执行逻辑，就算多弹出一次节点，到了外层while的下一个循环又会从左节点开始重复遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">push_back</span>(path[i]); <span class="comment">// ❌</span></span><br></pre></td></tr></table></figure><p>在 <code>string</code> 中直接用 <code>push_back(int)</code>，会被当作ASCII 字符写进去，而不是数字！<br />应该改成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s += <span class="built_in">to_string</span>(path[i]);</span><br></pre></td></tr></table></figure><p>这里我path传值不传引用，隐式使用了迭代法函数栈的特性来回溯path：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">vecString</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; path)</span></span>&#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;path.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            s += <span class="built_in">to_string</span>(path[i]);</span><br><span class="line">            <span class="keyword">if</span>(i != (path.<span class="built_in">size</span>()<span class="number">-1</span>))s.<span class="built_in">append</span>(<span class="string">&quot;-&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;path, vector&lt;string&gt;&amp;result)</span></span>&#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(<span class="built_in">vecString</span>(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            <span class="built_in">traverse</span>(root-&gt;left, path, result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)&#123;</span><br><span class="line">            <span class="built_in">traverse</span>(root-&gt;right, path, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        <span class="built_in">traverse</span>(root, path, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="左叶子之和">404.左叶子之和</h3><p>我直接防御型编程 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left)&#123;</span><br><span class="line">            sum += <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!root-&gt;left-&gt;left &amp;&amp; !root-&gt;left-&gt;right)&#123;</span><br><span class="line">            sum += root-&gt;left-&gt;val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            sum += <span class="built_in">sumOfLeftLeaves</span>(root-&gt;left); <span class="comment">// if(root-&gt;left)</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)sum += <span class="built_in">sumOfLeftLeaves</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="完全二叉树的节点个数">222.完全二叉树的节点个数</h3><p><span class="math inline">\(O(n)\)</span>写法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> cnt;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)cnt += <span class="built_in">countNodes</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)cnt += <span class="built_in">countNodes</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>使用完全二叉树的性质：完全二叉树只有两种情况，情况一：就是满二叉树，情况二：最后一层叶子节点没有满。<img src="../images/kamacode13_1.png" alt="完全二叉树1" /> *对于情况一，可以直接用 2^树深度 - 1 来计算，注意这里根节点深度为1。 *对于情况二，分别递归左孩子，和右孩子，递归到某一深度一定会有左孩子或者右孩子为满二叉树，然后依然可以按照情况1来计算</p><p>在完全二叉树中，如果递归向左遍历的深度等于递归向右遍历的深度，那说明就是满二叉树<img src="../images/kamacode13_2.png" alt="完全二叉树2" /> 可以达到<spanclass="math inline">\(O(log n × log n)\)</span>时间复杂度</p><h4 id="推荐修正版本如下">✅ 推荐修正版本如下：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countNodes</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        TreeNode* left = root;</span><br><span class="line">        TreeNode* right = root;</span><br><span class="line">        <span class="type">int</span> leftDepth = <span class="number">0</span>, rightDepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left) &#123;</span><br><span class="line">            leftDepth++;</span><br><span class="line">            left = left-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (right) &#123;</span><br><span class="line">            rightDepth++;</span><br><span class="line">            right = right-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) &#123;</span><br><span class="line">            <span class="comment">// 是满二叉树</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="number">1</span> &lt;&lt; leftDepth) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不是满二叉树，递归统计</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">countNodes</span>(root-&gt;left) + <span class="built_in">countNodes</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;平衡二叉树&quot;&gt;110.平衡二叉树&lt;/h3&gt;
&lt;p&gt;看到这题我的思路就是求高度算差值，看了题解才发现可以在求深度的同时就判定是否不平衡并剪枝
最后没想到的是居然还能犯打错字符的错，看来以后变量命名还是少偷懒
&lt;figure class=&quot;highlight c</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-二叉树2</title>
    <link href="https://mackz-maxw.github.io/2025/05/26/kamacode12/"/>
    <id>https://mackz-maxw.github.io/2025/05/26/kamacode12/</id>
    <published>2025-05-27T02:04:25.786Z</published>
    <updated>2025-05-26T19:30:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天找到了一个将chatGPT内容markdown化的插件（chrome插件商店搜索chatGPTto Markdown），这样整理每天的错题就方便直观多了</p><h3 id="堆对象-vs-栈对象-初始化">堆对象 vs 栈对象 初始化</h3><p>在 <strong>C++ 中，<code>struct</code> 和 <code>class</code>在语法上几乎没有区别</strong>，主要区别只有两点：</p><ol type="1"><li><p>默认访问权限：<code>struct</code> 默认是<code>public</code>，<code>class</code> 默认是<code>private</code></p></li><li><p>默认继承权限：<code>struct</code> 默认是 <code>public</code>继承，<code>class</code> 默认是 <code>private</code> 继承</p></li></ol><p>👉 所以：<strong><code>struct</code> 并不“必须”用 <code>new</code>来创建对象！</strong></p><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr><th>写法</th><th>内存位置</th><th>生命周期</th><th>示例</th></tr></thead><tbody><tr><td><code>Class c;</code></td><td>栈 (stack)</td><td>自动管理</td><td><code>class</code> 或 <code>struct</code> 都可以</td></tr><tr><td><code>Class* c = new Class();</code></td><td>堆 (heap)</td><td>需要手动 <code>delete</code></td><td><code>class</code> 或 <code>struct</code> 都可以</td></tr></tbody></table><p><strong>在需要动态分配的场景使用new（如链表节点）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node* head = <span class="keyword">new</span> <span class="built_in">Node</span>(); <span class="comment">// ✅ 堆上分配，适合动态数据结构</span></span><br></pre></td></tr></table></figure><h3 id="二叉树的层序遍历">102. 二叉树的层序遍历</h3><p>昨天的层序遍历练一练 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; lev;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> res;</span><br><span class="line">        lev.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!lev.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> len = lev.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; levVar;</span><br><span class="line">            <span class="keyword">while</span>(len &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                len--;</span><br><span class="line">                TreeNode* cur = lev.<span class="built_in">front</span>();</span><br><span class="line">                lev.<span class="built_in">pop</span>();</span><br><span class="line">                levVar.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;left)lev.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(cur-&gt;right)lev.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(levVar);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="翻转二叉树">226.翻转二叉树</h3><h4 id="问题一错误创建了无用的-treenode">❌ 问题一：错误创建了无用的<code>TreeNode</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* rightT = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line"><span class="keyword">if</span>(root-&gt;right) rightT = root-&gt;right;</span><br></pre></td></tr></table></figure><p>在这里无论 <code>root-&gt;right</code> 是否为空，都会创建一个新的<code>TreeNode</code> 实例。但实际上你只需要记录<code>root-&gt;right</code> 的原始指针。<strong>没有 delete 掉那个多余的new TreeNode()</strong>，会造成内存泄漏。在递归中创建新的<code>TreeNode</code>，可能无限递归，造成 <strong>stackoverflow</strong>。</p><p>要删除通过 <code>new TreeNode()</code> 动态创建的对象，只需要调用<code>delete</code> 并传入该指针即可。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line"><span class="comment">// 使用 node 做一些操作</span></span><br><span class="line"><span class="keyword">delete</span> node; <span class="comment">// 释放内存</span></span><br><span class="line">node = <span class="literal">nullptr</span>; <span class="comment">// 避免悬空指针（可选但推荐）</span></span><br></pre></td></tr></table></figure><h4 id="注意事项">✅ 注意事项：</h4><ol type="1"><li><p><strong>每一个 <code>new</code> 都要对应一个<code>delete</code></strong>，否则会导致内存泄漏。</p></li><li><p>删除后最好将指针设为<code>nullptr</code>，防止以后误访问已释放的内存。</p></li><li><p>如果你创建的是数组，用 <code>new[]</code>，则要用<code>delete[]</code>。</p></li></ol><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br></pre></td></tr></table></figure><h4 id="问题二判断逻辑混乱递归不完整">❌问题二：判断逻辑混乱，递归不完整</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">    root-&gt;right = <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(rightT != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">    root-&gt;left = <span class="built_in">invertTree</span>(rightT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>root-&gt;left</code> 是 <code>nullptr</code>，就跳过了对<code>root-&gt;right</code> 的赋值</p><p>正确的做法是把翻转和赋值分隔开来： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> root;</span><br><span class="line">        TreeNode* rightT = <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        TreeNode* leftT = <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        root-&gt;left = rightT;</span><br><span class="line">        root-&gt;right = leftT;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="对称二叉树">101. 对称二叉树</h3><p>别忘了判定值是否一致 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSym</span><span class="params">(TreeNode* left, TreeNode* right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!left &amp;&amp; !right)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>((!left &amp;&amp; right) || (!right &amp;&amp; left))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val != right-&gt;val)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> isIn = <span class="built_in">isSym</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">        <span class="type">bool</span> isOut = <span class="built_in">isSym</span>(left-&gt;left, right-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> isIn &amp;&amp; isOut;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isSym</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的最大深度">104.二叉树的最大深度</h3><ul><li>二叉树节点的深度：指从根节点到该节点的最长简单路径边的条数或者节点数（取决于深度从0开始还是从1开始）</li><li>二叉树节点的高度：指从该节点到叶子节点的最长简单路径边的条数或者节点数（取决于高度从0开始还是从1开始）</li></ul><p>注意边界条件对代码的影响</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxD = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            maxD++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> maxD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> maxL = root-&gt;left ? <span class="built_in">maxDepth</span>(root-&gt;left) : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxR = root-&gt;right ? <span class="built_in">maxDepth</span>(root-&gt;right) : <span class="number">0</span>;</span><br><span class="line">        maxD += maxL &gt; maxR ? maxL : maxR;</span><br><span class="line">        <span class="keyword">return</span> maxD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最小深度">111.二叉树的最小深度</h3><p>迭代法： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> minD = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> minD;</span><br><span class="line">        minD++;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; !root-&gt;right)<span class="keyword">return</span> minD;</span><br><span class="line">        <span class="keyword">if</span>(!root-&gt;left &amp;&amp; root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> minD + <span class="built_in">minDepth</span>(root-&gt;right);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left &amp;&amp; !root-&gt;right)&#123;</span><br><span class="line">            <span class="keyword">return</span> minD + <span class="built_in">minDepth</span>(root-&gt;left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> minL = <span class="built_in">minDepth</span>(root-&gt;left);</span><br><span class="line">            <span class="type">int</span> minR = <span class="built_in">minDepth</span>(root-&gt;right);</span><br><span class="line">            minD += minL &gt; minR ? minR : minL;</span><br><span class="line">            <span class="keyword">return</span> minD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天找到了一个将chatGPT内容markdown化的插件（chrome插件商店搜索chatGPT
to Markdown），这样整理每天的错题就方便直观多了&lt;/p&gt;
&lt;h3 id=&quot;堆对象-vs-栈对象-初始化&quot;&gt;堆对象 vs 栈对象 初始化&lt;/h3&gt;
&lt;p&gt;在 &lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 八股-HTTP请求</title>
    <link href="https://mackz-maxw.github.io/2025/05/26/kamabagu2/"/>
    <id>https://mackz-maxw.github.io/2025/05/26/kamabagu2/</id>
    <published>2025-05-27T02:04:25.737Z</published>
    <updated>2025-05-27T02:06:30.421Z</updated>
    
    <content type="html"><![CDATA[<h3id="http请求报文和响应报文是怎样的有哪些常见的字段">HTTP请求报文和响应报文是怎样的，有哪些常见的字段？</h3><p>HTTP报文分为请求报文和响应报文。</p><h4 id="请求报文"><strong>请求报文</strong></h4><p>请求报文主要由请求行、请求头、空行、请求体构成。请求行包括如下字段：</p><ul><li>方法（Method）：指定要执行的操作，如 GET、POST、PUT、DELETE等。</li><li>资源路径（Resource Path）：请求的资源的URI（统一资源标识符）。</li><li>HTTP版本（HTTP Version）：使用的HTTP协议版本，如 HTTP/1.1 或HTTP/2.0。</li></ul><p><strong>请求头</strong>的字段较多，常使用的包含以下几个：</p><ul><li>Host：请求的服务器的域名。</li><li>Accept：客户端能够处理的媒体类型。</li><li>Accept-Encoding：客户端能够解码的内容编码。</li><li>Authorization：用于认证的凭证信息，比如token数据。</li><li>Content-Length：请求体的长度。</li><li>Content-Type：请求体的媒体类型。（如<code>application/json</code>、<code>text/html</code> 等）</li><li>Cookie：存储在客户端的cookie数据。</li><li>If-None-Match：与 <code>ETag</code> 配合使用，用于缓存控制。</li><li>Connection：管理连接的选项，如 keep-alive。</li></ul><p>方便记忆：</p><h5 id="基本身份环境信息我是谁能接受什么">1.<strong>基本身份/环境信息</strong>（我是谁、能接受什么）</h5><ul><li><code>Host</code>：我要访问哪个服务器（主机名）</li><li><code>User-Agent</code>：我是哪个浏览器（可选提）</li><li><code>Accept</code> /<code>Accept-Encoding</code>：我能接受的内容类型/压缩方式</li></ul><h5 id="身份认证状态维持">2. <strong>身份认证/状态维持</strong></h5><ul><li><code>Authorization</code>：我的身份凭证（如 token）</li><li><code>Cookie</code>：我本地保存的 cookie，带回来给你看</li></ul><h5 id="请求体相关仅-postput-用">3. <strong>请求体相关（仅 POST/PUT用）</strong></h5><ul><li><code>Content-Type</code>：我发给你是什么格式（如 JSON）</li><li><code>Content-Length</code>：我发给你的内容多大</li></ul><h5 id="缓存控制和上次请求有关">4.<strong>缓存控制（和上次请求有关）</strong></h5><ul><li><code>If-None-Match</code>：上次你的资源 ETag 是XX，看看现在变没</li><li><code>If-Modified-Since</code>：上次的修改时间是XX，资源有变吗？</li><li><code>Cache-Control</code>：我是否希望使用缓存？</li></ul><p><strong>空行</strong>是请求头部和请求主体之间的空行，用于分隔请求头部和请求主体。</p><p><strong>请求体</strong>通常用于 POST 和 PUT请求，包含发送给服务器的数据。</p><h4 id="响应报文">响应报文</h4><p>HTTP响应报文是服务器向客户端返回的数据格式，用于传达服务器对客户端请求的处理结果以及相关的数据。一个标准的HTTP响应报文通常包含状态行、响应头、空行、响应体。</p><p>状态行包含HTTP版本、状态码和状态消息。例如：HTTP/1.1 200 OK</p><p>响应头部也是以键值对的形式提供的额外信息，类似于请求头部，用于告知客户端有关响应的详细信息。一些常见的响应头部字段包括：</p><ul><li>Content-Type：指定响应主体的媒体类型。</li><li>Content-Length：指定响应主体的长度（字节数）。</li><li>Server：指定服务器的信息。</li><li>Expires: 响应的过期时间，之后内容被认为是过时的。</li><li>ETag: 响应体的实体标签，用于缓存和条件请求。</li><li>Last-Modified： 资源最后被修改的日期和时间。</li><li>Location：在重定向时指定新的资源位置。</li><li>Set-Cookie：在响应中设置Cookie。</li><li>Access-Control-Allow-Origin:跨源资源共享（CORS）策略，指示哪些域可以访问资源。</li></ul><p>方便记忆：</p><h4 id="内容信息">1. <strong>内容信息</strong></h4><ul><li><code>Content-Type</code>：我返回的是什么格式（如 HTML/JSON）</li><li><code>Content-Length</code>：内容有多大</li></ul><h4 id="服务器身份">2. <strong>服务器身份</strong></h4><ul><li><code>Server</code>：我是哪个服务器（如 nginx）</li></ul><h4 id="状态维持">3. <strong>状态维持</strong></h4><ul><li><code>Set-Cookie</code>：设置 cookie，下次你带回来</li></ul><h4 id="缓存相关">4. <strong>缓存相关</strong></h4><ul><li><code>ETag</code>：这是资源的版本号</li><li><code>Last-Modified</code>：资源上次修改时间</li><li><code>Cache-Control</code> /<code>Expires</code>：多久前有效/过期时间</li></ul><h4 id="跨域和重定向">5. <strong>跨域和重定向</strong></h4><ul><li><code>Access-Control-Allow-Origin</code>：谁能访问我（CORS）</li><li><code>Location</code>：去这个新地址吧（重定向）</li></ul><p>空行（Empty Line）在响应头和响应体之间，表示响应头的结束。</p><p>响应体是服务端实际传输的数据，可以是文本、HTML页面、图片、视频等，也可能为空。</p><h3 id="http有哪些请求方式">HTTP有哪些请求方式？</h3><ul><li>GET：请求指定的资源。</li><li>POST：向指定资源提交数据进行处理请求（例如表单提交）。</li><li>PUT：更新指定资源。</li><li>DELETE：删除指定资源。</li><li>HEAD：获取GET请求相同响应的报文首部，不返回报文主体。</li><li>OPTIONS：查询服务器支持的请求方法。</li><li>PATCH：对资源进行部分更新</li></ul><h3 id="get请求和post请求的区别">GET请求和POST请求的区别</h3><ul><li>用途：GET请求通常用于获取数据，POST请求用于提交数据。</li><li>数据传输：GET请求将参数附加在URL之后，POST请求将数据放在请求体中。</li><li>安全性：GET请求由于参数暴露在URL中，安全性较低；POST请求参数不会暴露在URL中，相对更安全。</li><li>数据大小：GET请求受到URL长度限制，数据量有限；POST请求理论上没有大小限制。</li><li>幂等性：GET请求是幂等的，即多次执行相同的GET请求，资源的状态不会改变；POST请求不是幂等的，因为每次提交都可能改变资源状态。</li><li>缓存：GET请求可以被缓存，POST请求默认不会被缓存。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3
id=&quot;http请求报文和响应报文是怎样的有哪些常见的字段&quot;&gt;HTTP请求报文和响应报文是怎样的，有哪些常见的字段？&lt;/h3&gt;
&lt;p&gt;HTTP报文分为请求报文和响应报文。&lt;/p&gt;
&lt;h4 id=&quot;请求报文&quot;&gt;&lt;strong&gt;请求报文&lt;/strong&gt;&lt;/h4&gt;
&lt;</summary>
      
    
    
    
    <category term="comp basic" scheme="https://mackz-maxw.github.io/categories/comp-basic/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-二叉树</title>
    <link href="https://mackz-maxw.github.io/2025/05/25/kamacode11/"/>
    <id>https://mackz-maxw.github.io/2025/05/25/kamacode11/</id>
    <published>2025-05-25T15:48:50.445Z</published>
    <updated>2025-05-25T22:01:47.121Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树的前序遍历">144.二叉树的前序遍历</h3><h4 id="递归法">递归法</h4><p>注意边界条件，root为空指针时不再向下迭代叶子节点 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preTree</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root)&#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">preTree</span>(root-&gt;left, vec);</span><br><span class="line">            <span class="built_in">preTree</span>(root-&gt;right, vec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">preTree</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="迭代法">迭代法</h4><p>注意栈先入先出的特性对入栈顺序的影响 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* rt = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(rt-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(rt-&gt;right)st.<span class="built_in">push</span>(rt-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(rt-&gt;left)st.<span class="built_in">push</span>(rt-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的后序遍历">145.二叉树的后序遍历</h3><h4 id="递归法-1">递归法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postTree</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">postTree</span>(root-&gt;left, vec);</span><br><span class="line">        <span class="built_in">postTree</span>(root-&gt;right, vec);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">postTree</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="迭代法-1">迭代法</h4><p>注意栈先入先出的特性对入栈顺序的影响 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            TreeNode* cur = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;left)st.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)st.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="二叉树的中序遍历">94.二叉树的中序遍历</h3><h4 id="递归法-2">递归法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inTree</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; vec)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(!root)<span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">inTree</span>(root-&gt;left, vec);</span><br><span class="line">            vec.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">inTree</span>(root-&gt;right, vec);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">inTree</span>(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="迭代法-2">迭代法</h4><p>写答案的时候一直在想，因为想处理左子树方便，我想stack里面初始没有node，这样该如何定义while的初始条件？看了题解发现可以<code>while (cur != nullptr || !NodeStack.empty())</code>（但是还是写了麻烦的写法）<br />一直没想明白递归到弹出第一个左叶子之后如何避免在弹出中间节点时再把左叶子压栈，看了题解发现<code>cur = cur-&gt;right;</code>此时cur为空指针，直接跳过下一个while即可<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; NodeStack;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(!root)<span class="keyword">return</span> result;</span><br><span class="line">        NodeStack.<span class="built_in">push</span>(root);</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">while</span>(!NodeStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur &amp;&amp; cur-&gt;left != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">                NodeStack.<span class="built_in">push</span>(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = NodeStack.<span class="built_in">top</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">            NodeStack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right)&#123;</span><br><span class="line">                NodeStack.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;二叉树的前序遍历&quot;&gt;144.二叉树的前序遍历&lt;/h3&gt;
&lt;h4 id=&quot;递归法&quot;&gt;递归法&lt;/h4&gt;
&lt;p&gt;注意边界条件，root为空指针时不再向下迭代叶子节点 &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-栈与队列2</title>
    <link href="https://mackz-maxw.github.io/2025/05/24/kamacode10/"/>
    <id>https://mackz-maxw.github.io/2025/05/24/kamacode10/</id>
    <published>2025-05-24T22:15:57.037Z</published>
    <updated>2025-05-24T22:15:43.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="逆波兰表达式求值">150. 逆波兰表达式求值</h3><p>细节很重要，注意数字可能有多位，有负数；数学表达式操作前后数字顺序影响结果<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(string ss: tokens)&#123;</span><br><span class="line">            <span class="type">char</span> ssEnd = ss[ss.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(ssEnd &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; ssEnd &gt;= <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> times = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(!ss.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ss[ss.<span class="built_in">size</span>()<span class="number">-1</span>] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                        val = <span class="number">0</span> - val;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="type">int</span> n = (ss[ss.<span class="built_in">size</span>()<span class="number">-1</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                        val += n * times;</span><br><span class="line">                        times = times * <span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ss.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> n1 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> n2 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> opVal = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(ssEnd == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                    opVal = n2 + n1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ssEnd == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                    opVal = n2 - n1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ssEnd == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    opVal = n2 * n1;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    opVal = n2 / n1;</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(opVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="滑动窗口最大值">239. 滑动窗口最大值</h3><p>注意单调栈判断条件；top查询应在代码逻辑最后 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; val &gt; dq.<span class="built_in">back</span>())&#123;</span><br><span class="line">            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.<span class="built_in">push_back</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() == val)&#123;</span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dq.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue mq;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; maxWin;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; <span class="built_in">i</span>&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            mq.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;(k<span class="number">-1</span>))&#123;</span><br><span class="line">                mq.<span class="built_in">pop</span>(nums[i-k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=(k<span class="number">-1</span>))&#123;</span><br><span class="line">                maxWin.<span class="built_in">push_back</span>(mq.<span class="built_in">top</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxWin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="前-k-个高频元素">347.前 K 个高频元素</h3><p>注意operator()一定要是public的，因为小顶堆每次弹出堆顶最小元素所以最后要逆序填入vector<br />为什么priority_queue第三个参数要传入一个类？priority_queue只需要知道这个类的类型（模板参数），它会自己构造一个比较器对象myCompcomp 来比较元素 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">myComp</span>&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp;rhs)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second;<span class="comment">// 插入元素判断为true时走入叶子节点，所以是小顶堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n:nums)&#123;</span><br><span class="line">            mp[n]++;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, myComp&gt; priQue;</span><br><span class="line">        <span class="keyword">for</span>(unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator p = mp.<span class="built_in">begin</span>();p!=mp.<span class="built_in">end</span>();p++)&#123;</span><br><span class="line">            priQue.<span class="built_in">push</span>(*p);</span><br><span class="line">            <span class="keyword">if</span>(priQue.<span class="built_in">size</span>()&gt;k)priQue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            res[i] = priQue.<span class="built_in">top</span>().first;</span><br><span class="line">            priQue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;逆波兰表达式求值&quot;&gt;150. 逆波兰表达式求值&lt;/h3&gt;
&lt;p&gt;细节很重要，注意数字可能有多位，有负数；数学表达式操作前后数字顺序影响结果
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-栈与队列</title>
    <link href="https://mackz-maxw.github.io/2025/05/22/kamacode9/"/>
    <id>https://mackz-maxw.github.io/2025/05/22/kamacode9/</id>
    <published>2025-05-22T21:28:26.144Z</published>
    <updated>2025-05-22T19:47:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用栈实现队列">232.用栈实现队列</h3><p>我的想法是一旦pop或者peek就把数据导到输出栈，输出后再一个一个push回去。看了题解有更简捷的方式：</p><blockquote><p>在push数据的时候，只要数据放进输入栈就好，但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。最后如何判断队列为空呢？如果进栈和出栈都为空的话，说明模拟的队列为空了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; inStack;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; outStack;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        inStack.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(outStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!inStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                outStack.<span class="built_in">push</span>(inStack.<span class="built_in">top</span>());</span><br><span class="line">                inStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> r = outStack.<span class="built_in">top</span>();</span><br><span class="line">        outStack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        outStack.<span class="built_in">push</span>(r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.<span class="built_in">empty</span>() &amp;&amp; outStack.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="用队列实现栈">225. 用队列实现栈</h3><p>用一个队列实现的方法比较简洁。注意队列和栈两种数据结构的函数用法不一样<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = q.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            s--;</span><br><span class="line">            <span class="type">int</span> a = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> r = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        q.<span class="built_in">push</span>(r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="有效的括号">20. 有效的括号</h3><p>注意一下几种可能遇到的错误情况即可 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; pairP;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                pairP.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span> || c == <span class="string">&#x27;]&#x27;</span> || c == <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pairP.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">char</span> lPair = pairP.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span>( (c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; lPair == <span class="string">&#x27;(&#x27;</span>) || (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; lPair == <span class="string">&#x27;[&#x27;</span>)||(c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; lPair == <span class="string">&#x27;&#123;&#x27;</span>))&#123;</span><br><span class="line">                    pairP.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!pairP.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="删除字符串中的所有相邻重复项">1047.删除字符串中的所有相邻重复项</h3><p>有了前面的经验，这一题就相对简单了 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; adjStack;</span><br><span class="line">        string r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!adjStack.<span class="built_in">empty</span>() &amp;&amp; adjStack.<span class="built_in">top</span>() == c)&#123;</span><br><span class="line">                adjStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                adjStack.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!adjStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c = adjStack.<span class="built_in">top</span>();</span><br><span class="line">            adjStack.<span class="built_in">pop</span>();</span><br><span class="line">            r.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r.<span class="built_in">empty</span>())<span class="keyword">return</span> r;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = r.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">char</span> e = r[left];</span><br><span class="line">            r[left] = r[right];</span><br><span class="line">            r[right] = e;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;用栈实现队列&quot;&gt;232.用栈实现队列&lt;/h3&gt;
&lt;p&gt;我的想法是一旦pop或者peek就把数据导到输出栈，输出后再一个一个push回去。看了题解有更简捷的方式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在push数据的时候，只要数据放进输入栈就好，但在pop</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-字符串2</title>
    <link href="https://mackz-maxw.github.io/2025/05/22/kamacode8/"/>
    <id>https://mackz-maxw.github.io/2025/05/22/kamacode8/</id>
    <published>2025-05-22T21:28:25.904Z</published>
    <updated>2025-05-21T22:39:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="翻转字符串里的单词">151.翻转字符串里的单词</h3><p>需要注意反转的过程，不能想当然 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rev</span><span class="params">(<span class="type">char</span>* left, <span class="type">char</span>* right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> c = *left;</span><br><span class="line">            *left = *right;</span><br><span class="line">            *right = c;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ss;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;&quot;s[i]:&quot;&lt;&lt;s[i]&lt;&lt;endl;</span></span><br><span class="line">                ss.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ss.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="built_in">rev</span>(&amp;ss[<span class="number">0</span>], &amp;ss[ss.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">                    res.<span class="built_in">append</span>(ss);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                    ss = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ss.<span class="built_in">empty</span>() &amp;&amp; ss[ss.<span class="built_in">size</span>()<span class="number">-1</span>] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">rev</span>(&amp;ss[<span class="number">0</span>], &amp;ss[ss.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">            res.<span class="built_in">append</span>(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res[res.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)res.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="卡码网55.右旋转字符串">卡码网：55.右旋转字符串</h3><p>一步一步输出看结果，总算是做对了 贴一下题目：</p><blockquote><p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串s 和一个正整数 k，请编写一个函数，将字符串中的后面 k个字符移到字符串的前面，实现字符串的右旋转操作。<br />例如，对于输入字符串 "abcdefg" 和整数 2，函数应该将其转换为"fgabcde"。<br />输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串s，代表需要旋转的字符串。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    string s;</span><br><span class="line">    cin.<span class="built_in">ignore</span>();</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;k:&quot;&lt;&lt;k&lt;&lt;&quot; s:&quot;&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">    string ss;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = (len - <span class="number">1</span>); i&gt;=(len-k);i--)&#123;</span><br><span class="line">        ss.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">        s.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;ss:&quot;&lt;&lt;ss&lt;&lt;&quot; s:&quot;&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">    <span class="type">char</span>* left = &amp;ss[<span class="number">0</span>];</span><br><span class="line">    <span class="type">char</span>* right = &amp;ss[ss.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">char</span> c = *left;</span><br><span class="line">        *left = *right;</span><br><span class="line">        *right = c;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    ss.<span class="built_in">append</span>(s);</span><br><span class="line">    cout&lt;&lt;ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-strstr">28. 实现 strStr()</h3><p>使用KMP算法求最长相等前后缀的过程，实际上是在：</p><ul><li>后缀指针是外层循环</li><li>若前后缀判断不相等，前缀指针可以一直往前跳跃至上一个判断不相等的位置，直到长度计数归零或者找到相等位置。如果找到相等位置，则参考下一条将计数加一</li><li>重复利用之前已经判断相等的前后缀，如果一直相等，则长度每次都加一</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nextTable, string s)</span></span>&#123;</span><br><span class="line">        nextTable.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j])&#123;</span><br><span class="line">                j = nextTable[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable.<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">        <span class="built_in">getNext</span>(n, needle);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:n)&#123;</span><br><span class="line">            cout&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;haystack.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; haystack[i] != needle[j])&#123;</span><br><span class="line">                j = n[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(haystack[i] == needle[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == needle.<span class="built_in">size</span>() - <span class="number">1</span>)<span class="keyword">return</span> i-j;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="重复的子字符串">459.重复的子字符串</h3><p>关键是数学证明：最长相等前后缀不包含的子串的长度 可以被字符串s的长度整除，那么不包含的子串 就是s的最小重复子串<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nextT;</span><br><span class="line">        nextT.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> j= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; s[i] != s[j])&#123;</span><br><span class="line">                j = nextT[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            nextT.<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k&lt;nextT.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nextT[k] == <span class="number">0</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(nextT.<span class="built_in">back</span>()!=<span class="number">0</span> &amp;&amp; (len % (len - j) == <span class="number">0</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;翻转字符串里的单词&quot;&gt;151.翻转字符串里的单词&lt;/h3&gt;
&lt;p&gt;需要注意反转的过程，不能想当然 &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 八股-网络模型</title>
    <link href="https://mackz-maxw.github.io/2025/05/22/kamabagu1/"/>
    <id>https://mackz-maxw.github.io/2025/05/22/kamabagu1/</id>
    <published>2025-05-22T21:28:25.818Z</published>
    <updated>2025-05-22T20:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="osi-模型和-tcpip-模型">OSI 模型和 TCP/IP 模型</h3><h4 id="osi-模型">OSI 模型</h4><p>开放式系统互联模型 七层 概念框架</p><ul><li>物理层：光纤，电缆等传输信号的物理通道</li><li>数据链路层：通过物理层网络连接两台计算机管理数据帧：封装在数据包中的电子信号 示例：以太网</li><li>网络层：多个互联网络的路由，转发和寻址 示例：IPv4, IPv6</li><li>传输层：传输控制，例如确保数据包以正确的顺序到达 示例：TCP，UDP</li><li>会话层：负责会话中两个独立应用程序之间的网络协调，管理一对一应用程序连接的开始和结束以及同步冲突。网络文件系统（NFS）和服务器消息块（SMB）是会话层的常用协议。</li><li>表示层：主要关注应用程序发送和使用的数据本身的语法。例如，超文本标记语言（HTML）、JavaScript对象标记（JSON）和逗号分隔值（CSV）</li><li>应用层：关注应用程序本身的特定类型及其标准化通信方法。例如，浏览器可以使用超文本传输安全协议（HTTPS）进行通信，而HTTP 和电子邮件客户端可以使用 POP3（邮局协议版本 3）和SMTP（简单邮件传输协议）进行通信。</li></ul><h4 id="tcpip-模型">TCP/IP 模型</h4><p>TCP/IP模型分为四个层级</p><ul><li>网络接口层：该层对应OSI模型的数据链路层和物理层。它负责物理传输媒介的传输，例如以太网、Wi-Fi等，并提供错误检测和纠正的功能。此外，网络接口层还包含硬件地址（MAC地址）的管理。</li><li>网络层：该层对应OSI模型的网络层。主要协议是IP，它负责数据包的路由和转发，选择最佳路径将数据从源主机传输到目标主机。IP协议使用IP地址来标识主机和网络，并进行逻辑地址寻址。<br /></li><li>传输层：对应OSI模型的传输层。服务应用。主要的传输层协议有TCP和UDP。TCP提供可靠的数据传输，确保数据的正确性和完整性；而UDP则是无连接的，适用于不要求可靠性的传输，如实时音频和视频流。</li><li>应用层：对应OSI模型的应用层和表示层以及会话层，面向用户，示例：电子邮件（SMTP）、网页浏览（HTTP）、文件传输（FTP）等。</li></ul><h3 id="从输入-url-到页面展示到底发生了什么">从输入 URL到页面展示到底发生了什么？</h3><ol type="1"><li>输入网址，解析URL信息，准备发送HTTP请求</li><li>检查浏览器缓存里是否有缓存该资源，如果有直接返回；如果没有进入下一步网络请求。</li><li>DNS域名解析：网络请求前，进行DNS解析，以获取请求域名的IP地址。DNS解析时会按本地浏览器缓存-&gt;本地Host文件-&gt;路由器缓存-&gt;DNS服务器-&gt;根DNS服务器的顺序查询域名对应IP，直到找到为止。</li><li>TCP三次握手建立连接：浏览器与服务器IP建立TCP连接。</li><li>客户端发送HTTP请求：连接建立后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，向服务器构建请求信息。如果是HTTPS的话，还涉及到HTTPS的加解密流程。</li><li>服务器处理请求并返回HTTP资源：服务器接收到请求信息，根据请求生成响应数据。</li><li>TCP四次挥手断开连接：浏览器与服务器IP断开TCP连接。</li><li>浏览器解析响应并渲染页面：<ol type="1"><li>浏览器解析响应头。若响应头状态码为301、302，会重定向到新地址；若响应数据类型是字节流类型，一般会将请求提交给下载管理器；若是HTML类型，会进入下一部渲染流程。</li><li>浏览器解析HTML文件，创建DOM树，解析CSS进行样式计算，然后将CSS和DOM合并，构建渲染树；最后布局和绘制渲染树，完成页面展示。</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;osi-模型和-tcpip-模型&quot;&gt;OSI 模型和 TCP/IP 模型&lt;/h3&gt;
&lt;h4 id=&quot;osi-模型&quot;&gt;OSI 模型&lt;/h4&gt;
&lt;p&gt;开放式系统互联模型 七层 概念框架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物理层：光纤，电缆等传输信号的物理通道&lt;/li&gt;</summary>
      
    
    
    
    <category term="comp basic" scheme="https://mackz-maxw.github.io/categories/comp-basic/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-字符串</title>
    <link href="https://mackz-maxw.github.io/2025/05/21/kamacode7/"/>
    <id>https://mackz-maxw.github.io/2025/05/21/kamacode7/</id>
    <published>2025-05-21T14:18:29.572Z</published>
    <updated>2025-05-21T14:28:50.842Z</updated>
    
    <content type="html"><![CDATA[<h3 id="反转字符串">344.反转字符串</h3><p>双指针法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h = s.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;h;i++)&#123;</span><br><span class="line">            <span class="type">char</span> c = s[i];</span><br><span class="line">            s[i] = s[j];</span><br><span class="line">            s[j] = c;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="反转字符串ii">541. 反转字符串II</h3><p>主要还是注意语法的学习 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rev</span><span class="params">(<span class="type">char</span>* left, <span class="type">char</span>* right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> c = *left;</span><br><span class="line">            *left = *right;</span><br><span class="line">            *right = c;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> end = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p&lt;end)&#123;</span><br><span class="line">            n = p + k - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(n &lt;= end)&#123;</span><br><span class="line">                <span class="built_in">rev</span>(&amp;s[p], &amp;s[n]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">rev</span>(&amp;s[p], &amp;s[end]);</span><br><span class="line">            &#125;</span><br><span class="line">            p = p+ <span class="number">2</span>* k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="卡码网54.替换数字">卡码网：54.替换数字</h3><p>题目描述：</p><blockquote><p>给定一个字符串s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。<br />例如，对于输入字符串 "a1b2c3"，函数应该将其转换为"anumberbnumbercnumber"。<br />对于输入字符串 "a5b"，函数应该将其转换为 "anumberb"<br />输入：一个字符串 s,s 仅包含小写字母和数字字符。<br />输出：打印一个新的字符串，其中每个数字字符都被替换为了number<br />样例输入：a1b2c3<br />样例输出：anumberbnumbercnumber<br />数据范围：1 &lt;= s.length &lt; 10000</p></blockquote><p>主要是学习字符串输入输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string line, s;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: line)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            s.<span class="built_in">append</span>(<span class="string">&quot;number&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;反转字符串&quot;&gt;344.反转字符串&lt;/h3&gt;
&lt;p&gt;双指针法 &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-哈希表2</title>
    <link href="https://mackz-maxw.github.io/2025/05/21/kamacode6/"/>
    <id>https://mackz-maxw.github.io/2025/05/21/kamacode6/</id>
    <published>2025-05-21T14:18:29.399Z</published>
    <updated>2025-05-21T14:27:36.904Z</updated>
    
    <content type="html"><![CDATA[<h3 id="四数相加ii">454. 四数相加II</h3><p>这道题目我没什么思路，看了题解是两组两组遍历，存储和的值和出现次数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a: nums1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b: nums2)&#123;</span><br><span class="line">                m1[a+b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c: nums3)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> d: nums4)&#123;</span><br><span class="line">                <span class="type">int</span> r = <span class="number">0</span>-(c+d);</span><br><span class="line">                <span class="keyword">if</span>(m1.<span class="built_in">find</span>(r) != m1.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    count += m1[r];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="赎金信">383. 赎金信</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: magazine)&#123;</span><br><span class="line">            m[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> cr: ransomNote)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(cr) == m.<span class="built_in">end</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            m[cr]--;</span><br><span class="line">            <span class="keyword">if</span>(m[cr]&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="三数之和">15. 三数之和</h3><p>这题我的思路可能就是暴力解了，看了题解发现可以在for循环里同时利用下标和双指针来解决<br />一开始想用set解决去重的问题，但是发现不排序的话去重还是有问题这题的去重套路，初始化等要注意的地方还是很多的，这一遍刷题我也只是照着题解的意思敲了一遍，以后还是得多加练习<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 遍历到第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，可以剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)<span class="keyword">return</span> v;</span><br><span class="line">            <span class="type">int</span> left = i+<span class="number">1</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 错误去重第一个数方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    v.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>])&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums [right<span class="number">-1</span>])&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果判断找到答案，双指针同时收缩</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//否则单向收缩</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="四数之和">18. 四数之和</h3><p>还是看题解：</p><blockquote><p>四数之和的双指针解法是两层for循环<code>nums[k] + nums[i]</code>为确定值，依然是循环内有left和right下标作为双指针，找出<code>nums[k] + nums[i] + nums[left] + nums[right] == target</code>的情况，三数之和的时间复杂度是<span class="math inline">\(O(n^2)\)</span> ，四数之和的时间复杂度是<span class="math inline">\(O(n^3)\)</span><br />那么一样的道理，五数之和、六数之和等等都采用这种解法。<br />对于15.三数之和双指针法就是将原本暴力 <spanclass="math inline">\(O(n^3)\)</span> 的解法，降为 <spanclass="math inline">\(O(n^2)\)</span>的解法，四数之和的双指针解法就是将原本暴力 <spanclass="math inline">\(O(n^4)\)</span> 的解法，降为 <spanclass="math inline">\(O(n^3)\)</span> 的解法</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">4</span>)<span class="keyword">return</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt; target)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>] == nums[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = (i+<span class="number">1</span>);j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="comment">// 第二级剪枝和去重，注意表达式变化</span></span><br><span class="line">                <span class="keyword">if</span>((nums[i] + nums[j])&gt;=<span class="number">0</span> &amp;&amp;(nums[i] + nums[j])&gt;target)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;(i+<span class="number">1</span>) &amp;&amp; nums[j<span class="number">-1</span>] == nums[j])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> left = j+<span class="number">1</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="type">long</span> sum = (<span class="type">long</span>)nums[i]+nums[j]+nums[left]+nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                        v.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[left],nums[right]&#125;);</span><br><span class="line">                        <span class="comment">//先去重，再移动指针到下一个判定位置</span></span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>])left++;</span><br><span class="line">                        <span class="keyword">while</span>(right&gt;left &amp;&amp; nums[right] == nums[right<span class="number">-1</span>])right--;</span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;四数相加ii&quot;&gt;454. 四数相加II&lt;/h3&gt;
&lt;p&gt;这道题目我没什么思路，看了题解是两组两组遍历，存储和的值和出现次数
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-哈希表</title>
    <link href="https://mackz-maxw.github.io/2025/05/21/kamacode5/"/>
    <id>https://mackz-maxw.github.io/2025/05/21/kamacode5/</id>
    <published>2025-05-21T14:18:29.183Z</published>
    <updated>2025-05-21T14:19:56.454Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据结构">数据结构</h3><p>在C++中，set 和 map分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><table style="width:100%;"><colgroup><col style="width: 13%" /><col style="width: 13%" /><col style="width: 18%" /><col style="width: 13%" /><col style="width: 13%" /><col style="width: 13%" /><col style="width: 13%" /></colgroup><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><table style="width:100%;"><colgroup><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /></colgroup><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的</p><h3 id="有效的字母异位词">242.有效的字母异位词</h3><p>基本上都是语法问题了，比如<code>m[c]</code>自动初始化（int则为0），pair的first和second都是成员变量<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: s)&#123;</span><br><span class="line">            m[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!m[c])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            m[c]--;</span><br><span class="line">            <span class="keyword">if</span>(m[c]&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; p: m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.second&gt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 349. 两个数组的交集</p><p>绞尽脑汁想半天如果结果有重复数字怎么办，结果是去重的。。。以后看题要更仔细呀！<br />题解里使用set的特性去重也挺巧思的 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">m</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(n)!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                r.<span class="built_in">insert</span>(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(r.<span class="built_in">begin</span>(),r.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 202. 快乐数</p><p>思路差不多了，还是有代码实现的问题，例如<code>to_string(int)</code>的用法,如何char转int等<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums.<span class="built_in">find</span>(n) == nums.<span class="built_in">end</span>())&#123;</span><br><span class="line">            nums.<span class="built_in">insert</span>(n);</span><br><span class="line">            string s = <span class="built_in">to_string</span>(n);</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">                <span class="type">int</span> num = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                sum += num*num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 1. 两数之和</p><p>看到题目例子的时候我就觉得数组如果有两个一样的值，用哈希表就比较麻烦。先存数组所有值再判断会出现索引相等的问题。使用一个循环，先判断是否已有互补值，再存当前值进map，可以避免配对同一个元素<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> v = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(v) != m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                r.<span class="built_in">push_back</span>(i);</span><br><span class="line">                r.<span class="built_in">push_back</span>(m[v]);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据结构&quot;&gt;数据结构&lt;/h3&gt;
&lt;p&gt;在C++中，set 和 map
分别提供以下三种数据结构，其底层实现以及优劣如下表所示：&lt;/p&gt;
&lt;table style=&quot;width:100%;&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 1</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-链表2</title>
    <link href="https://mackz-maxw.github.io/2025/05/16/kamacode4/"/>
    <id>https://mackz-maxw.github.io/2025/05/16/kamacode4/</id>
    <published>2025-05-16T15:56:32.183Z</published>
    <updated>2025-05-21T14:19:39.287Z</updated>
    
    <content type="html"><![CDATA[<h3 id="两两交换链表中的节点">24. 两两交换链表中的节点</h3><p>翻转链表加强版 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode* d = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">        ListNode* n = <span class="built_in">swapPairs</span>(head-&gt;next-&gt;next);</span><br><span class="line">        ListNode* r_pair = head-&gt;next;</span><br><span class="line">        d-&gt;next = r_pair;</span><br><span class="line">        r_pair-&gt;next = head;</span><br><span class="line">        head-&gt;next = n;</span><br><span class="line">        <span class="keyword">return</span> d-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 19.删除链表的倒数第N个节点</p><p>还是那个当整个链表删除时不能直接返回head的问题，多复制几个dummyhead就好了 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">        ListNode* d = dummy;</span><br><span class="line">        ListNode* d2 = dummy;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;next)&#123;</span><br><span class="line">            d = d-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;len: &quot;</span>&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">        <span class="type">int</span> rm = len - n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(rm&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;rm: &quot;</span>&lt;&lt;rm&lt;&lt;<span class="string">&quot;d2 val&quot;</span>&lt;&lt;d2-&gt;val&lt;&lt;endl;</span><br><span class="line">            d2 = d2-&gt;next;</span><br><span class="line">            rm--;</span><br><span class="line">        &#125;</span><br><span class="line">        d2-&gt;next = d2-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 面试题 02.07. 链表相交 (leetcode 160)</p><p>本来想着可能需要挨个遍历节点是否相等找到相交节点，看了题解发现可以从共同长度同时往后搜索<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* cur_a = headA;</span><br><span class="line">        ListNode* cur_b = headB;</span><br><span class="line">        <span class="type">int</span> len_a = <span class="number">0</span>, len_b = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur_a)&#123;</span><br><span class="line">            len_a++;</span><br><span class="line">            cur_a = cur_a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur_b)&#123;</span><br><span class="line">            len_b++;</span><br><span class="line">            cur_b = cur_b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_a = headA;</span><br><span class="line">        cur_b = headB;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;len_a:&quot;</span>&lt;&lt;len_a&lt;&lt;<span class="string">&quot;len_b&quot;</span>&lt;&lt;len_b&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(len_a &gt; len_b)&#123;</span><br><span class="line">            e = len_a - len_b;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;e:&quot;</span>&lt;&lt;e&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">while</span>(e&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                e--;</span><br><span class="line">                cur_a = cur_a-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            e = len_b - len_a;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;e:&quot;</span>&lt;&lt;e&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">while</span>(e&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                e--;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;whiling&quot;</span>&lt;&lt;endl;</span><br><span class="line">                cur_b = cur_b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;caval:&quot;</span>&lt;&lt;cur_a-&gt;val&lt;&lt;<span class="string">&quot;cbval:&quot;</span>&lt;&lt;cur_b-&gt;val&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">while</span>(cur_a || cur_b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur_a == cur_b)<span class="keyword">return</span> cur_a;</span><br><span class="line">            cur_a = cur_a-&gt;next;</span><br><span class="line">            cur_b = cur_b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 142.环形链表II</p><p>模糊记得俩指针相遇的地方有一些特性，还是得确定地记下来：从头结点出发一个指针，从相遇节点也出发一个指针，这两个指针每次只走一个节点，那么当这两个指针相遇的时候就是 环形入口的节点。两个指针都从head开始如何避免判断一开始这个点？看题解发现可以循环内先走next再判断,错误的初始化容易错过相遇点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* h = head;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow &amp;&amp; fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                ListNode* b = slow;</span><br><span class="line">                <span class="keyword">while</span>(b != h)&#123;</span><br><span class="line">                    b = b-&gt;next;</span><br><span class="line">                    h = h-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> h;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;两两交换链表中的节点&quot;&gt;24. 两两交换链表中的节点&lt;/h3&gt;
&lt;p&gt;翻转链表加强版 &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-链表</title>
    <link href="https://mackz-maxw.github.io/2025/05/16/kamacode3/"/>
    <id>https://mackz-maxw.github.io/2025/05/16/kamacode3/</id>
    <published>2025-05-16T14:26:06.919Z</published>
    <updated>2025-05-21T14:19:30.186Z</updated>
    
    <content type="html"><![CDATA[<h3 id="移除链表元素">203.移除链表元素</h3><p>这回刷题的思路总算对了，但是一开始直接返回head,没有考虑到万一整个链表全部需要删除，原有的链表相当于没动。设置了dummyhead就解决了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* n = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* dum = n;</span><br><span class="line">        <span class="keyword">while</span>(n &amp;&amp; n-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n-&gt;next-&gt;val == val)&#123;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;&quot;next val eq. cur val: &quot;&lt;&lt;n-&gt;val&lt;&lt;endl;</span></span><br><span class="line">                ListNode* link = n-&gt;next-&gt;next;</span><br><span class="line">                n-&gt;next = link;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                n = n-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 707.设计链表</p><p>设计了一个单链表<br />首先是结构体命名总是写错，应该注意检查这种问题。<br />dummy node 也需要在构造函数外声明才可以在其它函数中调用；<br />然后是尾部插入节点不需要再声明一个尾节点，直接插入即可，定义尾dummycode需要考虑的边界条件太多。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> v): <span class="built_in">val</span>(v),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> v, ListNode* n): <span class="built_in">val</span>(v), <span class="built_in">next</span>(n)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ListNode* dummy;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dummy-&gt;next) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ListNode* d = dummy;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;get ind:&quot;</span>&lt;&lt;index&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(;index&gt;=<span class="number">0</span>;index--)&#123;</span><br><span class="line">            d = d-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!d)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;index:&quot;</span>&lt;&lt;index&lt;&lt;<span class="string">&quot;getfor+1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="comment">// if(d-&gt;val == -1)return -1;</span></span><br><span class="line">        <span class="keyword">return</span> d-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">addAtIndex</span>(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if(dummy-&gt;next)</span></span><br><span class="line">        ListNode* d = dummy;</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;next)&#123;</span><br><span class="line">            d = d-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* d = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = index - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            d = d-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!d)<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if(!d || !d-&gt;next)return;</span></span><br><span class="line">        ListNode* n = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode* link = d-&gt;next;</span><br><span class="line">        d-&gt;next = n;</span><br><span class="line">        n-&gt;next = link;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        ListNode* d = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = index - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            d = d-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!d)<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!d-&gt;next)<span class="keyword">return</span>;</span><br><span class="line">        d-&gt;next = d-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 206.反转链表</p><p>稀里糊涂地写对了...看了题解，发现这种做法相当于从后往前反转列表，结合以前的debug经验推导了一下这段代码会如何运行，有些理解了<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode* n = head-&gt;next;</span><br><span class="line">        ListNode* h = <span class="built_in">reverseList</span>(n);</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        n-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;移除链表元素&quot;&gt;203.移除链表元素&lt;/h3&gt;
&lt;p&gt;这回刷题的思路总算对了，但是一开始直接返回head,没有考虑到万一整个链表全部需要删除，原有的链表相当于没动。设置了dummy
head就解决了。 &lt;figure class=&quot;highlight cpp&quot;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-数组2</title>
    <link href="https://mackz-maxw.github.io/2025/05/14/kamacode2/"/>
    <id>https://mackz-maxw.github.io/2025/05/14/kamacode2/</id>
    <published>2025-05-14T18:46:08.756Z</published>
    <updated>2025-05-21T14:19:21.715Z</updated>
    
    <content type="html"><![CDATA[<h3 id="长度最小的子数组">209.长度最小的子数组</h3><p>不看题解的时候我的想法是在一个大循环里使用三个循环，先移动两个指针里右边指针的位置到和大于等于target，然后移动左指针到小于等于target,再开始移动右边指针。看了题解了解到可以在两个循环里操作两个指针完成上述操作，避免到处找边界条件。实际写的时候还是犯了一些小错误，例如sum的累加初始值，sum应该在何时减少等等，今后在更改代码的时候还是要注意细节。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>, k = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(;right&lt;nums.<span class="built_in">size</span>();right++)&#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                len = right - left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(len &lt; k)k = len;</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// printf(&quot;left: %d, right: %d, len: %d, k:%d\n&quot;, left, right,len, k);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k == INT_MAX ? <span class="number">0</span> : k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 59.螺旋矩阵II</p><p>看到这道题目我的第一想法是整理出移动方向和当前数字所在位置i，j的关系。尝试写了一下感觉太复杂了，看了题解发现是每圈一次循环，每次循环处理四条边自己尝试着写了一下发现被每次循环加减的边界绕进去了，还是题解的方式比较清晰。题解强调的区间问题也要注意，不仅仅是每条边的循环条件，每次循环终止如何过渡到下次循环开始也是问题。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; mat;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">            mat.<span class="built_in">push_back</span>(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>, p = <span class="number">1</span>, c = n / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>, offset = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(c--)&#123;</span><br><span class="line">            row = starty;</span><br><span class="line">            col = startx;</span><br><span class="line">            <span class="keyword">for</span>(;col&lt;(n-offset);col++)&#123;</span><br><span class="line">                mat[row][col] = p;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;row&lt;(n-offset);row++)&#123;</span><br><span class="line">                mat[row][col] = p;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;col&gt;startx;col--)&#123;</span><br><span class="line">                mat[row][col] = p;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;row&gt;starty;row--)&#123;</span><br><span class="line">                mat[row][col] = p;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)mat[n/<span class="number">2</span>][n/<span class="number">2</span>] = p;</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;长度最小的子数组&quot;&gt;209.长度最小的子数组&lt;/h3&gt;
&lt;p&gt;不看题解的时候我的想法是在一个大循环里使用三个循环，先移动两个指针里右边指针的位置到和大于等于target，然后移动左指针到小于等于target,再开始移动右边指针。看了题解了解到可以在两个循环里操作</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-数组</title>
    <link href="https://mackz-maxw.github.io/2025/05/13/kamacode1/"/>
    <id>https://mackz-maxw.github.io/2025/05/13/kamacode1/</id>
    <published>2025-05-14T03:19:17.104Z</published>
    <updated>2025-05-21T14:19:17.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组基础与算法实现">数组基础与算法实现</h1><h2 id="数组基本特性">数组基本特性</h2><ul><li>数组下标从0开始</li><li>数组内存空间的地址是连续的</li><li>在C++中，二维数组在内存的空间地址是连续的</li></ul><h2 id="c常见数据类型长度">C++常见数据类型长度</h2><table><colgroup><col style="width: 17%" /><col style="width: 37%" /><col style="width: 44%" /></colgroup><thead><tr><th>数据类型</th><th>长度（字节）</th><th>备注</th></tr></thead><tbody><tr><td>char</td><td>1</td><td></td></tr><tr><td>short</td><td>2</td><td></td></tr><tr><td>int</td><td>4</td><td></td></tr><tr><td>long</td><td>4或8</td><td>取决于编译器和操作系统</td></tr><tr><td>long long</td><td>8</td><td></td></tr><tr><td>float</td><td>4</td><td></td></tr><tr><td>double</td><td>8</td><td></td></tr><tr><td>long double</td><td>8或16</td><td>取决于编译器和操作系统</td></tr><tr><td>bool</td><td>1</td><td>实际只使用1位</td></tr><tr><td>指针类型</td><td>4或8</td><td>取决于编译器和操作系统</td></tr></tbody></table><h2 id="算法实现">算法实现</h2><h3 id="二分查找">704. 二分查找</h3><h4 id="左闭右闭区间实现">左闭右闭区间实现</h4><p>原本仅判断left ==right，后来发现在处理仅两个元素，且target小于最小元素的数组时，这样写会导致left= 0同时right= -1,陷入死循环，更改判断条件后就解决了 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchid</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>, target, nums);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchid</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchid</span>(left, mid - <span class="number">1</span>, target, nums);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchid</span>(mid + <span class="number">1</span>, right, target, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="左闭右开区间实现">左闭右开区间实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchid</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>(), target, nums);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchid</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchid</span>(left, mid, target, nums);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchid</span>(mid + <span class="number">1</span>, right, target, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="移除元素">27. 移除元素</h3><p>当target小于所有数时，right不断左移，left不变等于0，刚好结果应该是0。当target大于所有数时，right不会动，left不断右移直到nums.length，刚好等于结果。所以未找到时应返回left</p><p>我的方法从数组的两端向中间遍历，虽然也是双指针方法，但是需要不少额外判断。下一次要定义快慢指针去解题，因为实际上不用把所有查找的元素移动到数组最后，所以直接跳过这些元素复制即可：快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组慢指针：指向更新 新数组下标的位置 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[left] != val &amp;&amp; left &lt; right) left++;</span><br><span class="line">            <span class="keyword">while</span>(nums[left] == val &amp;&amp; left &lt; right) &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right] = val;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] != val) <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="number">0</span> ? <span class="number">0</span> : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="有序数组的平方">977. 有序数组的平方</h3><p>这题我一开始总是想着在原数组中修改，于是想不出什么来。看了题解是新开一个数组，再左右指针遍历原数组，思路正确很快就做出来了：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> res_p = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(res_p &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[left]) &lt; <span class="built_in">abs</span>(nums[right])) &#123;</span><br><span class="line">                res[res_p] = <span class="built_in">pow</span>(nums[right], <span class="number">2</span>);</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[res_p] = <span class="built_in">pow</span>(nums[left], <span class="number">2</span>);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            res_p--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="c常用数学函数">C++常用数学函数</h2><ul><li><code>pow(x, y)</code>：计算x的y次方</li><li><code>sqrt(x)</code>：计算平方根</li><li><code>abs(x)</code>：计算绝对值</li><li><code>ceil(x)</code>：向上取整</li><li><code>floor(x)</code>：向下取整</li><li><code>round(x)</code>：四舍五入</li><li><code>max(x, y)</code>/<code>min(x, y)</code>：返回较大/较小值</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组基础与算法实现&quot;&gt;数组基础与算法实现&lt;/h1&gt;
&lt;h2 id=&quot;数组基本特性&quot;&gt;数组基本特性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;数组下标从0开始&lt;/li&gt;
&lt;li&gt;数组内存空间的地址是连续的&lt;/li&gt;
&lt;li&gt;在C++中，二维数组在内存的空间地址是连续的&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>algorithm1-en</title>
    <link href="https://mackz-maxw.github.io/2025/01/21/algorithm1-en/"/>
    <id>https://mackz-maxw.github.io/2025/01/21/algorithm1-en/</id>
    <published>2025-01-21T12:36:03.000Z</published>
    <updated>2025-01-22T02:49:27.636Z</updated>
    
    <content type="html"><![CDATA[<p>I've been working on LeetCode problems for almost a week now, and Ifeel like my progress with algorithms is pretty slow—managing just oneor two problems a day seems like my limit.</p><p>I'm focusing on problems from the "Beginner Algorithms" section onLeetCode. Sometimes, I feel my memory is terrible; I realized I hadencountered some of these problems before in an introductory algorithmsbook but couldn't recall the solutions. I ended up solving them with themost inefficient methods...</p><p>I can foresee that learning techniques like two-pointers will takesome getting used to. It's tough! But I'll take it one step at atime.</p><p>(All problems below are from LeetCode's official website.)</p><h2 id="section">2/25-3/1</h2><h3 id="lc26.-remove-duplicates-from-sorted-array">LC26. RemoveDuplicates from Sorted Array</h3><p>You are given an array <code>nums</code> sorted in non-decreasingorder. Remove the duplicates in-place such that each unique elementappears only once. The relative order of the elements should be kept thesame. After removing the duplicates, return the new length of thearray.</p><p>Since some languages cannot change the size of the array, the finalresult must be placed in the first part of the array <code>nums</code>.More formally, if there are <code>k</code> elements after removing theduplicates, then the first <code>k</code> elements of <code>nums</code>should hold the final result.</p><p>Do not allocate extra space for another array. You must do this bymodifying the input array in-place with <spanclass="math inline">\(O(1)\)</span> extra memory.</p><p><span class="math display">\[\begin{aligned}&amp;\text{class Solution \{} \\&amp;\quad \text{public:} \\&amp;\quad \quad \text{int removeDuplicates(vector&lt;int&gt;\&amp;nums) \{} \\&amp;\quad \quad \quad \text{int a = 0;} \\&amp;\quad \quad \quad \text{int b = nums.size();} \\&amp;\quad \quad \quad \text{if (b &lt;= 1) return b;} \\&amp;\quad \quad \quad \text{for (int i = 0; i &lt; (b - 1); i++) \{} \\&amp;\quad \quad \quad \quad \text{if (nums[i] != nums[i + 1]) \{} \\&amp;\quad \quad \quad \quad \quad \text{nums[a] = nums[i];} \\&amp;\quad \quad \quad \quad \quad \text{a++;} \\&amp;\quad \quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{nums[a] = nums[b - 1];} \\&amp;\quad \quad \quad \text{return a + 1;} \\&amp;\quad \quad \text{\}} \\&amp;\text{\};}\end{aligned}\]</span></p><p>Here, I learned (again) about the two-pointer technique and refreshedmy long-unused C++ knowledge. I chose C++ mainly because many of thealgorithm and OpenCV books I previously studied use C++. Although I'veheard C++ interviews focus heavily on language features, it feels moresuitable than Python for understanding internal mechanisms. Python seemsto hide a lot of details, which might not be ideal for my coding stylelater.</p><p>This problem was manageable, but for problems involving in-placemodifications, it's essential to use<code>vector&lt;int&gt;&amp; nums</code> to pass by reference.</p><p>While solving this, I realized I had forgotten basic functions like<code>.size()</code>, <code>memset()</code>, and <code>.length()</code>.Sigh.</p><hr /><h3 id="lc122.-best-time-to-buy-and-sell-stock-ii">LC122. Best Time toBuy and Sell Stock II</h3><p>You are given an array <code>prices</code> where<code>prices[i]</code> is the price of a given stock on the<code>i</code>th day.</p><p>On each day, you may decide to buy and/or sell the stock. You canhold at most one share of the stock at any time. However, you can buy itand then sell it on the same day. Return the maximum profit you canachieve.</p><p><span class="math display">\[\begin{aligned}&amp;\text{class Solution \{} \\&amp;\quad \text{public:} \\&amp;\quad \quad \text{int maxProfit(vector&lt;int&gt;\&amp; prices) \{}\\&amp;\quad \quad \quad \text{int day = 0;} \\&amp;\quad \quad \quad \text{int count = 0;} \\&amp;\quad \quad \quad \text{bool st = false;} \\&amp;\quad \quad \quad \text{if (prices.size() == 1) return 0;} \\&amp;\quad \quad \quad \text{for (int i = 0; i &lt; prices.size() - 1;i++) \{} \\&amp;\quad \quad \quad \quad \text{if (prices[i] &lt; prices[i + 1]&amp;&amp; st == false) \{} \\&amp;\quad \quad \quad \quad \quad \text{day = i; st = true;} \\&amp;\quad \quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \quad \text{if (prices[i] &gt; prices[i + 1]&amp;&amp; st == true) \{} \\&amp;\quad \quad \quad \quad \quad \text{count += prices[i] -prices[day]; st = false;} \\&amp;\quad \quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{return count;} \\&amp;\quad \quad \text{\}} \\&amp;\text{\};}\end{aligned}\]</span></p><p>The above solution attempts to track local minima and maxima but ledto overly complex <code>if</code> conditions. A simpler approach issumming positive differences between consecutive days:</p><p><span class="math display">\[\begin{aligned}&amp;\text{class Solution \{} \\&amp;\quad \text{public:} \\&amp;\quad \quad \text{int maxProfit(vector&lt;int&gt;\&amp; prices) \{}\\&amp;\quad \quad \quad \text{int pf = 0;} \\&amp;\quad \quad \quad \text{for (int i = 0; i &lt; prices.size() - 1;i++) \{} \\&amp;\quad \quad \quad \quad \text{if (prices[i] &lt; prices[i + 1]) \{}\\&amp;\quad \quad \quad \quad \quad \text{pf += prices[i + 1] -prices[i];} \\&amp;\quad \quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{return pf;} \\&amp;\quad \quad \text{\}} \\&amp;\text{\};}\end{aligned}\]</span></p><p>This solution is concise and easier to understand, summing up profitswhenever prices go up.</p><hr /><h3 id="lc48.-rotate-image">LC48. Rotate Image</h3><p>You are given an <span class="math inline">\(n \times n\)</span> 2Dmatrix representing an image. Rotate the image by 90 degreesclockwise.</p><p><span class="math display">\[\begin{aligned}&amp;\text{class Solution \{} \\&amp;\quad \text{public:} \\&amp;\quad \quad \text{void rotate(vector&lt;vector&lt;int&gt;&gt;\&amp;matrix) \{} \\&amp;\quad \quad \quad \text{int n = matrix.size();} \\&amp;\quad \quad \quad \text{for (int i = 0; i &lt; n; i++) \{} \\&amp;\quad \quad \quad \quad \text{for (int j = i; j &lt; n; j++) \{} \\&amp;\quad \quad \quad \quad \quad \text{swap(matrix[i][j],matrix[j][i]);} \\&amp;\quad \quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{for (auto\&amp; row : matrix) \{reverse(row.begin(), row.end()); \}} \\&amp;\quad \quad \text{\}} \\&amp;\text{\};}\end{aligned}\]</span></p><p>First, transpose the matrix, then reverse each row to achieve the90-degree rotation.</p><p>After solving the problem using the approach of transposing thematrix followed by reversing the rows, I thought of an alternative way:reversing the rows first and then transposing the matrix.</p><p>This approach also works effectively and provides the same result.Here's how it looks:</p><p><span class="math display">\[\begin{aligned}&amp;\text{class Solution \{} \\&amp;\quad \text{public:} \\&amp;\quad \quad \text{void rotate(vector&lt;vector&lt;int&gt;&gt;\&amp;matrix) \{} \\&amp;\quad \quad \quad \text{reverse(matrix.begin(), matrix.end());} \\&amp;\quad \quad \quad \text{for (int i = 0; i &lt; matrix.size(); i++)\{} \\&amp;\quad \quad \quad \quad \text{for (int j = i; j &lt;matrix[i].size(); j++) \{} \\&amp;\quad \quad \quad \quad \quad \text{swap(matrix[i][j],matrix[j][i]);} \\&amp;\quad \quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{\}} \\&amp;\quad \quad \text{\}} \\&amp;\text{\};}\end{aligned}\]</span></p><p>This version simplifies the triangle iteration by starting the innerloop at <code>j = i</code>. It reduces the code's complexity whilemaintaining clarity. However, I noticed that the memory usage wasslightly higher compared to my earlier implementation where I explicitlymanaged the triangular region with an additional variable. Toinvestigate further, I experimented with both versions on LeetCode'ssubmission platform. Interestingly, I found that memory usage sometimesfluctuated slightly for reasons I couldn't fully understand, possiblydue to internal optimizations in the runtime environment.</p><p>Ultimately, both methods provide the correct result, and the choicedepends on your preference for readability versus strict memorymanagement.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;I&#39;ve been working on LeetCode problems for almost a week now, and I
feel like my progress with algorithms is pretty slow—managing just o</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>fed_sched_int</title>
    <link href="https://mackz-maxw.github.io/2025/01/20/fed-sched-int/"/>
    <id>https://mackz-maxw.github.io/2025/01/20/fed-sched-int/</id>
    <published>2025-01-20T14:45:29.000Z</published>
    <updated>2025-01-22T02:30:04.079Z</updated>
    
    <content type="html"><![CDATA[<p>摘录一下Marion的论文要点，方便查阅</p><hr /><h3 id="任务模型">任务模型</h3><p>每个任务 <span class="math inline">\(\tau_i\)</span> 由一组子任务<span class="math inline">\(\tau_{i,j}\)</span>组成，并在其间具有优先关系 <spanclass="math inline">\(&lt;\)</span>。每个子任务 <spanclass="math inline">\(\tau_{i,j}\)</span> 的特征为： - 工作量 <spanclass="math inline">\(c_{i,j} \in\mathbb{N}\)</span>，表示其最坏情况下的执行时间。</p><p>子任务必须顺序执行，即它是一组必须按顺序完成的指令的集合，执行时间最长为<spanclass="math inline">\(c_{i,j}\)</span>。假设子任务执行是可重入的：执行可以被其他子任务抢占，且无需在系统中同一个核心上恢复。</p><p>优先关系限制了子任务的执行顺序，例如 <spanclass="math inline">\(\tau_{i,a} &lt; \tau_{i,b}\)</span>，则 <spanclass="math inline">\(\tau_{i,a}\)</span> 必须在 <spanclass="math inline">\(\tau_{i,b}\)</span> 之前完全执行。我们说，当任务<span class="math inline">\(\tau_{i,a}\)</span> 的所有前驱任务 <spanclass="math inline">\(\tau_{i,a&#39;}\)</span> 完成时，<spanclass="math inline">\(\tau_{i,a}\)</span> 变为“可用”（available）。</p><p>根据 [26]，我们将任务分为两类： 1. <strong>轻量任务（lighttasks）</strong>：满足 <span class="math inline">\(C_i &lt;D_i\)</span>； 2. <strong>重量任务（heavy tasks）</strong>：满足 <spanclass="math inline">\(C_i \geqD_i\)</span>，此类任务必须利用其潜在的并行性才能满足调度要求。</p><p>本文的重点是<strong>联合调度</strong>（federatedscheduling），对于每个重量任务，其被分配到一个专用核心集上并独占执行。我们仅考虑截止时间<span class="math inline">\(D_i\)</span> 和子任务工作量 <spanclass="math inline">\(c_{i,j}\)</span>为正整数的任务，称为<strong>整数值任务</strong>（integer-valuedtasks）。</p><hr /><h3 id="优先关系的dag表示">优先关系的DAG表示</h3><p>子任务执行的优先关系可表示为一个<strong>有向无环图（DAG）</strong>。对于每个并行任务<span class="math inline">\(\tau_i\)</span>，存在一个DAG <spanclass="math inline">\(G_i\)</span>，其包含的顶点集合为 <spanclass="math inline">\(v_{i,j}\)</span>，对应于任务 <spanclass="math inline">\(\tau_i\)</span> 的子任务 <spanclass="math inline">\(\tau_{i,j}\)</span>： - 每个顶点 <spanclass="math inline">\(v_{i,j}\)</span> 的属性为子任务的工作量 <spanclass="math inline">\(c_{i,j}\)</span>； - 边 <spanclass="math inline">\(v_{i,a} \to v_{i,b}\)</span> 存在当且仅当 <spanclass="math inline">\(\tau_{i,a} &lt; \tau_{i,b}\)</span> 且不存在 <spanclass="math inline">\(v_{i,c}\)</span> 满足 <spanclass="math inline">\(\tau_{i,a} &lt; \tau_{i,c} &lt;\tau_{i,b}\)</span>，即 <span class="math inline">\(v_{i,b}\)</span>直接继承 <span class="math inline">\(v_{i,a}\)</span>。</p><hr /><h3 id="关键路径长度的定义">关键路径长度的定义</h3><p>对于每个图顶点 <spanclass="math inline">\(v_{i,j}\)</span>，我们定义其<strong>关键路径长度</strong>或<strong>跨度</strong><span class="math inline">\(l_{i,j} \in \mathbb{N}\)</span>为从该顶点起始的最长路径的长度，该路径由沿路径每个顶点的执行时间（包括起始顶点的权重<span class="math inline">\(c_{i,j}\)</span>）加权。</p><p>对于相应的任务 <span class="math inline">\(\tau_i\)</span>，跨度<span class="math inline">\(L_i \in \mathbb{N}\)</span>是所有顶点的跨度中的最大值，即整个DAG的关键路径长度。跨度对应于任务在给定无限数量核心时相对于其激活时间的最早完成时间。</p><p>显然，为使任务可调度，必须满足： <span class="math display">\[L_i \leq D_i\]</span></p><h2 id="适用于整数值任务的联合调度">适用于整数值任务的联合调度</h2><p>对于一个重量任务 <spanclass="math inline">\(\tau_i\)</span>，其特征为工作量 <spanclass="math inline">\(C_i\)</span>、跨度 <spanclass="math inline">\(L_i\)</span> 和截止时间 <spanclass="math inline">\(D_i\)</span>，在提供足够核心的情况下，任何工作保留型（work-conserving，即贪婪型）调度器均可调度该任务。分配给任务<span class="math inline">\(\tau_i\)</span> 的核心数可以表示为： <spanclass="math display">\[n_i = \left\lceil \frac{C_i - L_i}{D_i - L_i} \right\rceil \tag{1}\]</span></p><p>我们在此证明，对于一个并行任务，如果其截止时间和所有子任务的工作量均为整数，则分配的核心数可以改进为：<span class="math display">\[n_i&#39; = \left\lceil \frac{C_i - L_i + 1}{D_i - L_i + 1} \right\rceil\]</span></p><p>这一公式比方程 (1)在限制重量任务的核心数方面提供了实际且直观的优势。</p><h2id="单工作量表调度unit-workload-list-scheduling">单工作量表调度（Unit-WorkloadList Scheduling）</h2><p>第4节中提出的联合调度方法为高利用率的整数值任务分配了足够的处理器，以保证任何工作保留型调度器的可行性，前提是给定每个任务的工作量、关键路径长度和截止时间。然而，这种常量时间的分配方法可能会导致对重量任务的处理器过度分配，进而造成资源浪费。</p><p>在 [3] 中，Graham 的表调度方法（listscheduling）被应用于重量任务；通过使用多种启发式方法为子任务排序，可以在更少的处理器上生成可行的调度。表调度以非抢占式方式将可用子任务分配给空闲处理器；如[14]所述，这可能导致对重量任务的处理器分配过多。然而，允许空闲子任务进行抢占可能会引入切换问题。</p><h3 id="方法改进">方法改进</h3><p>为了解决这个问题，我们提出了<strong>单工作量子任务的表调度</strong>。<br />- 一个整数值并行任务 <span class="math inline">\(\tau_i\)</span>，由DAG<span class="math inline">\(G_i\)</span>表示，可以被分解为一个包含单工作量顶点的DAG <spanclass="math inline">\(G_i^*\)</span>。<br />- 在 <span class="math inline">\(G_i\)</span> 中具有工作量 <spanclass="math inline">\(c\)</span> 的顶点 <spanclass="math inline">\(v_{i,j}\)</span>被映射为一个完全有序的顶点序列，在 <spanclass="math inline">\(G_i^*\)</span> 中形成从起点到终点的路径。</p><p>对于 <span class="math inline">\(G_i^*\)</span> 中的任何边 <spanclass="math inline">\(v_{i,j}\)</span>，其连接方式如下： 1. <spanclass="math inline">\(G_i^*\)</span> 中进入 <spanclass="math inline">\(v_{i,j}\)</span>的任何边连接到其分解后路径中的第一个顶点； 2. 在 <spanclass="math inline">\(G_i\)</span> 中离开 <spanclass="math inline">\(v_j\)</span> 的任何边，现在连接到 <spanclass="math inline">\(v_{i,j}\)</span> 的分解路径中的最后一个顶点。</p><h3 id="优势">优势</h3><p>对于这样的DAG，表调度方法可以为每个单位工作量分配一个优先级；<br />这使得原始DAG <span class="math inline">\(G_i\)</span>中的相应子任务能够在单位时间步边界内被抢占。</p><h3 id="常见的表调度启发式方法">5.1 常见的表调度启发式方法</h3><h4 id="关键路径规则critical-path-rule-cp">关键路径规则（Critical PathRule, CP）</h4><p>关键路径规则用于表调度时，以<strong>最长跨度</strong>的顺序选择可用子任务进行执行。<br />-子任务跨度的分配可以以深度优先搜索的方式完成；当为每个顶点分配跨度后，图的总跨度<span class="math inline">\(L\)</span> 会被更新。 - 该过程的时间复杂度为<span class="math inline">\(O(|V| + |E|)\)</span>。</p><h4 id="dag分解">DAG分解</h4><p>DAG <span class="math inline">\(G\)</span> 分解为单位工作量的 DAG<span class="math inline">\(G^*\)</span> 的过程表示为函数<strong>Convert_Unit_DAG</strong>： 1. 初始化 <spanclass="math inline">\(G^*\)</span> 为 <spanclass="math inline">\(G\)</span> 的副本。 2. 建立一个顶点集合 <spanclass="math inline">\(V^*\)</span>，其由 <spanclass="math inline">\(G^*\)</span>中的顶点（实际代码中可能为指向顶点的指针）组成。 3. 对于 <spanclass="math inline">\(V^*\)</span> 中的每个顶点 <spanclass="math inline">\(v_i\)</span>： - 将 <spanclass="math inline">\(v_i\)</span> 的工作量 <spanclass="math inline">\(c_i\)</span> 转化为单位工作量顶点序列，这些顶点在<span class="math inline">\(G^*\)</span> 中形成路径： -路径中的每个顶点之间用边连接，第一个顶点的跨度等于 <spanclass="math inline">\(v_i\)</span> 的跨度 <spanclass="math inline">\(l_i\)</span>； -每个后续顶点的跨度比前一个顶点小1。 - 删除原始顶点 <spanclass="math inline">\(v_i\)</span>。</p><ol start="4" type="1"><li>处理完成后，<span class="math inline">\(G^*\)</span>中仅包含单位工作量的顶点：<ul><li>通过分解，生成了 <span class="math inline">\(C - |V|\)</span>个额外顶点，以及 <span class="math inline">\(C - |V|\)</span>条额外边。</li><li>因此，总运行时间为 <span class="math inline">\(O(|V| + C - |V| + |E|+ C - |V|)\)</span>，简化为 <span class="math inline">\(O(C +|E|)\)</span>。</li></ul></li></ol><h4id="后继数量规则largest-number-of-successors-rule-lns">后继数量规则（LargestNumber of Successors Rule, LNS）</h4><p>LNS规则以<strong>后继任务的总工作量</strong>为顺序，选择可用子任务进行执行：- 子任务 <span class="math inline">\(v_i \in G\)</span> 的后继工作量由与<span class="math inline">\(v_i\)</span>通过路径相连的所有顶点的工作量之和定义。 -可以通过动态规划在整个图上实现这一过程，其时间复杂度为 <spanclass="math inline">\(O(|V| + |E|)\)</span>。</p><p>LNS规则也可以应用于单位工作量子任务的表调度，并保持伪多项式时间复杂度。</p><h4 id="注意">注意</h4><p>将整数值任务的 DAG <span class="math inline">\(G\)</span>分解为单位工作量的 DAG <span class="math inline">\(G^*\)</span>时，还需要为每个单位工作量顶点分配一个子图工作量。这与跨度的分配类似，不会影响算法的时间复杂度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;摘录一下Marion的论文要点，方便查阅&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;任务模型&quot;&gt;任务模型&lt;/h3&gt;
&lt;p&gt;每个任务 &lt;span class=&quot;math inline&quot;&gt;\(\tau_i\)&lt;/span&gt; 由一组子任务
&lt;span class=&quot;math </summary>
      
    
    
    
    <category term="realtime sched" scheme="https://mackz-maxw.github.io/categories/realtime-sched/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux联合调度相关</title>
    <link href="https://mackz-maxw.github.io/2025/01/18/federated_sched/"/>
    <id>https://mackz-maxw.github.io/2025/01/18/federated_sched/</id>
    <published>2025-01-18T19:39:54.270Z</published>
    <updated>2025-01-22T02:30:10.613Z</updated>
    
    <content type="html"><![CDATA[<p>摘录一下Jing Li的论文要点，方便查阅</p><hr /><h2 id="性能界限的定义">性能界限的定义</h2><p>通常，可以为实时调度器推导出两种类型的性能界限：</p><ol type="1"><li><strong>资源增益界限</strong>（Resource Augmentation Bound）：<br />调度器 <span class="math inline">\(S\)</span> 提供一个资源增益界限 <spanclass="math inline">\(b \geq 1\)</span>，如果理想调度器能够在 <spanclass="math inline">\(m\)</span> 个速度为 1 的核心上调度任何任务集 <spanclass="math inline">\(\tau\)</span>，它能够在 <spanclass="math inline">\(m\)</span> 个速度为 <spanclass="math inline">\(b\)</span> 的核心上成功调度 <spanclass="math inline">\(\tau\)</span>。<ul><li>资源增益界限很好地反映了调度器与最优调度的接近程度，但有一个缺点：理想调度器只是一个假设的调度器，它总能找到一个可行调度（如果存在）。<br /></li><li>由于无法验证理想调度器是否能够在单位速度核心上调度给定任务集，因此资源增益界限无法提供可调度性测试。</li></ul></li><li><strong>利用率界限</strong>（Utilization Bound）：<br />调度器 <span class="math inline">\(S\)</span> 提供一个利用率界限 <spanclass="math inline">\(b\)</span>，如果它能够在 <spanclass="math inline">\(m\)</span>个核心上成功调度任何任务集，其总利用率不超过 <spanclass="math inline">\(m/b\)</span>。<ul><li>利用率界限比资源增益界限提供了更多信息：任何保证利用率界限 <spanclass="math inline">\(b\)</span> 的调度器都会自动保证资源增益界限 <spanclass="math inline">\(b\)</span>。<br /></li><li>此外，利用率界限本身是一种简单的可调度性测试，因为任务集的总利用率可以在线性时间内计算，并与<span class="math inline">\(m/b\)</span> 进行比较。</li></ul></li></ol><p>注意这些界限讨论的是调度的相对效率，而不是程序执行的速度，所以b值越小，调度更有效率。</p><ol start="3" type="1"><li><strong>容量增益界限</strong> Li 等人 [35]定义了一个名为<strong>容量增益界限</strong>（capacity augmentationbound）的概念，这一概念与利用率界限类似，但增加了一个新条件：<br />调度器 <span class="math inline">\(S\)</span> 提供容量增益界限 <spanclass="math inline">\(b\)</span>，如果它能够调度满足以下两个条件的任何任务集<span class="math inline">\(\tau\)</span>：</li></ol><ul><li><span class="math inline">\(\tau\)</span> 的总利用率最多为 <spanclass="math inline">\(m/b\)</span>；</li><li>每个任务的最差情况关键路径长度 <spanclass="math inline">\(L_i\)</span>（即在无限核心上的执行时间）最多为其截止时间的<span class="math inline">\(1/b\)</span> 的比例。</li></ul><p>容量增益界限与利用率界限非常相似，但它提供的信息比资源增益界限更多：<br />- 任何保证容量增益界限为 <span class="math inline">\(b\)</span>的调度器也自动保证资源增益界限为 <spanclass="math inline">\(b\)</span>。<br />-它同样可以作为一种简单的可调度性测试，并提供对系统可承受负载的估计。</p><hr /><h2 id="策略分类">策略分类</h2><p>最近的研究主要集中在为并行任务的各种调度策略证明<strong>资源增益界限</strong>和<strong>容量增益界限</strong>。这些工作可以分为两类：1. <strong>基于分解的策略</strong>（Decomposition-basedstrategies）：<br />并行任务被分解为一组顺序任务，并使用现有的顺序任务调度策略在多处理器上进行调度。这些策略通常需要事先明确DAG的结构，以便进行分解。</p><ol start="2" type="1"><li><strong>非分解策略</strong>（Non-decomposition-basedstrategies）：<br />程序可以动态展开，因此不需要离线知识。研究主要集中在两种调度策略上：</li></ol><hr /><h2 id="主要贡献">主要贡献</h2><p>本文的主要贡献如下： 1.<strong>提出了一种新的联合调度策略</strong>（federated schedulingstrategy）：<br />- 在此策略中，每个<strong>高利用率任务</strong>（利用率 ≥1）被分配到一个专用的核心集（cluster）。<br />-一个多处理器调度算法用于调度所有<strong>低利用率任务</strong>，这些任务依次运行在由剩余核心组成的共享核心集上。<br />- 联合调度可以看作是分区调度策略的推广，适用于并行任务。<br />- 这是目前已知的针对任意并行 DAG 调度器的最佳容量增益界限。</p><ol start="2" type="1"><li><p><strong>证明联合调度的容量增益界限为 2</strong>：<br />此外，我们还证明了没有任何调度器能够为并行任务提供比 <spanclass="math inline">\(2 - 1/m\)</span> 更好的容量增益界限。<br />因此，当 <span class="math inline">\(m\)</span>足够大时，联合调度的界限为 2 是最优的。</p></li><li><p><strong>改进了 G-EDF 的容量增益界限</strong>：<br />对于 DAG 任务，G-EDF 的容量增益界限被改进为<br /><span class="math display">\[\frac{3 + \sqrt{5}}{2} \approx 2.618\]</span> 当 <span class="math inline">\(m\)</span> 足够大时，G-EDF的容量增益界限达到这一匹配的下界。因此，这一结果填补了大 <spanclass="math inline">\(m\)</span>场景下的间隙，这是目前已知针对任意全局调度器的最佳容量增益界限。</p></li><li><p><strong>证明 G-RM 的容量增益界限为</strong> <spanclass="math inline">\(2 + \sqrt{3} \approx 3.732\)</span> ：</p><ul><li>这是目前已知针对任何固定优先级调度器的 DAG任务的最佳容量增益界限。<br /></li><li>即使仅限于同步任务，这仍是基于全局固定优先级调度（且无需分解）的最佳界限。</li></ul></li></ol><hr /><h2 id="系统模型">系统模型</h2><p>我们现在详细描述并行任务的DAG模型以及一些附加定义。</p><p>我们考虑一个由 <span class="math inline">\(n\)</span>个独立的间歇性实时任务 <span class="math inline">\(\tau = \{\tau_1,\tau_2, \dots, \tau_n\}\)</span> 组成的任务集。任务 <spanclass="math inline">\(\tau_i\)</span>表示任务实例（也称为作业）的无限到达和执行序列。我们考虑<strong>间歇性任务模型</strong>，其中对于任务<span class="math inline">\(\tau_i\)</span>： -<strong>最小间隔时间</strong>（或周期）<spanclass="math inline">\(T_i\)</span> 表示连续任务实例到达之间的时间； -<strong>相对截止时间</strong> <span class="math inline">\(D_i\)</span>表示完成作业的时间约束。</p><p>如果任务实例 <span class="math inline">\(\tau_i\)</span> 在时间 <spanclass="math inline">\(t\)</span> 到达，则其执行必须在绝对截止时间 <spanclass="math inline">\(t + D_i\)</span>之前完成，且下一个任务实例不能早于 <span class="math inline">\(t +T_i\)</span> 到达。<br />在本文中，我们考虑<strong>隐式截止时间任务</strong>，即每个任务 <spanclass="math inline">\(\tau_i\)</span> 的相对截止时间 <spanclass="math inline">\(D_i\)</span> 等于其最小间隔时间 <spanclass="math inline">\(T_i\)</span>，即 <span class="math inline">\(T_i =D_i\)</span>。</p><p>我们研究在具有 <span class="math inline">\(m\)</span>个相同核心的多核系统上调度这些任务集的可调度性。</p><h3 id="dag任务的特性">DAG任务的特性</h3><p>每个任务 <span class="math inline">\(\tau_i \in \tau\)</span>是一个并行任务，并被描述为一个<strong>有向无环图（DAG）</strong>。<br />- DAG中的每个节点（子任务）表示指令序列（一个线程），每条边表示节点之间的依赖关系。- 当一个节点的所有前驱节点完成时，该节点准备好执行。</p><p>在本文中，由于不需要基于DAG的具体结构进行分析，仅定义了与任务 <spanclass="math inline">\(\tau_i\)</span> 的执行模式相关的两个参数：</p><ol type="1"><li><p><strong>总执行时间（或工作量）<spanclass="math inline">\(C_i\)</span></strong>：<br />这是任务 <span class="math inline">\(\tau_i\)</span>的所有子任务在最坏情况下的执行时间总和。</p></li><li><p><strong>关键路径长度 <spanclass="math inline">\(L_i\)</span></strong>：<br />在给定DAG中，这是关键路径的长度，其中每个节点由对应子任务的最坏情况下执行时间表示。<br />关键路径长度是任务在无限核心下的最坏情况下执行时间。</p></li></ol><p>给定一个DAG，计算 <span class="math inline">\(C_i\)</span> 和 <spanclass="math inline">\(L_i\)</span> 都可以在线性时间内完成。</p><h3 id="任务的利用率">任务的利用率</h3><ul><li>任务 <span class="math inline">\(\tau_i\)</span>的<strong>利用率</strong>定义为 <span class="math inline">\(u_i =\frac{C_i}{T_i} = \frac{C_i}{D_i}\)</span>。<br /></li><li>任务集的总利用率表示为： <span class="math display">\[U_\Sigma = \sum_{\tau_i \in \tau} u_i\]</span></li></ul><hr /><h2 id="基于利用率的可调度性测试">基于利用率的可调度性测试</h2><p>在本文中，我们从容量增益界限的角度分析调度器。形式化定义如下：</p><h3 id="定义-1">定义 1</h3><p>给定总利用率为 <span class="math inline">\(U_\Sigma\)</span> 的任务集<span class="math inline">\(\tau\)</span>，如果调度算法 <spanclass="math inline">\(S\)</span> 在 <spanclass="math inline">\(m\)</span> 个速度为 <spanclass="math inline">\(b\)</span> 的核心上总能调度 <spanclass="math inline">\(\tau\)</span>，且满足以下条件，则其容量增益界限为<span class="math inline">\(b\)</span>：</p><ol type="1"><li><p><strong>利用率限制条件</strong>：<br /><span class="math display">\[\sum_{\tau_i \in \tau} u_i \leq \frac{m}{b}\]</span></p></li><li><p><strong>关键路径限制条件</strong>：<br />对于每个任务 <span class="math inline">\(\tau_i \in \tau\)</span>：<span class="math display">\[L_i \leq \frac{D_i}{b}\]</span></p></li></ol><h3 id="说明">说明</h3><ul><li>条件 (1) 表示任务集的总利用率不超过 <spanclass="math inline">\(m/b\)</span>。</li><li>条件 (2) 表示每个任务的关键路径长度不超过其相对截止时间的 <spanclass="math inline">\(1/b\)</span>。</li></ul><p>因此，为了验证任务集是否可调度，我们只需知道任务集的总利用率和最大关键路径利用率即可。</p><p>当 <span class="math inline">\(b = 1\)</span> 时，<spanclass="math inline">\(S\)</span> 是一个理想调度器；调度器的 <spanclass="math inline">\(b\)</span> 越小，其性能越优。</p><h2 id="iii.-联合调度federated-scheduling">III. 联合调度（FederatedScheduling）</h2><h3 id="a.-联合调度算法federated-scheduling-algorithm">A.联合调度算法（Federated Scheduling Algorithm）</h3><p>给定任务集 <spanclass="math inline">\(\tau\)</span>，联合调度算法的工作流程如下：</p><ol type="1"><li>首先，将任务划分为两个不相交的集合：<ul><li><span class="math inline">\(\tau_{\text{high}}\)</span>包含所有<strong>高利用率任务</strong>，即利用率至少为 1 的任务（<spanclass="math inline">\(u_i \geq 1\)</span>）。<br /></li><li><span class="math inline">\(\tau_{\text{low}}\)</span>包含所有剩余的<strong>低利用率任务</strong>。</li></ul></li></ol><p>考虑一个高利用率任务 <spanclass="math inline">\(\tau_i\)</span>，其最坏情况下执行时间为 <spanclass="math inline">\(C_i\)</span>，关键路径长度为 <spanclass="math inline">\(L_i\)</span>，截止时间为 <spanclass="math inline">\(D_i\)</span>（与其周期 <spanclass="math inline">\(T_i\)</span> 相等）。我们为任务 <spanclass="math inline">\(\tau_i\)</span> 分配 <spanclass="math inline">\(n_i\)</span> 个专用核心，其中： <spanclass="math display">\[n_i = \left\lceil \frac{C_i - L_i}{D_i - L_i} \right\rceil\]</span></p><ol start="2" type="1"><li><p>我们使用以下公式计算分配给高利用率任务的核心总数： <spanclass="math display">\[n_{\text{high}} = \sum_{\tau_i \in \tau_{\text{high}}} n_i\]</span></p></li><li><p>剩余的核心被分配给所有低利用率任务 <spanclass="math inline">\(\tau_{\text{low}}\)</span>，其核心数为： <spanclass="math display">\[n_{\text{low}} = m - n_{\text{high}}\]</span></p></li></ol><p>如果 <span class="math inline">\(n_{\text{low}}\)</span>非负且满足以下条件： <span class="math display">\[n_{\text{low}} \geq 2 \sum_{\tau_i \in \tau_{\text{low}}} u_i\]</span> 则联合调度算法接受任务集 <spanclass="math inline">\(\tau\)</span>。</p><h3 id="运行时调度runtime-scheduling">运行时调度（RuntimeScheduling）</h3><p>在有效的核心分配之后，运行时调度过程如下：</p><ol type="1"><li><strong>高利用率任务的调度</strong>：<ul><li>使用任何贪婪调度器（greedy scheduler）对高利用率任务 <spanclass="math inline">\(\tau_i\)</span> 进行调度。<br /></li><li>贪婪调度器确保当某节点准备好执行时，不会让核心处于空闲状态。</li></ul></li><li><strong>低利用率任务的调度</strong>：<ul><li>将低利用率任务视为顺序任务，并使用任何多处理器调度算法（如分区EDF或速率单调调度器）进行调度。<br /></li><li>低利用率任务的总利用率最多为 <spanclass="math inline">\(1/2\)</span>，因此可以在分配的 <spanclass="math inline">\(n_{\text{low}}\)</span> 核心上进行调度。</li></ul></li></ol><h3 id="关键点">关键点</h3><p>联合调度算法的一个重要特性是：我们可以安全地将低利用率任务视为顺序任务，因为<span class="math inline">\(C_i \leqD_i\)</span>，这表明这些任务在其截止时间内完成时不需要并行执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;摘录一下Jing Li的论文要点，方便查阅&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;性能界限的定义&quot;&gt;性能界限的定义&lt;/h2&gt;
&lt;p&gt;通常，可以为实时调度器推导出两种类型的性能界限：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;strong&gt;资源增益界限&lt;/str</summary>
      
    
    
    
    <category term="realtime sched" scheme="https://mackz-maxw.github.io/categories/realtime-sched/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux调度算法相关4</title>
    <link href="https://mackz-maxw.github.io/2025/01/04/linux_sched4/"/>
    <id>https://mackz-maxw.github.io/2025/01/04/linux_sched4/</id>
    <published>2025-01-05T03:00:13.516Z</published>
    <updated>2025-01-22T02:30:43.409Z</updated>
    
    <content type="html"><![CDATA[<h3 id="检索调度策略和优先级">检索调度策略和优先级</h3><ol type="1"><li><strong><code>sched_getscheduler()</code> 和<code>sched_getparam()</code> 系统调用</strong>：<ul><li>这两个系统调用可以检索进程的调度策略和优先级。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_getscheduler</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="comment">//返回调度策略，成功时返回调度策略标识符，出错时返回 -1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_getparam</span><span class="params">(<span class="type">pid_t</span> pid, <span class="keyword">struct</span> sched_param *param)</span>;</span><br><span class="line"><span class="comment">//成功时返回 0，出错时返回 -1。</span></span><br></pre></td></tr></table></figure><h3id="调度参数和优先级获取的系统调用说明">调度参数和优先级获取的系统调用说明</h3><p>对于这两个系统调用（<code>sched_getscheduler</code> 和<code>sched_getparam</code>），<code>pid</code> 指定了要获取信息的进程ID。如果 <code>pid</code> 为 0，则获取调用进程的信息。<br />不论是否具有特权，这两个系统调用都可用于非特权进程，以获取任何进程的信息，无需凭证。</p><p><code>sched_getparam()</code> 系统调用在 <code>sched_param</code>结构体中的 <code>sched_priority</code>字段中返回指定进程的实时优先级。</p><hr /><h3 id="示例用法">示例用法</h3><p>成功执行后，<code>sched_getscheduler()</code> 返回表 35-1中列出的策略之一。<br />Listing 35-3 中的程序使用 <code>sched_getscheduler()</code> 和<code>sched_getparam()</code>来获取命令行参数指定的所有进程的调度策略和优先级。<br />下面的 shell 会话演示了该程序和 Listing 35-2 中的程序的使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ su  </span><br><span class="line">Password:  </span><br><span class="line"><span class="comment"># sleep 100 &amp;    # 创建一个进程</span></span><br><span class="line">[1] 2006  </span><br><span class="line"><span class="comment"># ./sched_view 2006    # 查看 sleep 进程的初始调度策略和优先级</span></span><br><span class="line">2006: OTHER 0  </span><br><span class="line"><span class="comment"># ./sched_set f 25 2006    # 将进程 2006 切换为 SCHED_FIFO 策略，优先级为 25</span></span><br><span class="line"><span class="comment"># ./sched_view 2006        # 验证修改</span></span><br><span class="line">2006: FIFO 25  </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j, pol;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">sp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        pol = sched_getscheduler(getLong(argv[j], <span class="number">0</span>, <span class="string">&quot;pid&quot;</span>)); <span class="comment">// 获取调度策略</span></span><br><span class="line">        <span class="keyword">if</span> (pol == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;sched_getscheduler&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sched_getparam(getLong(argv[j], <span class="number">0</span>, <span class="string">&quot;pid&quot;</span>), &amp;sp) == <span class="number">-1</span>) <span class="comment">// 获取调度参数</span></span><br><span class="line">            errExit(<span class="string">&quot;sched_getparam&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: %-5s %2d\n&quot;</span>, argv[j],</span><br><span class="line">            (pol == SCHED_OTHER) ? <span class="string">&quot;OTHER&quot;</span> :     <span class="comment">// 普通调度策略</span></span><br><span class="line">            (pol == SCHED_RR) ? <span class="string">&quot;RR&quot;</span> :          <span class="comment">// 轮转调度策略</span></span><br><span class="line">            (pol == SCHED_FIFO) ? <span class="string">&quot;FIFO&quot;</span> :      <span class="comment">// 先进先出调度策略</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_BATCH                            <span class="comment">// Linux特定调度策略</span></span></span><br><span class="line">            (pol == SCHED_BATCH) ? <span class="string">&quot;BATCH&quot;</span> :</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_IDLE                             <span class="comment">// Linux特定空闲调度策略</span></span></span><br><span class="line">            (pol == SCHED_IDLE) ? <span class="string">&quot;IDLE&quot;</span> :</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="string">&quot;???&quot;</span>,                             <span class="comment">// 未知调度策略</span></span><br><span class="line">            sp.sched_priority);                <span class="comment">// 优先级</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防止实时进程锁死系统">防止实时进程锁死系统</h3><p>由于 <strong>SCHED_RR</strong> 和 <strong>SCHED_FIFO</strong>进程会抢占任何低优先级的进程（例如运行程序的shell），在开发使用这些策略的应用程序时，我们需要注意一个可能的风险：一个失控的实时进程可能会通过占用CPU导致系统锁死。为避免这种情况，可以采用以下几种方法：</p><ul><li><p><strong>设置一个足够低的软CPU时间资源限制（<code>RLIMIT_CPU</code>）</strong><br />使用 <code>setrlimit()</code>函数（参考第36.3节）来设置。如果进程消耗了过多的CPU时间，将会被发送一个<code>SIGXCPU</code> 信号，该信号默认会杀死进程。</p></li><li><p><strong>使用 <code>alarm()</code> 设置报警计时器</strong><br />如果进程运行的实际时间超过了 <code>alarm()</code>调用中指定的秒数，则会被发送一个 <code>SIGALRM</code>信号并被终止。</p></li><li><p><strong>创建一个具有高实时优先级的守护进程</strong><br />该进程可以循环运行，按照指定的间隔睡眠，然后唤醒并监视其他进程的状态。此类监视可以包括：</p><ul><li>检查每个进程的CPU时间时钟值（参考23.5.3节中的<code>clock_getcpuclockid()</code> 函数）；</li><li>使用 <code>sched_getscheduler()</code> 和<code>sched_getparam()</code> 检查其调度策略和优先级。<br />如果某个进程被认为行为异常，守护线程可以通过降低其优先级或发送适当的信号终止该进程来控制它。</li></ul></li><li><p><strong>从Linux内核2.6.25开始，提供了非标准的资源限制<code>RLIMIT_RTTIME</code></strong><br />该限制用于控制实时调度策略进程在单次连续运行中可以消耗的CPU时间，单位为微秒。</p><ul><li><code>RLIMIT_RTTIME</code>限制了进程在不执行阻塞系统调用时所能消耗的CPU时间总量。<br /></li><li>当进程执行阻塞系统调用时，消耗的CPU时间计数会被重置为0。<br /></li><li>如果进程被更高优先级的进程抢占、由于时间片到期（<strong>SCHED_RR</strong>进程）或调用<code>sched_yield()</code>（第35.3.3节）而被调度出CPU，则计数也会被重置。<br /></li><li>如果进程达到 <code>RLIMIT_CPU</code> 限制，将收到一个<code>SIGXCPU</code> 信号，默认情况下会杀死进程。</li></ul></li></ul><h4 id="注意">注意</h4><p>内核2.6.25中的改动也有助于防止失控的实时进程锁死系统。有关详细信息，请参阅内核源代码文档：<code>scheduler/sched-rt-group.txt</code>。</p><h3 id="防止子进程继承特权调度策略">防止子进程继承特权调度策略</h3><p>Linux 2.6.32 引入了 <code>SCHED_RESET_ON_FORK</code> 作为可以在调用<code>sched_setscheduler()</code> 时指定的策略值之一。<br />这是一个标志值，它会与表35-1中的策略之一进行位或操作。如果设置了此标志，则由此进程通过<code>fork()</code>创建的子进程不会继承特权调度策略和优先级。规则如下：</p><ul><li>如果调用进程具有实时调度策略（<strong>SCHED_RR</strong> 或<strong>SCHED_FIFO</strong>），那么子进程的调度策略将被重置为标准的时间片轮转策略，<strong>SCHED_OTHER</strong>。</li><li>如果进程具有负的（即较高的）nice 值，则子进程的 nice值将被重置为0。</li></ul><h3 id="sched_reset_on_fork-的作用"><code>SCHED_RESET_ON_FORK</code>的作用</h3><p><code>SCHED_RESET_ON_FORK</code>标志旨在用于媒体播放等应用场景。它允许创建具有实时调度策略的单个进程，而这些策略不会传递给子进程。<br />使用 <code>SCHED_RESET_ON_FORK</code>标志可以防止通过创建多个运行在实时调度策略下的子进程来试图规避<strong>RLIMIT_RTTIME</strong> 资源限制的 fork 炸弹攻击。</p><p>一旦为一个进程启用了 <code>SCHED_RESET_ON_FORK</code>标志，只有具备特权的进程（即具有 <strong>CAP_SYS_NICE</strong>权限的进程）可以禁用它。 此时当创建子进程时，其 reset-on-fork标志会被禁用。</p><hr /><h3 id="让出-cpu">让出 CPU</h3><p>一个实时进程可以通过以下两种方式主动让出 CPU： 1.调用一个会阻塞进程的系统调用（例如，从终端执行 <code>read()</code>）。2. 调用 <code>sched_yield()</code>。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_yield</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//成功时返回 0，出错时返回 -1。</span></span><br></pre></td></tr></table></figure> ###<code>sched_yield()</code> 的操作</p><p><code>sched_yield()</code>的操作非常简单。如果有其他与调用进程处于相同优先级队列中的可运行进程，则调用进程会被放到队列的末尾，并由队列头部的进程被调度使用CPU。<br />如果在此优先级上没有其他可运行进程排队，那么 <code>sched_yield()</code>什么都不做；调用进程将继续使用 CPU。</p><p>尽管 SUSv3 允许 <code>sched_yield()</code> 返回可能的错误，但在 Linux以及许多其他 UNIX 实现中，此系统调用始终成功。<br />然而，可移植的应用程序仍应始终检查是否有错误返回。</p><p>对于非实时进程使用 <code>sched_yield()</code> 的行为是未定义的。</p><hr /><h3 id="sched_rr-时间片"><strong><code>SCHED_RR</code>时间片</strong></h3><p><code>sched_rr_get_interval()</code> 系统调用使我们能够确定为<code>SCHED_RR</code> 进程每次被分配使用 CPU 时的时间片长度。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_rr_get_interval</span><span class="params">(<span class="type">pid_t</span> pid, <span class="keyword">struct</span> timespec *tp)</span>;</span><br><span class="line"><span class="comment">//成功时返回 0，出错时返回 -1。</span></span><br></pre></td></tr></table></figure> 与其他进程调度系统调用一样，<code>pid</code>用于标识我们希望获取信息的进程。指定 <code>pid</code> 为 0表示当前调用进程。<br />时间片的长度通过指向 <code>tp</code> 的 <code>timespec</code>结构返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;   <span class="comment">/* 秒 */</span></span><br><span class="line">    <span class="type">long</span>   tv_nsec;  <span class="comment">/* 纳秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在最近的 2.6 内核中，实时轮转调度（SCHED_RR）的时间片为 0.1 秒。 ###总结</p><p>默认的内核调度算法采用的是轮转时间共享策略。在这种策略下，所有进程默认可以平等地访问CPU。不过，我们可以通过将进程的 nice 值设置为 -20（高优先级）到+19（低优先级）的范围内的数字，从而使调度器偏爱或减少对该进程的调度。然而，即使我们将进程设置为最低优先级，它也不会完全失去对CPU 的访问。</p><p>Linux 还实现了 POSIX 实时调度扩展，这允许应用程序精确控制进程对 CPU的分配。在实时调度的两种策略下运行的进程，<strong>SCHED_RR</strong>（轮转调度）和<strong>SCHED_FIFO</strong>（先进先出），总是优先于运行在非实时策略下的进程。实时进程的优先级范围是1（低优先级）到99（高优先级）。只要高优先级进程可运行，它就会完全排除低优先级进程对 CPU的访问。</p><p>在 <strong>SCHED_FIFO</strong> 策略下运行的进程会独占CPU，直到进程终止、自愿释放CPU，或者被一个更高优先级的进程抢占。同样的规则适用于<strong>SCHED_RR</strong>策略，不同之处在于，如果多个进程具有相同的优先级，则 CPU在这些进程之间以轮转方式共享。</p><p>此外，可以使用进程的 CPU 亲和性掩码（CPU affinitymask）来限制进程仅运行在多处理器系统的某些 CPU上。这有助于提高某些应用程序类型的性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;检索调度策略和优先级&quot;&gt;检索调度策略和优先级&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;sched_getscheduler()&lt;/code&gt; 和
&lt;code&gt;sched_getparam()&lt;/code&gt; 系统调用&lt;/str</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux调度算法相关3</title>
    <link href="https://mackz-maxw.github.io/2025/01/02/linux_sched3/"/>
    <id>https://mackz-maxw.github.io/2025/01/02/linux_sched3/</id>
    <published>2025-01-03T01:43:33.351Z</published>
    <updated>2025-01-22T02:30:40.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实时进程调度-api">实时进程调度 API</h1><p>我们现在来看一下组成实时进程调度 API的各种系统调用。这些系统调用允许我们控制进程的调度策略和优先级。</p><h2 id="实时优先级范围">实时优先级范围</h2><p><code>sched_get_priority_min()</code> 和<code>sched_get_priority_max()</code>系统调用返回特定调度策略的可用优先级范围。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_get_priority_min</span><span class="params">(<span class="type">int</span> policy)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_get_priority_max</span><span class="params">(<span class="type">int</span> policy)</span>;</span><br><span class="line"><span class="comment">//返回值：成功时返回非负整数优先级，出错时返回 -1。</span></span><br></pre></td></tr></table></figure> -对于这两个系统调用，<code>policy</code>指定我们想要获取信息的调度策略。我们可以指定 <code>SCHED_RR</code> 或<code>SCHED_FIFO</code>。 - <code>sched_get_priority_min()</code>系统调用返回指定策略的最小优先级，<code>sched_get_priority_max()</code>返回最大优先级。 - 在 Linux 系统中，这两个系统调用分别返回数字 1 和99，适用于 <code>SCHED_RR</code> 和 <code>SCHED_FIFO</code> 策略。 -换句话说，<code>SCHED_RR</code> 和 <code>SCHED_FIFO</code>的优先级范围完全相同，<code>SCHED_RR</code> 和 <code>SCHED_FIFO</code>的进程在同一优先级时是同样有资格被调度的。首先调度哪个进程取决于它们在该优先级队列中的顺序。</p><h3 id="实时优先级范围的差异">实时优先级范围的差异</h3><ul><li>实时优先级范围在不同的 UNIX实现中有所不同。因此，在应用程序中避免硬编码优先级值时，我们应该根据从这些函数返回的值来指定优先级。</li><li>例如，最低的 <code>SCHED_RR</code> 优先级可以指定为<code>sched_get_priority_min(SCHED_RR)</code>，下一个较高的优先级可以指定为<code>sched_get_priority_min(SCHED_RR) + 1</code>，以此类推。</li></ul><h3 id="susv3-和-unix-实现的差异">SUSv3 和 UNIX 实现的差异</h3><ul><li>SUSv3 并不要求 <code>SCHED_RR</code> 和 <code>SCHED_FIFO</code>策略使用相同的优先级范围，但在大多数 UNIX 实现中，它们是相同的。</li><li>例如，在 Solaris 8 中，两个策略的优先级范围为 0 到 59，而在 FreeBSD6.1 中为 0 到 31。</li></ul><h1 id="修改和检索调度策略及优先级">修改和检索调度策略及优先级</h1><h2 id="修改调度策略和优先级">修改调度策略和优先级</h2><p><code>sched_setscheduler()</code> 系统调用可以更改指定进程（通过<code>pid</code> 参数指定）的调度策略和优先级。</p><ul><li><strong>参数说明</strong>：<ul><li>如果 <code>pid</code> 参数被设置为<code>0</code>，则更改的是调用该系统调用的当前进程的属性。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setscheduler</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> policy, <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span>;</span><br></pre></td></tr></table></figure><p>成功时返回 0。出错时返回 -1。</p><p>param：指向如下包含调度优先级信息的结构体的指针。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> sched_priority;  <span class="comment">/* 调度优先级 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> SUSv3定义了 <code>param</code>参数为一个结构体，以允许实现包括特定于实现的额外字段，这在提供额外的调度策略时可能很有用。然而，与大多数UNIX 实现一样，Linux 仅提供了 <code>sched_priority</code>字段，用于指定调度优先级。</p><p>对于 <code>SCHED_RR</code> 和 <code>SCHED_FIFO</code>策略，该字段的值必须位于由 <code>sched_get_priority_min()</code> 和<code>sched_get_priority_max()</code>确定的范围内；对于其他策略，该优先级必须为 0。</p><p><code>policy</code>参数决定了进程的调度策略。它可以是以下策略之一（如表 35-1 所示）：</p><h3 id="表-35-1linux-的实时和非实时调度策略">表 35-1：Linux的实时和非实时调度策略</h3><table><colgroup><col style="width: 16%" /><col style="width: 83%" /></colgroup><thead><tr><th>策略</th><th>描述</th></tr></thead><tbody><tr><td><code>SCHED_FIFO</code></td><td>实时先进先出（First-in First-out）</td></tr><tr><td><code>SCHED_RR</code></td><td>实时轮转（Round-robin）</td></tr><tr><td><code>SCHED_OTHER</code></td><td>标准轮转时间共享</td></tr><tr><td><code>SCHED_BATCH</code></td><td>类似于 <code>SCHED_OTHER</code>，但用于批处理（自 Linux 2.6.16起提供）</td></tr><tr><td><code>SCHED_IDLE</code></td><td>类似于 <code>SCHED_OTHER</code>，但优先级比 <code>nice +19</code>更低（自 Linux 2.6.23 起提供）</td></tr></tbody></table><h3 id="sched_setscheduler-系统调用"><code>sched_setscheduler()</code>系统调用</h3><ul><li>成功的 <code>sched_setscheduler()</code> 调用会将指定的进程（由<code>pid</code> 参数指定）移动到其优先级队列的末尾。</li></ul><p>SUSv3 指定，成功的 <code>sched_setscheduler()</code>调用应返回之前的调度策略。然而，Linux 与标准不同，成功调用时返回值为<code>0</code>。<br />便携式应用程序应通过检查返回值是否为 <code>-1</code>来判断是否成功。</p><ul><li>子进程通过 <code>fork()</code>继承其父进程的调度策略和优先级，并在调用 <code>exec()</code>时保留这些属性。</li></ul><h3 id="sched_setparam-系统调用"><code>sched_setparam()</code>系统调用</h3><ul><li><p><code>sched_setparam()</code> 系统调用提供了<code>sched_setscheduler()</code> 功能的子集：</p><ul><li>它可以修改进程的调度优先级，但不会更改其调度策略。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setparam</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span>;</span><br></pre></td></tr></table></figure>成功时返回 0。出错时返回 -1。 <code>pid</code> 和 <code>param</code>参数的含义与 <code>sched_setscheduler()</code> 中的相同。</li></ul></li><li><p><strong>成功的 <code>sched_setparam()</code>调用</strong>：<br />成功调用 <code>sched_setparam()</code> 后，指定的进程（通过<code>pid</code> 参数指定）会被移动到其优先级队列的队尾。</p></li><li><p><strong>代码示例</strong>：<br />以下程序使用 <code>sched_setscheduler()</code>来根据命令行参数设置指定进程的调度策略和优先级。</p><ul><li><strong>参数说明</strong>：<ol type="1"><li>第一个参数是一个字母，用于指定调度策略（如 <code>SCHED_RR</code> 或<code>SCHED_FIFO</code>）。</li><li>第二个参数是一个整数，用于指定调度优先级。</li><li>剩余参数是需要更改调度属性的进程 ID 列表。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span><span class="comment">//自定义的头文件，提供错误处理和辅助函数</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> j, pol;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">sp</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span> || <span class="built_in">strchr</span>(<span class="string">&quot;rfobi&quot;</span>, argv[<span class="number">1</span>][<span class="number">0</span>]) == <span class="literal">NULL</span>)</span><br><span class="line">        usageErr(<span class="string">&quot;%s policy priority [pid...]\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    policy is &#x27;r&#x27; (RR), &#x27;f&#x27; (FIFO), &quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_BATCH</span></span><br><span class="line">                 <span class="string">&quot; &#x27;b&#x27; (BATCH), &quot;</span> <span class="comment">/* Linux-specific */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_IDLE</span></span><br><span class="line">                 <span class="string">&quot; &#x27;i&#x27; (IDLE), &quot;</span>  <span class="comment">/* Linux-specific */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                 <span class="string">&quot;or &#x27;o&#x27; (OTHER)\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析调度策略</span></span><br><span class="line">    pol = (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>) ? SCHED_RR :</span><br><span class="line">          (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;f&#x27;</span>) ? SCHED_FIFO :</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_BATCH</span></span><br><span class="line">          (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;b&#x27;</span>) ? SCHED_BATCH :</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_IDLE</span></span><br><span class="line">          (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>) ? SCHED_IDLE :</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          SCHED_OTHER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析优先级</span></span><br><span class="line">    sp.sched_priority = getInt(argv[<span class="number">2</span>], <span class="number">0</span>, <span class="string">&quot;priority&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置每个指定进程的调度策略和优先级</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">3</span>; j &lt; argc; j++)</span><br><span class="line">        <span class="keyword">if</span> (sched_setscheduler(getLong(argv[j], <span class="number">0</span>, <span class="string">&quot;pid&quot;</span>), pol, &amp;sp) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;sched_setscheduler&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ###权限和资源限制对调度参数更改的影响</li></ol></li></ul></li></ul><h4 id="版本之前的内核行为">1. <strong>2.6.12版本之前的内核行为</strong></h4><ul><li>在 Linux 2.6.12内核之前，进程通常需要具有特权（<code>CAP_SYS_NICE</code>）才能更改调度策略和优先级。</li><li>唯一的例外是：如果调用者的有效用户 ID 与目标进程的真实或有效用户 ID匹配，则非特权进程可以将目标进程的调度策略更改为<code>SCHED_OTHER</code>。</li></ul><h4 id="版本及之后的内核行为">2. <strong>2.6.12版本及之后的内核行为</strong></h4><ul><li>自 Linux 2.6.12 起，引入了一个新的非标准资源限制<code>RLIMIT_RTPRIO</code>，调整了实时调度策略和优先级的设置规则：<ul><li>拥有特权的进程（<code>CAP_SYS_NICE</code>）可以对任意进程的调度策略和优先级进行更改。</li><li>非特权进程也可以根据以下规则更改调度策略和优先级：</li></ul></li></ul><ol type="1"><li><strong><code>RLIMIT_RTPRIO</code> 的非零软限制</strong>：<ul><li>如果进程具有非零的 <code>RLIMIT_RTPRIO</code>软限制，则可以任意更改其调度策略和优先级。</li><li>但有以下限制：<ul><li>实时优先级的最大值不能超过当前实时优先级和<code>RLIMIT_RTPRIO</code> 软限制中的较大值。</li></ul></li></ul></li><li><strong>如果<code>RLIMIT_RTPRIO</code> 的软限制为零</strong>：<ul><li>唯一可以进行的更改是：<ul><li>将实时优先级降低。</li><li>或从实时调度策略切换到非实时调度策略。</li></ul></li></ul></li><li><strong><code>SCHED_IDLE</code> 策略的特殊性</strong>：<ul><li>运行在 <code>SCHED_IDLE</code> 策略下的进程无法更改其调度策略，无论<code>RLIMIT_RTPRIO</code> 的值如何。</li></ul></li><li><strong>从其他非特权进程进行更改</strong>：<ul><li>如果调用者的有效用户 ID 与目标进程的真实或有效用户 ID匹配，则可以更改目标进程的调度策略和优先级。</li></ul></li><li><strong><code>RLIMIT_RTPRIO</code> 软限制的作用</strong>：<ul><li>仅决定进程对自身或其它非特权进程对该进程调度策略和优先级的更改。</li><li>一个非零限制并不赋予非特权进程对其他进程的调度策略和优先级进行更改的能力。</li></ul></li></ol><h3 id="特殊说明">特殊说明</h3><ul><li>自 Linux 2.6.25 起，添加了实时调度组（Realtime SchedulingGroups）的概念：<ul><li>可通过 <code>CONFIG_RT_GROUP_SCHED</code> 内核选项进行配置。</li><li>这一选项影响设置实时调度策略时可以进行的更改。</li><li>详情请参阅内核源码文档<code>Documentation/scheduler/sched-rt-group.txt</code>。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实时进程调度-api&quot;&gt;实时进程调度 API&lt;/h1&gt;
&lt;p&gt;我们现在来看一下组成实时进程调度 API
的各种系统调用。这些系统调用允许我们控制进程的调度策略和优先级。&lt;/p&gt;
&lt;h2 id=&quot;实时优先级范围&quot;&gt;实时优先级范围&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
