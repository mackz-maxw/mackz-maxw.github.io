<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Maxw的小站</title>
  
  <subtitle>Maxw学习记录</subtitle>
  <link href="https://mackz-maxw.github.io/atom.xml" rel="self"/>
  
  <link href="https://mackz-maxw.github.io/"/>
  <updated>2025-05-24T22:15:43.438Z</updated>
  <id>https://mackz-maxw.github.io/</id>
  
  <author>
    <name>Mackz-Maxw</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>代码随想录 | 刷题-栈与队列2</title>
    <link href="https://mackz-maxw.github.io/2025/05/24/kamacode10/"/>
    <id>https://mackz-maxw.github.io/2025/05/24/kamacode10/</id>
    <published>2025-05-24T22:15:57.037Z</published>
    <updated>2025-05-24T22:15:43.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="逆波兰表达式求值">150. 逆波兰表达式求值</h3><p>细节很重要，注意数字可能有多位，有负数；数学表达式操作前后数字顺序影响结果<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(string ss: tokens)&#123;</span><br><span class="line">            <span class="type">char</span> ssEnd = ss[ss.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(ssEnd &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; ssEnd &gt;= <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span> times = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(!ss.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">if</span>(ss[ss.<span class="built_in">size</span>()<span class="number">-1</span>] == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                        val = <span class="number">0</span> - val;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="type">int</span> n = (ss[ss.<span class="built_in">size</span>()<span class="number">-1</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                        val += n * times;</span><br><span class="line">                        times = times * <span class="number">10</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ss.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span> n1 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> n2 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> opVal = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(ssEnd == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                    opVal = n2 + n1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ssEnd == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                    opVal = n2 - n1;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ssEnd == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    opVal = n2 * n1;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    opVal = n2 / n1;</span><br><span class="line">                &#125;</span><br><span class="line">                st.<span class="built_in">push</span>(opVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="滑动窗口最大值">239. 滑动窗口最大值</h3><p>注意单调栈判断条件；top查询应在代码逻辑最后 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; val &gt; dq.<span class="built_in">back</span>())&#123;</span><br><span class="line">            dq.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        dq.<span class="built_in">push_back</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() == val)&#123;</span><br><span class="line">            dq.<span class="built_in">pop_front</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dq.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        MyQueue mq;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; maxWin;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; <span class="built_in">i</span>&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            mq.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;(k<span class="number">-1</span>))&#123;</span><br><span class="line">                mq.<span class="built_in">pop</span>(nums[i-k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=(k<span class="number">-1</span>))&#123;</span><br><span class="line">                maxWin.<span class="built_in">push_back</span>(mq.<span class="built_in">top</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxWin;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="前-k-个高频元素">347.前 K 个高频元素</h3><p>注意operator()一定要是public的，因为小顶堆每次弹出堆顶最小元素所以最后要逆序填入vector<br />为什么priority_queue第三个参数要传入一个类？priority_queue只需要知道这个类的类型（模板参数），它会自己构造一个比较器对象myCompcomp 来比较元素 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">myComp</span>&#123;</span><br><span class="line">        <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp;rhs)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second;<span class="comment">// 插入元素判断为true时走入叶子节点，所以是小顶堆</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n:nums)&#123;</span><br><span class="line">            mp[n]++;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;, myComp&gt; priQue;</span><br><span class="line">        <span class="keyword">for</span>(unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator p = mp.<span class="built_in">begin</span>();p!=mp.<span class="built_in">end</span>();p++)&#123;</span><br><span class="line">            priQue.<span class="built_in">push</span>(*p);</span><br><span class="line">            <span class="keyword">if</span>(priQue.<span class="built_in">size</span>()&gt;k)priQue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            res[i] = priQue.<span class="built_in">top</span>().first;</span><br><span class="line">            priQue.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;逆波兰表达式求值&quot;&gt;150. 逆波兰表达式求值&lt;/h3&gt;
&lt;p&gt;细节很重要，注意数字可能有多位，有负数；数学表达式操作前后数字顺序影响结果
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-栈与队列</title>
    <link href="https://mackz-maxw.github.io/2025/05/22/kamacode9/"/>
    <id>https://mackz-maxw.github.io/2025/05/22/kamacode9/</id>
    <published>2025-05-22T21:28:26.144Z</published>
    <updated>2025-05-22T19:47:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用栈实现队列">232.用栈实现队列</h3><p>我的想法是一旦pop或者peek就把数据导到输出栈，输出后再一个一个push回去。看了题解有更简捷的方式：</p><blockquote><p>在push数据的时候，只要数据放进输入栈就好，但在pop的时候，操作就复杂一些，输出栈如果为空，就把进栈数据全部导入进来（注意是全部导入），再从出栈弹出数据，如果输出栈不为空，则直接从出栈弹出数据就可以了。最后如何判断队列为空呢？如果进栈和出栈都为空的话，说明模拟的队列为空了。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; inStack;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; outStack;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        inStack.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(outStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!inStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                outStack.<span class="built_in">push</span>(inStack.<span class="built_in">top</span>());</span><br><span class="line">                inStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> r = outStack.<span class="built_in">top</span>();</span><br><span class="line">        outStack.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        outStack.<span class="built_in">push</span>(r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> inStack.<span class="built_in">empty</span>() &amp;&amp; outStack.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="用队列实现栈">225. 用队列实现栈</h3><p>用一个队列实现的方法比较简洁。注意队列和栈两种数据结构的函数用法不一样<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> s = q.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            s--;</span><br><span class="line">            <span class="type">int</span> a = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            q.<span class="built_in">push</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> r = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> r = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        q.<span class="built_in">push</span>(r);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="有效的括号">20. 有效的括号</h3><p>注意一下几种可能遇到的错误情况即可 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; pairP;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c==<span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                pairP.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;)&#x27;</span> || c == <span class="string">&#x27;]&#x27;</span> || c == <span class="string">&#x27;&#125;&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pairP.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="type">char</span> lPair = pairP.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span>( (c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; lPair == <span class="string">&#x27;(&#x27;</span>) || (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; lPair == <span class="string">&#x27;[&#x27;</span>)||(c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; lPair == <span class="string">&#x27;&#123;&#x27;</span>))&#123;</span><br><span class="line">                    pairP.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!pairP.<span class="built_in">empty</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="删除字符串中的所有相邻重复项">1047.删除字符串中的所有相邻重复项</h3><p>有了前面的经验，这一题就相对简单了 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; adjStack;</span><br><span class="line">        string r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!adjStack.<span class="built_in">empty</span>() &amp;&amp; adjStack.<span class="built_in">top</span>() == c)&#123;</span><br><span class="line">                adjStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                adjStack.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!adjStack.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">char</span> c = adjStack.<span class="built_in">top</span>();</span><br><span class="line">            adjStack.<span class="built_in">pop</span>();</span><br><span class="line">            r.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r.<span class="built_in">empty</span>())<span class="keyword">return</span> r;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = r.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="type">char</span> e = r[left];</span><br><span class="line">            r[left] = r[right];</span><br><span class="line">            r[right] = e;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;用栈实现队列&quot;&gt;232.用栈实现队列&lt;/h3&gt;
&lt;p&gt;我的想法是一旦pop或者peek就把数据导到输出栈，输出后再一个一个push回去。看了题解有更简捷的方式：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在push数据的时候，只要数据放进输入栈就好，但在pop</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-字符串2</title>
    <link href="https://mackz-maxw.github.io/2025/05/22/kamacode8/"/>
    <id>https://mackz-maxw.github.io/2025/05/22/kamacode8/</id>
    <published>2025-05-22T21:28:25.904Z</published>
    <updated>2025-05-21T22:39:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="翻转字符串里的单词">151.翻转字符串里的单词</h3><p>需要注意反转的过程，不能想当然 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rev</span><span class="params">(<span class="type">char</span>* left, <span class="type">char</span>* right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> c = *left;</span><br><span class="line">            *left = *right;</span><br><span class="line">            *right = c;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        string ss;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;&quot;s[i]:&quot;&lt;&lt;s[i]&lt;&lt;endl;</span></span><br><span class="line">                ss.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(!ss.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="built_in">rev</span>(&amp;ss[<span class="number">0</span>], &amp;ss[ss.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">                    res.<span class="built_in">append</span>(ss);</span><br><span class="line">                    res.<span class="built_in">push_back</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                    ss = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!ss.<span class="built_in">empty</span>() &amp;&amp; ss[ss.<span class="built_in">size</span>()<span class="number">-1</span>] != <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">rev</span>(&amp;ss[<span class="number">0</span>], &amp;ss[ss.<span class="built_in">size</span>() - <span class="number">1</span>]);</span><br><span class="line">            res.<span class="built_in">append</span>(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res[res.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="string">&#x27; &#x27;</span>)res.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="卡码网55.右旋转字符串">卡码网：55.右旋转字符串</h3><p>一步一步输出看结果，总算是做对了 贴一下题目：</p><blockquote><p>字符串的右旋转操作是把字符串尾部的若干个字符转移到字符串的前面。给定一个字符串s 和一个正整数 k，请编写一个函数，将字符串中的后面 k个字符移到字符串的前面，实现字符串的右旋转操作。<br />例如，对于输入字符串 "abcdefg" 和整数 2，函数应该将其转换为"fgabcde"。<br />输入共包含两行，第一行为一个正整数 k，代表右旋转的位数。第二行为字符串s，代表需要旋转的字符串。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin&gt;&gt;k;</span><br><span class="line">    string s;</span><br><span class="line">    cin.<span class="built_in">ignore</span>();</span><br><span class="line">    <span class="built_in">getline</span>(cin, s);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;k:&quot;&lt;&lt;k&lt;&lt;&quot; s:&quot;&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">    string ss;</span><br><span class="line">    <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = (len - <span class="number">1</span>); i&gt;=(len-k);i--)&#123;</span><br><span class="line">        ss.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">        s.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout&lt;&lt;&quot;ss:&quot;&lt;&lt;ss&lt;&lt;&quot; s:&quot;&lt;&lt;s&lt;&lt;endl;</span></span><br><span class="line">    <span class="type">char</span>* left = &amp;ss[<span class="number">0</span>];</span><br><span class="line">    <span class="type">char</span>* right = &amp;ss[ss.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">char</span> c = *left;</span><br><span class="line">        *left = *right;</span><br><span class="line">        *right = c;</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    ss.<span class="built_in">append</span>(s);</span><br><span class="line">    cout&lt;&lt;ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现-strstr">28. 实现 strStr()</h3><p>使用KMP算法求最长相等前后缀的过程，实际上是在：</p><ul><li>后缀指针是外层循环</li><li>若前后缀判断不相等，前缀指针可以一直往前跳跃至上一个判断不相等的位置，直到长度计数归零或者找到相等位置。如果找到相等位置，则参考下一条将计数加一</li><li>重复利用之前已经判断相等的前后缀，如果一直相等，则长度每次都加一</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nextTable, string s)</span></span>&#123;</span><br><span class="line">        nextTable.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j])&#123;</span><br><span class="line">                j = nextTable[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable.<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; n;</span><br><span class="line">        <span class="built_in">getNext</span>(n, needle);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:n)&#123;</span><br><span class="line">            cout&lt;&lt;i;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;haystack.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; haystack[i] != needle[j])&#123;</span><br><span class="line">                j = n[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(haystack[i] == needle[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(j == needle.<span class="built_in">size</span>() - <span class="number">1</span>)<span class="keyword">return</span> i-j;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="重复的子字符串">459.重复的子字符串</h3><p>关键是数学证明：最长相等前后缀不包含的子串的长度 可以被字符串s的长度整除，那么不包含的子串 就是s的最小重复子串<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nextT;</span><br><span class="line">        nextT.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> j= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; s[i] != s[j])&#123;</span><br><span class="line">                j = nextT[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            nextT.<span class="built_in">push_back</span>(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>;k&lt;nextT.<span class="built_in">size</span>();k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nextT[k] == <span class="number">0</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> len = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(nextT.<span class="built_in">back</span>()!=<span class="number">0</span> &amp;&amp; (len % (len - j) == <span class="number">0</span>))<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;翻转字符串里的单词&quot;&gt;151.翻转字符串里的单词&lt;/h3&gt;
&lt;p&gt;需要注意反转的过程，不能想当然 &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 八股-网络模型</title>
    <link href="https://mackz-maxw.github.io/2025/05/22/kamabagu1/"/>
    <id>https://mackz-maxw.github.io/2025/05/22/kamabagu1/</id>
    <published>2025-05-22T21:28:25.818Z</published>
    <updated>2025-05-22T20:53:51.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="osi-模型和-tcpip-模型">OSI 模型和 TCP/IP 模型</h3><h4 id="osi-模型">OSI 模型</h4><p>开放式系统互联模型 七层 概念框架</p><ul><li>物理层：光纤，电缆等传输信号的物理通道</li><li>数据链路层：通过物理层网络连接两台计算机管理数据帧：封装在数据包中的电子信号 示例：以太网</li><li>网络层：多个互联网络的路由，转发和寻址 示例：IPv4, IPv6</li><li>传输层：传输控制，例如确保数据包以正确的顺序到达 示例：TCP，UDP</li><li>会话层：负责会话中两个独立应用程序之间的网络协调，管理一对一应用程序连接的开始和结束以及同步冲突。网络文件系统（NFS）和服务器消息块（SMB）是会话层的常用协议。</li><li>表示层：主要关注应用程序发送和使用的数据本身的语法。例如，超文本标记语言（HTML）、JavaScript对象标记（JSON）和逗号分隔值（CSV）</li><li>应用层：关注应用程序本身的特定类型及其标准化通信方法。例如，浏览器可以使用超文本传输安全协议（HTTPS）进行通信，而HTTP 和电子邮件客户端可以使用 POP3（邮局协议版本 3）和SMTP（简单邮件传输协议）进行通信。</li></ul><h4 id="tcpip-模型">TCP/IP 模型</h4><p>TCP/IP模型分为四个层级</p><ul><li>网络接口层：该层对应OSI模型的数据链路层和物理层。它负责物理传输媒介的传输，例如以太网、Wi-Fi等，并提供错误检测和纠正的功能。此外，网络接口层还包含硬件地址（MAC地址）的管理。</li><li>网络层：该层对应OSI模型的网络层。主要协议是IP，它负责数据包的路由和转发，选择最佳路径将数据从源主机传输到目标主机。IP协议使用IP地址来标识主机和网络，并进行逻辑地址寻址。<br /></li><li>传输层：对应OSI模型的传输层。服务应用。主要的传输层协议有TCP和UDP。TCP提供可靠的数据传输，确保数据的正确性和完整性；而UDP则是无连接的，适用于不要求可靠性的传输，如实时音频和视频流。</li><li>应用层：对应OSI模型的应用层和表示层以及会话层，面向用户，示例：电子邮件（SMTP）、网页浏览（HTTP）、文件传输（FTP）等。</li></ul><h3 id="从输入-url-到页面展示到底发生了什么">从输入 URL到页面展示到底发生了什么？</h3><ol type="1"><li>输入网址，解析URL信息，准备发送HTTP请求</li><li>检查浏览器缓存里是否有缓存该资源，如果有直接返回；如果没有进入下一步网络请求。</li><li>DNS域名解析：网络请求前，进行DNS解析，以获取请求域名的IP地址。DNS解析时会按本地浏览器缓存-&gt;本地Host文件-&gt;路由器缓存-&gt;DNS服务器-&gt;根DNS服务器的顺序查询域名对应IP，直到找到为止。</li><li>TCP三次握手建立连接：浏览器与服务器IP建立TCP连接。</li><li>客户端发送HTTP请求：连接建立后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的Cookie等数据附加到请求头中，向服务器构建请求信息。如果是HTTPS的话，还涉及到HTTPS的加解密流程。</li><li>服务器处理请求并返回HTTP资源：服务器接收到请求信息，根据请求生成响应数据。</li><li>TCP四次挥手断开连接：浏览器与服务器IP断开TCP连接。</li><li>浏览器解析响应并渲染页面：<ol type="1"><li>浏览器解析响应头。若响应头状态码为301、302，会重定向到新地址；若响应数据类型是字节流类型，一般会将请求提交给下载管理器；若是HTML类型，会进入下一部渲染流程。</li><li>浏览器解析HTML文件，创建DOM树，解析CSS进行样式计算，然后将CSS和DOM合并，构建渲染树；最后布局和绘制渲染树，完成页面展示。</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;osi-模型和-tcpip-模型&quot;&gt;OSI 模型和 TCP/IP 模型&lt;/h3&gt;
&lt;h4 id=&quot;osi-模型&quot;&gt;OSI 模型&lt;/h4&gt;
&lt;p&gt;开放式系统互联模型 七层 概念框架&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;物理层：光纤，电缆等传输信号的物理通道&lt;/li&gt;</summary>
      
    
    
    
    <category term="comp basic" scheme="https://mackz-maxw.github.io/categories/comp-basic/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-字符串</title>
    <link href="https://mackz-maxw.github.io/2025/05/21/kamacode7/"/>
    <id>https://mackz-maxw.github.io/2025/05/21/kamacode7/</id>
    <published>2025-05-21T14:18:29.572Z</published>
    <updated>2025-05-21T14:28:50.842Z</updated>
    
    <content type="html"><![CDATA[<h3 id="反转字符串">344.反转字符串</h3><p>双指针法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> h = s.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;h;i++)&#123;</span><br><span class="line">            <span class="type">char</span> c = s[i];</span><br><span class="line">            s[i] = s[j];</span><br><span class="line">            s[j] = c;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="反转字符串ii">541. 反转字符串II</h3><p>主要还是注意语法的学习 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rev</span><span class="params">(<span class="type">char</span>* left, <span class="type">char</span>* right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left&lt; right)&#123;</span><br><span class="line">            <span class="type">char</span> c = *left;</span><br><span class="line">            *left = *right;</span><br><span class="line">            *right = c;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> end = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p&lt;end)&#123;</span><br><span class="line">            n = p + k - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(n &lt;= end)&#123;</span><br><span class="line">                <span class="built_in">rev</span>(&amp;s[p], &amp;s[n]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">rev</span>(&amp;s[p], &amp;s[end]);</span><br><span class="line">            &#125;</span><br><span class="line">            p = p+ <span class="number">2</span>* k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="卡码网54.替换数字">卡码网：54.替换数字</h3><p>题目描述：</p><blockquote><p>给定一个字符串s，它包含小写字母和数字字符，请编写一个函数，将字符串中的字母字符保持不变，而将每个数字字符替换为number。<br />例如，对于输入字符串 "a1b2c3"，函数应该将其转换为"anumberbnumbercnumber"。<br />对于输入字符串 "a5b"，函数应该将其转换为 "anumberb"<br />输入：一个字符串 s,s 仅包含小写字母和数字字符。<br />输出：打印一个新的字符串，其中每个数字字符都被替换为了number<br />样例输入：a1b2c3<br />样例输出：anumberbnumbercnumber<br />数据范围：1 &lt;= s.length &lt; 10000</p></blockquote><p>主要是学习字符串输入输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string line, s;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: line)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">            s.<span class="built_in">append</span>(<span class="string">&quot;number&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            s.<span class="built_in">push_back</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;反转字符串&quot;&gt;344.反转字符串&lt;/h3&gt;
&lt;p&gt;双指针法 &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-哈希表2</title>
    <link href="https://mackz-maxw.github.io/2025/05/21/kamacode6/"/>
    <id>https://mackz-maxw.github.io/2025/05/21/kamacode6/</id>
    <published>2025-05-21T14:18:29.399Z</published>
    <updated>2025-05-21T14:27:36.904Z</updated>
    
    <content type="html"><![CDATA[<h3 id="四数相加ii">454. 四数相加II</h3><p>这道题目我没什么思路，看了题解是两组两组遍历，存储和的值和出现次数<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m1;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> a: nums1)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> b: nums2)&#123;</span><br><span class="line">                m1[a+b]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> c: nums3)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> d: nums4)&#123;</span><br><span class="line">                <span class="type">int</span> r = <span class="number">0</span>-(c+d);</span><br><span class="line">                <span class="keyword">if</span>(m1.<span class="built_in">find</span>(r) != m1.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    count += m1[r];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="赎金信">383. 赎金信</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: magazine)&#123;</span><br><span class="line">            m[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> cr: ransomNote)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(cr) == m.<span class="built_in">end</span>())<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            m[cr]--;</span><br><span class="line">            <span class="keyword">if</span>(m[cr]&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="三数之和">15. 三数之和</h3><p>这题我的思路可能就是暴力解了，看了题解发现可以在for循环里同时利用下标和双指针来解决<br />一开始想用set解决去重的问题，但是发现不排序的话去重还是有问题这题的去重套路，初始化等要注意的地方还是很多的，这一遍刷题我也只是照着题解的意思敲了一遍，以后还是得多加练习<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">// 遍历到第一个元素已经大于零，那么无论如何组合都不可能凑成三元组，可以剪枝</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)<span class="keyword">return</span> v;</span><br><span class="line">            <span class="type">int</span> left = i+<span class="number">1</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">            <span class="comment">// 错误去重第一个数方法，将会漏掉-1,-1,2 这种情况</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            if (nums[i] == nums[i + 1]) &#123;</span></span><br><span class="line"><span class="comment">                continue;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    v.<span class="built_in">push_back</span>(&#123;nums[i], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="comment">// 去重逻辑应该放在找到一个三元组之后，对b 和 c去重</span></span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>])&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums [right<span class="number">-1</span>])&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果判断找到答案，双指针同时收缩</span></span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//否则单向收缩</span></span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="四数之和">18. 四数之和</h3><p>还是看题解：</p><blockquote><p>四数之和的双指针解法是两层for循环<code>nums[k] + nums[i]</code>为确定值，依然是循环内有left和right下标作为双指针，找出<code>nums[k] + nums[i] + nums[left] + nums[right] == target</code>的情况，三数之和的时间复杂度是<span class="math inline">\(O(n^2)\)</span> ，四数之和的时间复杂度是<span class="math inline">\(O(n^3)\)</span><br />那么一样的道理，五数之和、六数之和等等都采用这种解法。<br />对于15.三数之和双指针法就是将原本暴力 <spanclass="math inline">\(O(n^3)\)</span> 的解法，降为 <spanclass="math inline">\(O(n^2)\)</span>的解法，四数之和的双指针解法就是将原本暴力 <spanclass="math inline">\(O(n^4)\)</span> 的解法，降为 <spanclass="math inline">\(O(n^3)\)</span> 的解法</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;<span class="number">4</span>)<span class="keyword">return</span> v;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;=<span class="number">0</span> &amp;&amp; nums[i]&gt; target)<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i<span class="number">-1</span>] == nums[i])<span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = (i+<span class="number">1</span>);j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="comment">// 第二级剪枝和去重，注意表达式变化</span></span><br><span class="line">                <span class="keyword">if</span>((nums[i] + nums[j])&gt;=<span class="number">0</span> &amp;&amp;(nums[i] + nums[j])&gt;target)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;(i+<span class="number">1</span>) &amp;&amp; nums[j<span class="number">-1</span>] == nums[j])<span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">int</span> left = j+<span class="number">1</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                    <span class="type">long</span> sum = (<span class="type">long</span>)nums[i]+nums[j]+nums[left]+nums[right];</span><br><span class="line">                    <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                        v.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[left],nums[right]&#125;);</span><br><span class="line">                        <span class="comment">//先去重，再移动指针到下一个判定位置</span></span><br><span class="line">                        <span class="keyword">while</span>(left&lt;right &amp;&amp; nums[left] == nums[left+<span class="number">1</span>])left++;</span><br><span class="line">                        <span class="keyword">while</span>(right&gt;left &amp;&amp; nums[right] == nums[right<span class="number">-1</span>])right--;</span><br><span class="line">                        right--;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;四数相加ii&quot;&gt;454. 四数相加II&lt;/h3&gt;
&lt;p&gt;这道题目我没什么思路，看了题解是两组两组遍历，存储和的值和出现次数
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;sp</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-哈希表</title>
    <link href="https://mackz-maxw.github.io/2025/05/21/kamacode5/"/>
    <id>https://mackz-maxw.github.io/2025/05/21/kamacode5/</id>
    <published>2025-05-21T14:18:29.183Z</published>
    <updated>2025-05-21T14:19:56.454Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据结构">数据结构</h3><p>在C++中，set 和 map分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><table style="width:100%;"><colgroup><col style="width: 13%" /><col style="width: 13%" /><col style="width: 18%" /><col style="width: 13%" /><col style="width: 13%" /><col style="width: 13%" /><col style="width: 13%" /></colgroup><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><table style="width:100%;"><colgroup><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /></colgroup><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的</p><h3 id="有效的字母异位词">242.有效的字母异位词</h3><p>基本上都是语法问题了，比如<code>m[c]</code>自动初始化（int则为0），pair的first和second都是成员变量<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: s)&#123;</span><br><span class="line">            m[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: t)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!m[c])<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            m[c]--;</span><br><span class="line">            <span class="keyword">if</span>(m[c]&lt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; p: m)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.second&gt;<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 349. 两个数组的交集</p><p>绞尽脑汁想半天如果结果有重复数字怎么办，结果是去重的。。。以后看题要更仔细呀！<br />题解里使用set的特性去重也挺巧思的 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function">unordered_set&lt;<span class="type">int</span>&gt; <span class="title">m</span><span class="params">(nums1.begin(), nums1.end())</span></span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n: nums2)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(n)!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                r.<span class="built_in">insert</span>(n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(r.<span class="built_in">begin</span>(),r.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 202. 快乐数</p><p>思路差不多了，还是有代码实现的问题，例如<code>to_string(int)</code>的用法,如何char转int等<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(nums.<span class="built_in">find</span>(n) == nums.<span class="built_in">end</span>())&#123;</span><br><span class="line">            nums.<span class="built_in">insert</span>(n);</span><br><span class="line">            string s = <span class="built_in">to_string</span>(n);</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">                <span class="type">int</span> num = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                sum += num*num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum == <span class="number">1</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            n = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 1. 两数之和</p><p>看到题目例子的时候我就觉得数组如果有两个一样的值，用哈希表就比较麻烦。先存数组所有值再判断会出现索引相等的问题。使用一个循环，先判断是否已有互补值，再存当前值进map，可以避免配对同一个元素<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; r;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt; nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="type">int</span> v = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(v) != m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                r.<span class="built_in">push_back</span>(i);</span><br><span class="line">                r.<span class="built_in">push_back</span>(m[v]);</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据结构&quot;&gt;数据结构&lt;/h3&gt;
&lt;p&gt;在C++中，set 和 map
分别提供以下三种数据结构，其底层实现以及优劣如下表所示：&lt;/p&gt;
&lt;table style=&quot;width:100%;&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 1</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-链表2</title>
    <link href="https://mackz-maxw.github.io/2025/05/16/kamacode4/"/>
    <id>https://mackz-maxw.github.io/2025/05/16/kamacode4/</id>
    <published>2025-05-16T15:56:32.183Z</published>
    <updated>2025-05-21T14:19:39.287Z</updated>
    
    <content type="html"><![CDATA[<h3 id="两两交换链表中的节点">24. 两两交换链表中的节点</h3><p>翻转链表加强版 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode* d = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">        ListNode* n = <span class="built_in">swapPairs</span>(head-&gt;next-&gt;next);</span><br><span class="line">        ListNode* r_pair = head-&gt;next;</span><br><span class="line">        d-&gt;next = r_pair;</span><br><span class="line">        r_pair-&gt;next = head;</span><br><span class="line">        head-&gt;next = n;</span><br><span class="line">        <span class="keyword">return</span> d-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 19.删除链表的倒数第N个节点</p><p>还是那个当整个链表删除时不能直接返回head的问题，多复制几个dummyhead就好了 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>, head);</span><br><span class="line">        ListNode* d = dummy;</span><br><span class="line">        ListNode* d2 = dummy;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;next)&#123;</span><br><span class="line">            d = d-&gt;next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;len: &quot;</span>&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">        <span class="type">int</span> rm = len - n<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(rm&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;rm: &quot;</span>&lt;&lt;rm&lt;&lt;<span class="string">&quot;d2 val&quot;</span>&lt;&lt;d2-&gt;val&lt;&lt;endl;</span><br><span class="line">            d2 = d2-&gt;next;</span><br><span class="line">            rm--;</span><br><span class="line">        &#125;</span><br><span class="line">        d2-&gt;next = d2-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 面试题 02.07. 链表相交 (leetcode 160)</p><p>本来想着可能需要挨个遍历节点是否相等找到相交节点，看了题解发现可以从共同长度同时往后搜索<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode* cur_a = headA;</span><br><span class="line">        ListNode* cur_b = headB;</span><br><span class="line">        <span class="type">int</span> len_a = <span class="number">0</span>, len_b = <span class="number">0</span>, e = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur_a)&#123;</span><br><span class="line">            len_a++;</span><br><span class="line">            cur_a = cur_a-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(cur_b)&#123;</span><br><span class="line">            len_b++;</span><br><span class="line">            cur_b = cur_b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur_a = headA;</span><br><span class="line">        cur_b = headB;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;len_a:&quot;</span>&lt;&lt;len_a&lt;&lt;<span class="string">&quot;len_b&quot;</span>&lt;&lt;len_b&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(len_a &gt; len_b)&#123;</span><br><span class="line">            e = len_a - len_b;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;e:&quot;</span>&lt;&lt;e&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">while</span>(e&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                e--;</span><br><span class="line">                cur_a = cur_a-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            e = len_b - len_a;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;e:&quot;</span>&lt;&lt;e&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">while</span>(e&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                e--;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;whiling&quot;</span>&lt;&lt;endl;</span><br><span class="line">                cur_b = cur_b-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;caval:&quot;</span>&lt;&lt;cur_a-&gt;val&lt;&lt;<span class="string">&quot;cbval:&quot;</span>&lt;&lt;cur_b-&gt;val&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">while</span>(cur_a || cur_b)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur_a == cur_b)<span class="keyword">return</span> cur_a;</span><br><span class="line">            cur_a = cur_a-&gt;next;</span><br><span class="line">            cur_b = cur_b-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 142.环形链表II</p><p>模糊记得俩指针相遇的地方有一些特性，还是得确定地记下来：从头结点出发一个指针，从相遇节点也出发一个指针，这两个指针每次只走一个节点，那么当这两个指针相遇的时候就是 环形入口的节点。两个指针都从head开始如何避免判断一开始这个点？看题解发现可以循环内先走next再判断,错误的初始化容易错过相遇点<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* h = head;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span>(slow &amp;&amp; fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)&#123;</span><br><span class="line">                ListNode* b = slow;</span><br><span class="line">                <span class="keyword">while</span>(b != h)&#123;</span><br><span class="line">                    b = b-&gt;next;</span><br><span class="line">                    h = h-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> h;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;两两交换链表中的节点&quot;&gt;24. 两两交换链表中的节点&lt;/h3&gt;
&lt;p&gt;翻转链表加强版 &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-链表</title>
    <link href="https://mackz-maxw.github.io/2025/05/16/kamacode3/"/>
    <id>https://mackz-maxw.github.io/2025/05/16/kamacode3/</id>
    <published>2025-05-16T14:26:06.919Z</published>
    <updated>2025-05-21T14:19:30.186Z</updated>
    
    <content type="html"><![CDATA[<h3 id="移除链表元素">203.移除链表元素</h3><p>这回刷题的思路总算对了，但是一开始直接返回head,没有考虑到万一整个链表全部需要删除，原有的链表相当于没动。设置了dummyhead就解决了。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* n = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        ListNode* dum = n;</span><br><span class="line">        <span class="keyword">while</span>(n &amp;&amp; n-&gt;next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n-&gt;next-&gt;val == val)&#123;</span><br><span class="line">                <span class="comment">// cout&lt;&lt;&quot;next val eq. cur val: &quot;&lt;&lt;n-&gt;val&lt;&lt;endl;</span></span><br><span class="line">                ListNode* link = n-&gt;next-&gt;next;</span><br><span class="line">                n-&gt;next = link;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                n = n-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dum-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 707.设计链表</p><p>设计了一个单链表<br />首先是结构体命名总是写错，应该注意检查这种问题。<br />dummy node 也需要在构造函数外声明才可以在其它函数中调用；<br />然后是尾部插入节点不需要再声明一个尾节点，直接插入即可，定义尾dummycode需要考虑的边界条件太多。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        ListNode* next;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> v): <span class="built_in">val</span>(v),<span class="built_in">next</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">        <span class="built_in">ListNode</span>(<span class="type">int</span> v, ListNode* n): <span class="built_in">val</span>(v), <span class="built_in">next</span>(n)&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ListNode* dummy;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!dummy-&gt;next) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        ListNode* d = dummy;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;get ind:&quot;</span>&lt;&lt;index&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">for</span>(;index&gt;=<span class="number">0</span>;index--)&#123;</span><br><span class="line">            d = d-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!d)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;index:&quot;</span>&lt;&lt;index&lt;&lt;<span class="string">&quot;getfor+1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="comment">// if(d-&gt;val == -1)return -1;</span></span><br><span class="line">        <span class="keyword">return</span> d-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">addAtIndex</span>(<span class="number">0</span>, val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if(dummy-&gt;next)</span></span><br><span class="line">        ListNode* d = dummy;</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;next)&#123;</span><br><span class="line">            d = d-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* d = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = index - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            d = d-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!d)<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if(!d || !d-&gt;next)return;</span></span><br><span class="line">        ListNode* n = <span class="keyword">new</span> <span class="built_in">ListNode</span>(val);</span><br><span class="line">        ListNode* link = d-&gt;next;</span><br><span class="line">        d-&gt;next = n;</span><br><span class="line">        n-&gt;next = link;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        ListNode* d = dummy;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = index - <span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            d = d-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(!d)<span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!d-&gt;next)<span class="keyword">return</span>;</span><br><span class="line">        d-&gt;next = d-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 206.反转链表</p><p>稀里糊涂地写对了...看了题解，发现这种做法相当于从后往前反转列表，结合以前的debug经验推导了一下这段代码会如何运行，有些理解了<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode* n = head-&gt;next;</span><br><span class="line">        ListNode* h = <span class="built_in">reverseList</span>(n);</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        n-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;移除链表元素&quot;&gt;203.移除链表元素&lt;/h3&gt;
&lt;p&gt;这回刷题的思路总算对了，但是一开始直接返回head,没有考虑到万一整个链表全部需要删除，原有的链表相当于没动。设置了dummy
head就解决了。 &lt;figure class=&quot;highlight cpp&quot;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-数组2</title>
    <link href="https://mackz-maxw.github.io/2025/05/14/kamacode2/"/>
    <id>https://mackz-maxw.github.io/2025/05/14/kamacode2/</id>
    <published>2025-05-14T18:46:08.756Z</published>
    <updated>2025-05-21T14:19:21.715Z</updated>
    
    <content type="html"><![CDATA[<h3 id="长度最小的子数组">209.长度最小的子数组</h3><p>不看题解的时候我的想法是在一个大循环里使用三个循环，先移动两个指针里右边指针的位置到和大于等于target，然后移动左指针到小于等于target,再开始移动右边指针。看了题解了解到可以在两个循环里操作两个指针完成上述操作，避免到处找边界条件。实际写的时候还是犯了一些小错误，例如sum的累加初始值，sum应该在何时减少等等，今后在更改代码的时候还是要注意细节。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>, k = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(;right&lt;nums.<span class="built_in">size</span>();right++)&#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="type">int</span> len;</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                len = right - left + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(len &lt; k)k = len;</span><br><span class="line">                sum -= nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// printf(&quot;left: %d, right: %d, len: %d, k:%d\n&quot;, left, right,len, k);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k == INT_MAX ? <span class="number">0</span> : k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ### 59.螺旋矩阵II</p><p>看到这道题目我的第一想法是整理出移动方向和当前数字所在位置i，j的关系。尝试写了一下感觉太复杂了，看了题解发现是每圈一次循环，每次循环处理四条边自己尝试着写了一下发现被每次循环加减的边界绕进去了，还是题解的方式比较清晰。题解强调的区间问题也要注意，不仅仅是每条边的循环条件，每次循环终止如何过渡到下次循环开始也是问题。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; mat;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;n;i++)&#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">row</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">            mat.<span class="built_in">push_back</span>(row);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> row = <span class="number">0</span>, col = <span class="number">0</span>, p = <span class="number">1</span>, c = n / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>, starty = <span class="number">0</span>, offset = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(c--)&#123;</span><br><span class="line">            row = starty;</span><br><span class="line">            col = startx;</span><br><span class="line">            <span class="keyword">for</span>(;col&lt;(n-offset);col++)&#123;</span><br><span class="line">                mat[row][col] = p;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;row&lt;(n-offset);row++)&#123;</span><br><span class="line">                mat[row][col] = p;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;col&gt;startx;col--)&#123;</span><br><span class="line">                mat[row][col] = p;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(;row&gt;starty;row--)&#123;</span><br><span class="line">                mat[row][col] = p;</span><br><span class="line">                p++;</span><br><span class="line">            &#125;</span><br><span class="line">            startx++;</span><br><span class="line">            starty++;</span><br><span class="line">            offset++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>)mat[n/<span class="number">2</span>][n/<span class="number">2</span>] = p;</span><br><span class="line">        <span class="keyword">return</span> mat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;长度最小的子数组&quot;&gt;209.长度最小的子数组&lt;/h3&gt;
&lt;p&gt;不看题解的时候我的想法是在一个大循环里使用三个循环，先移动两个指针里右边指针的位置到和大于等于target，然后移动左指针到小于等于target,再开始移动右边指针。看了题解了解到可以在两个循环里操作</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>代码随想录 | 刷题-数组</title>
    <link href="https://mackz-maxw.github.io/2025/05/13/kamacode1/"/>
    <id>https://mackz-maxw.github.io/2025/05/13/kamacode1/</id>
    <published>2025-05-14T03:19:17.104Z</published>
    <updated>2025-05-21T14:19:17.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数组基础与算法实现">数组基础与算法实现</h1><h2 id="数组基本特性">数组基本特性</h2><ul><li>数组下标从0开始</li><li>数组内存空间的地址是连续的</li><li>在C++中，二维数组在内存的空间地址是连续的</li></ul><h2 id="c常见数据类型长度">C++常见数据类型长度</h2><table><colgroup><col style="width: 17%" /><col style="width: 37%" /><col style="width: 44%" /></colgroup><thead><tr><th>数据类型</th><th>长度（字节）</th><th>备注</th></tr></thead><tbody><tr><td>char</td><td>1</td><td></td></tr><tr><td>short</td><td>2</td><td></td></tr><tr><td>int</td><td>4</td><td></td></tr><tr><td>long</td><td>4或8</td><td>取决于编译器和操作系统</td></tr><tr><td>long long</td><td>8</td><td></td></tr><tr><td>float</td><td>4</td><td></td></tr><tr><td>double</td><td>8</td><td></td></tr><tr><td>long double</td><td>8或16</td><td>取决于编译器和操作系统</td></tr><tr><td>bool</td><td>1</td><td>实际只使用1位</td></tr><tr><td>指针类型</td><td>4或8</td><td>取决于编译器和操作系统</td></tr></tbody></table><h2 id="算法实现">算法实现</h2><h3 id="二分查找">704. 二分查找</h3><h4 id="左闭右闭区间实现">左闭右闭区间实现</h4><p>原本仅判断left ==right，后来发现在处理仅两个元素，且target小于最小元素的数组时，这样写会导致left= 0同时right= -1,陷入死循环，更改判断条件后就解决了 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchid</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>, target, nums);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchid</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchid</span>(left, mid - <span class="number">1</span>, target, nums);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchid</span>(mid + <span class="number">1</span>, right, target, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h4 id="左闭右开区间实现">左闭右开区间实现</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchid</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>(), target, nums);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchid</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchid</span>(left, mid, target, nums);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">searchid</span>(mid + <span class="number">1</span>, right, target, nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="移除元素">27. 移除元素</h3><p>当target小于所有数时，right不断左移，left不变等于0，刚好结果应该是0。当target大于所有数时，right不会动，left不断右移直到nums.length，刚好等于结果。所以未找到时应返回left</p><p>我的方法从数组的两端向中间遍历，虽然也是双指针方法，但是需要不少额外判断。下一次要定义快慢指针去解题，因为实际上不用把所有查找的元素移动到数组最后，所以直接跳过这些元素复制即可：快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组慢指针：指向更新 新数组下标的位置 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[left] != val &amp;&amp; left &lt; right) left++;</span><br><span class="line">            <span class="keyword">while</span>(nums[left] == val &amp;&amp; left &lt; right) &#123;</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right] = val;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] != val) <span class="keyword">return</span> left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> left == <span class="number">0</span> ? <span class="number">0</span> : left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="有序数组的平方">977. 有序数组的平方</h3><p>这题我一开始总是想着在原数组中修改，于是想不出什么来。看了题解是新开一个数组，再左右指针遍历原数组，思路正确很快就做出来了：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> res_p = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(res_p &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[left]) &lt; <span class="built_in">abs</span>(nums[right])) &#123;</span><br><span class="line">                res[res_p] = <span class="built_in">pow</span>(nums[right], <span class="number">2</span>);</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[res_p] = <span class="built_in">pow</span>(nums[left], <span class="number">2</span>);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            res_p--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="c常用数学函数">C++常用数学函数</h2><ul><li><code>pow(x, y)</code>：计算x的y次方</li><li><code>sqrt(x)</code>：计算平方根</li><li><code>abs(x)</code>：计算绝对值</li><li><code>ceil(x)</code>：向上取整</li><li><code>floor(x)</code>：向下取整</li><li><code>round(x)</code>：四舍五入</li><li><code>max(x, y)</code>/<code>min(x, y)</code>：返回较大/较小值</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数组基础与算法实现&quot;&gt;数组基础与算法实现&lt;/h1&gt;
&lt;h2 id=&quot;数组基本特性&quot;&gt;数组基本特性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;数组下标从0开始&lt;/li&gt;
&lt;li&gt;数组内存空间的地址是连续的&lt;/li&gt;
&lt;li&gt;在C++中，二维数组在内存的空间地址是连续的&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>algorithm1-en</title>
    <link href="https://mackz-maxw.github.io/2025/01/21/algorithm1-en/"/>
    <id>https://mackz-maxw.github.io/2025/01/21/algorithm1-en/</id>
    <published>2025-01-21T12:36:03.000Z</published>
    <updated>2025-01-22T02:49:27.636Z</updated>
    
    <content type="html"><![CDATA[<p>I've been working on LeetCode problems for almost a week now, and Ifeel like my progress with algorithms is pretty slow—managing just oneor two problems a day seems like my limit.</p><p>I'm focusing on problems from the "Beginner Algorithms" section onLeetCode. Sometimes, I feel my memory is terrible; I realized I hadencountered some of these problems before in an introductory algorithmsbook but couldn't recall the solutions. I ended up solving them with themost inefficient methods...</p><p>I can foresee that learning techniques like two-pointers will takesome getting used to. It's tough! But I'll take it one step at atime.</p><p>(All problems below are from LeetCode's official website.)</p><h2 id="section">2/25-3/1</h2><h3 id="lc26.-remove-duplicates-from-sorted-array">LC26. RemoveDuplicates from Sorted Array</h3><p>You are given an array <code>nums</code> sorted in non-decreasingorder. Remove the duplicates in-place such that each unique elementappears only once. The relative order of the elements should be kept thesame. After removing the duplicates, return the new length of thearray.</p><p>Since some languages cannot change the size of the array, the finalresult must be placed in the first part of the array <code>nums</code>.More formally, if there are <code>k</code> elements after removing theduplicates, then the first <code>k</code> elements of <code>nums</code>should hold the final result.</p><p>Do not allocate extra space for another array. You must do this bymodifying the input array in-place with <spanclass="math inline">\(O(1)\)</span> extra memory.</p><p><span class="math display">\[\begin{aligned}&amp;\text{class Solution \{} \\&amp;\quad \text{public:} \\&amp;\quad \quad \text{int removeDuplicates(vector&lt;int&gt;\&amp;nums) \{} \\&amp;\quad \quad \quad \text{int a = 0;} \\&amp;\quad \quad \quad \text{int b = nums.size();} \\&amp;\quad \quad \quad \text{if (b &lt;= 1) return b;} \\&amp;\quad \quad \quad \text{for (int i = 0; i &lt; (b - 1); i++) \{} \\&amp;\quad \quad \quad \quad \text{if (nums[i] != nums[i + 1]) \{} \\&amp;\quad \quad \quad \quad \quad \text{nums[a] = nums[i];} \\&amp;\quad \quad \quad \quad \quad \text{a++;} \\&amp;\quad \quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{nums[a] = nums[b - 1];} \\&amp;\quad \quad \quad \text{return a + 1;} \\&amp;\quad \quad \text{\}} \\&amp;\text{\};}\end{aligned}\]</span></p><p>Here, I learned (again) about the two-pointer technique and refreshedmy long-unused C++ knowledge. I chose C++ mainly because many of thealgorithm and OpenCV books I previously studied use C++. Although I'veheard C++ interviews focus heavily on language features, it feels moresuitable than Python for understanding internal mechanisms. Python seemsto hide a lot of details, which might not be ideal for my coding stylelater.</p><p>This problem was manageable, but for problems involving in-placemodifications, it's essential to use<code>vector&lt;int&gt;&amp; nums</code> to pass by reference.</p><p>While solving this, I realized I had forgotten basic functions like<code>.size()</code>, <code>memset()</code>, and <code>.length()</code>.Sigh.</p><hr /><h3 id="lc122.-best-time-to-buy-and-sell-stock-ii">LC122. Best Time toBuy and Sell Stock II</h3><p>You are given an array <code>prices</code> where<code>prices[i]</code> is the price of a given stock on the<code>i</code>th day.</p><p>On each day, you may decide to buy and/or sell the stock. You canhold at most one share of the stock at any time. However, you can buy itand then sell it on the same day. Return the maximum profit you canachieve.</p><p><span class="math display">\[\begin{aligned}&amp;\text{class Solution \{} \\&amp;\quad \text{public:} \\&amp;\quad \quad \text{int maxProfit(vector&lt;int&gt;\&amp; prices) \{}\\&amp;\quad \quad \quad \text{int day = 0;} \\&amp;\quad \quad \quad \text{int count = 0;} \\&amp;\quad \quad \quad \text{bool st = false;} \\&amp;\quad \quad \quad \text{if (prices.size() == 1) return 0;} \\&amp;\quad \quad \quad \text{for (int i = 0; i &lt; prices.size() - 1;i++) \{} \\&amp;\quad \quad \quad \quad \text{if (prices[i] &lt; prices[i + 1]&amp;&amp; st == false) \{} \\&amp;\quad \quad \quad \quad \quad \text{day = i; st = true;} \\&amp;\quad \quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \quad \text{if (prices[i] &gt; prices[i + 1]&amp;&amp; st == true) \{} \\&amp;\quad \quad \quad \quad \quad \text{count += prices[i] -prices[day]; st = false;} \\&amp;\quad \quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{return count;} \\&amp;\quad \quad \text{\}} \\&amp;\text{\};}\end{aligned}\]</span></p><p>The above solution attempts to track local minima and maxima but ledto overly complex <code>if</code> conditions. A simpler approach issumming positive differences between consecutive days:</p><p><span class="math display">\[\begin{aligned}&amp;\text{class Solution \{} \\&amp;\quad \text{public:} \\&amp;\quad \quad \text{int maxProfit(vector&lt;int&gt;\&amp; prices) \{}\\&amp;\quad \quad \quad \text{int pf = 0;} \\&amp;\quad \quad \quad \text{for (int i = 0; i &lt; prices.size() - 1;i++) \{} \\&amp;\quad \quad \quad \quad \text{if (prices[i] &lt; prices[i + 1]) \{}\\&amp;\quad \quad \quad \quad \quad \text{pf += prices[i + 1] -prices[i];} \\&amp;\quad \quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{return pf;} \\&amp;\quad \quad \text{\}} \\&amp;\text{\};}\end{aligned}\]</span></p><p>This solution is concise and easier to understand, summing up profitswhenever prices go up.</p><hr /><h3 id="lc48.-rotate-image">LC48. Rotate Image</h3><p>You are given an <span class="math inline">\(n \times n\)</span> 2Dmatrix representing an image. Rotate the image by 90 degreesclockwise.</p><p><span class="math display">\[\begin{aligned}&amp;\text{class Solution \{} \\&amp;\quad \text{public:} \\&amp;\quad \quad \text{void rotate(vector&lt;vector&lt;int&gt;&gt;\&amp;matrix) \{} \\&amp;\quad \quad \quad \text{int n = matrix.size();} \\&amp;\quad \quad \quad \text{for (int i = 0; i &lt; n; i++) \{} \\&amp;\quad \quad \quad \quad \text{for (int j = i; j &lt; n; j++) \{} \\&amp;\quad \quad \quad \quad \quad \text{swap(matrix[i][j],matrix[j][i]);} \\&amp;\quad \quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{for (auto\&amp; row : matrix) \{reverse(row.begin(), row.end()); \}} \\&amp;\quad \quad \text{\}} \\&amp;\text{\};}\end{aligned}\]</span></p><p>First, transpose the matrix, then reverse each row to achieve the90-degree rotation.</p><p>After solving the problem using the approach of transposing thematrix followed by reversing the rows, I thought of an alternative way:reversing the rows first and then transposing the matrix.</p><p>This approach also works effectively and provides the same result.Here's how it looks:</p><p><span class="math display">\[\begin{aligned}&amp;\text{class Solution \{} \\&amp;\quad \text{public:} \\&amp;\quad \quad \text{void rotate(vector&lt;vector&lt;int&gt;&gt;\&amp;matrix) \{} \\&amp;\quad \quad \quad \text{reverse(matrix.begin(), matrix.end());} \\&amp;\quad \quad \quad \text{for (int i = 0; i &lt; matrix.size(); i++)\{} \\&amp;\quad \quad \quad \quad \text{for (int j = i; j &lt;matrix[i].size(); j++) \{} \\&amp;\quad \quad \quad \quad \quad \text{swap(matrix[i][j],matrix[j][i]);} \\&amp;\quad \quad \quad \quad \text{\}} \\&amp;\quad \quad \quad \text{\}} \\&amp;\quad \quad \text{\}} \\&amp;\text{\};}\end{aligned}\]</span></p><p>This version simplifies the triangle iteration by starting the innerloop at <code>j = i</code>. It reduces the code's complexity whilemaintaining clarity. However, I noticed that the memory usage wasslightly higher compared to my earlier implementation where I explicitlymanaged the triangular region with an additional variable. Toinvestigate further, I experimented with both versions on LeetCode'ssubmission platform. Interestingly, I found that memory usage sometimesfluctuated slightly for reasons I couldn't fully understand, possiblydue to internal optimizations in the runtime environment.</p><p>Ultimately, both methods provide the correct result, and the choicedepends on your preference for readability versus strict memorymanagement.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;I&#39;ve been working on LeetCode problems for almost a week now, and I
feel like my progress with algorithms is pretty slow—managing just o</summary>
      
    
    
    
    <category term="leetcode" scheme="https://mackz-maxw.github.io/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>fed_sched_int</title>
    <link href="https://mackz-maxw.github.io/2025/01/20/fed-sched-int/"/>
    <id>https://mackz-maxw.github.io/2025/01/20/fed-sched-int/</id>
    <published>2025-01-20T14:45:29.000Z</published>
    <updated>2025-01-22T02:30:04.079Z</updated>
    
    <content type="html"><![CDATA[<p>摘录一下Marion的论文要点，方便查阅</p><hr /><h3 id="任务模型">任务模型</h3><p>每个任务 <span class="math inline">\(\tau_i\)</span> 由一组子任务<span class="math inline">\(\tau_{i,j}\)</span>组成，并在其间具有优先关系 <spanclass="math inline">\(&lt;\)</span>。每个子任务 <spanclass="math inline">\(\tau_{i,j}\)</span> 的特征为： - 工作量 <spanclass="math inline">\(c_{i,j} \in\mathbb{N}\)</span>，表示其最坏情况下的执行时间。</p><p>子任务必须顺序执行，即它是一组必须按顺序完成的指令的集合，执行时间最长为<spanclass="math inline">\(c_{i,j}\)</span>。假设子任务执行是可重入的：执行可以被其他子任务抢占，且无需在系统中同一个核心上恢复。</p><p>优先关系限制了子任务的执行顺序，例如 <spanclass="math inline">\(\tau_{i,a} &lt; \tau_{i,b}\)</span>，则 <spanclass="math inline">\(\tau_{i,a}\)</span> 必须在 <spanclass="math inline">\(\tau_{i,b}\)</span> 之前完全执行。我们说，当任务<span class="math inline">\(\tau_{i,a}\)</span> 的所有前驱任务 <spanclass="math inline">\(\tau_{i,a&#39;}\)</span> 完成时，<spanclass="math inline">\(\tau_{i,a}\)</span> 变为“可用”（available）。</p><p>根据 [26]，我们将任务分为两类： 1. <strong>轻量任务（lighttasks）</strong>：满足 <span class="math inline">\(C_i &lt;D_i\)</span>； 2. <strong>重量任务（heavy tasks）</strong>：满足 <spanclass="math inline">\(C_i \geqD_i\)</span>，此类任务必须利用其潜在的并行性才能满足调度要求。</p><p>本文的重点是<strong>联合调度</strong>（federatedscheduling），对于每个重量任务，其被分配到一个专用核心集上并独占执行。我们仅考虑截止时间<span class="math inline">\(D_i\)</span> 和子任务工作量 <spanclass="math inline">\(c_{i,j}\)</span>为正整数的任务，称为<strong>整数值任务</strong>（integer-valuedtasks）。</p><hr /><h3 id="优先关系的dag表示">优先关系的DAG表示</h3><p>子任务执行的优先关系可表示为一个<strong>有向无环图（DAG）</strong>。对于每个并行任务<span class="math inline">\(\tau_i\)</span>，存在一个DAG <spanclass="math inline">\(G_i\)</span>，其包含的顶点集合为 <spanclass="math inline">\(v_{i,j}\)</span>，对应于任务 <spanclass="math inline">\(\tau_i\)</span> 的子任务 <spanclass="math inline">\(\tau_{i,j}\)</span>： - 每个顶点 <spanclass="math inline">\(v_{i,j}\)</span> 的属性为子任务的工作量 <spanclass="math inline">\(c_{i,j}\)</span>； - 边 <spanclass="math inline">\(v_{i,a} \to v_{i,b}\)</span> 存在当且仅当 <spanclass="math inline">\(\tau_{i,a} &lt; \tau_{i,b}\)</span> 且不存在 <spanclass="math inline">\(v_{i,c}\)</span> 满足 <spanclass="math inline">\(\tau_{i,a} &lt; \tau_{i,c} &lt;\tau_{i,b}\)</span>，即 <span class="math inline">\(v_{i,b}\)</span>直接继承 <span class="math inline">\(v_{i,a}\)</span>。</p><hr /><h3 id="关键路径长度的定义">关键路径长度的定义</h3><p>对于每个图顶点 <spanclass="math inline">\(v_{i,j}\)</span>，我们定义其<strong>关键路径长度</strong>或<strong>跨度</strong><span class="math inline">\(l_{i,j} \in \mathbb{N}\)</span>为从该顶点起始的最长路径的长度，该路径由沿路径每个顶点的执行时间（包括起始顶点的权重<span class="math inline">\(c_{i,j}\)</span>）加权。</p><p>对于相应的任务 <span class="math inline">\(\tau_i\)</span>，跨度<span class="math inline">\(L_i \in \mathbb{N}\)</span>是所有顶点的跨度中的最大值，即整个DAG的关键路径长度。跨度对应于任务在给定无限数量核心时相对于其激活时间的最早完成时间。</p><p>显然，为使任务可调度，必须满足： <span class="math display">\[L_i \leq D_i\]</span></p><h2 id="适用于整数值任务的联合调度">适用于整数值任务的联合调度</h2><p>对于一个重量任务 <spanclass="math inline">\(\tau_i\)</span>，其特征为工作量 <spanclass="math inline">\(C_i\)</span>、跨度 <spanclass="math inline">\(L_i\)</span> 和截止时间 <spanclass="math inline">\(D_i\)</span>，在提供足够核心的情况下，任何工作保留型（work-conserving，即贪婪型）调度器均可调度该任务。分配给任务<span class="math inline">\(\tau_i\)</span> 的核心数可以表示为： <spanclass="math display">\[n_i = \left\lceil \frac{C_i - L_i}{D_i - L_i} \right\rceil \tag{1}\]</span></p><p>我们在此证明，对于一个并行任务，如果其截止时间和所有子任务的工作量均为整数，则分配的核心数可以改进为：<span class="math display">\[n_i&#39; = \left\lceil \frac{C_i - L_i + 1}{D_i - L_i + 1} \right\rceil\]</span></p><p>这一公式比方程 (1)在限制重量任务的核心数方面提供了实际且直观的优势。</p><h2id="单工作量表调度unit-workload-list-scheduling">单工作量表调度（Unit-WorkloadList Scheduling）</h2><p>第4节中提出的联合调度方法为高利用率的整数值任务分配了足够的处理器，以保证任何工作保留型调度器的可行性，前提是给定每个任务的工作量、关键路径长度和截止时间。然而，这种常量时间的分配方法可能会导致对重量任务的处理器过度分配，进而造成资源浪费。</p><p>在 [3] 中，Graham 的表调度方法（listscheduling）被应用于重量任务；通过使用多种启发式方法为子任务排序，可以在更少的处理器上生成可行的调度。表调度以非抢占式方式将可用子任务分配给空闲处理器；如[14]所述，这可能导致对重量任务的处理器分配过多。然而，允许空闲子任务进行抢占可能会引入切换问题。</p><h3 id="方法改进">方法改进</h3><p>为了解决这个问题，我们提出了<strong>单工作量子任务的表调度</strong>。<br />- 一个整数值并行任务 <span class="math inline">\(\tau_i\)</span>，由DAG<span class="math inline">\(G_i\)</span>表示，可以被分解为一个包含单工作量顶点的DAG <spanclass="math inline">\(G_i^*\)</span>。<br />- 在 <span class="math inline">\(G_i\)</span> 中具有工作量 <spanclass="math inline">\(c\)</span> 的顶点 <spanclass="math inline">\(v_{i,j}\)</span>被映射为一个完全有序的顶点序列，在 <spanclass="math inline">\(G_i^*\)</span> 中形成从起点到终点的路径。</p><p>对于 <span class="math inline">\(G_i^*\)</span> 中的任何边 <spanclass="math inline">\(v_{i,j}\)</span>，其连接方式如下： 1. <spanclass="math inline">\(G_i^*\)</span> 中进入 <spanclass="math inline">\(v_{i,j}\)</span>的任何边连接到其分解后路径中的第一个顶点； 2. 在 <spanclass="math inline">\(G_i\)</span> 中离开 <spanclass="math inline">\(v_j\)</span> 的任何边，现在连接到 <spanclass="math inline">\(v_{i,j}\)</span> 的分解路径中的最后一个顶点。</p><h3 id="优势">优势</h3><p>对于这样的DAG，表调度方法可以为每个单位工作量分配一个优先级；<br />这使得原始DAG <span class="math inline">\(G_i\)</span>中的相应子任务能够在单位时间步边界内被抢占。</p><h3 id="常见的表调度启发式方法">5.1 常见的表调度启发式方法</h3><h4 id="关键路径规则critical-path-rule-cp">关键路径规则（Critical PathRule, CP）</h4><p>关键路径规则用于表调度时，以<strong>最长跨度</strong>的顺序选择可用子任务进行执行。<br />-子任务跨度的分配可以以深度优先搜索的方式完成；当为每个顶点分配跨度后，图的总跨度<span class="math inline">\(L\)</span> 会被更新。 - 该过程的时间复杂度为<span class="math inline">\(O(|V| + |E|)\)</span>。</p><h4 id="dag分解">DAG分解</h4><p>DAG <span class="math inline">\(G\)</span> 分解为单位工作量的 DAG<span class="math inline">\(G^*\)</span> 的过程表示为函数<strong>Convert_Unit_DAG</strong>： 1. 初始化 <spanclass="math inline">\(G^*\)</span> 为 <spanclass="math inline">\(G\)</span> 的副本。 2. 建立一个顶点集合 <spanclass="math inline">\(V^*\)</span>，其由 <spanclass="math inline">\(G^*\)</span>中的顶点（实际代码中可能为指向顶点的指针）组成。 3. 对于 <spanclass="math inline">\(V^*\)</span> 中的每个顶点 <spanclass="math inline">\(v_i\)</span>： - 将 <spanclass="math inline">\(v_i\)</span> 的工作量 <spanclass="math inline">\(c_i\)</span> 转化为单位工作量顶点序列，这些顶点在<span class="math inline">\(G^*\)</span> 中形成路径： -路径中的每个顶点之间用边连接，第一个顶点的跨度等于 <spanclass="math inline">\(v_i\)</span> 的跨度 <spanclass="math inline">\(l_i\)</span>； -每个后续顶点的跨度比前一个顶点小1。 - 删除原始顶点 <spanclass="math inline">\(v_i\)</span>。</p><ol start="4" type="1"><li>处理完成后，<span class="math inline">\(G^*\)</span>中仅包含单位工作量的顶点：<ul><li>通过分解，生成了 <span class="math inline">\(C - |V|\)</span>个额外顶点，以及 <span class="math inline">\(C - |V|\)</span>条额外边。</li><li>因此，总运行时间为 <span class="math inline">\(O(|V| + C - |V| + |E|+ C - |V|)\)</span>，简化为 <span class="math inline">\(O(C +|E|)\)</span>。</li></ul></li></ol><h4id="后继数量规则largest-number-of-successors-rule-lns">后继数量规则（LargestNumber of Successors Rule, LNS）</h4><p>LNS规则以<strong>后继任务的总工作量</strong>为顺序，选择可用子任务进行执行：- 子任务 <span class="math inline">\(v_i \in G\)</span> 的后继工作量由与<span class="math inline">\(v_i\)</span>通过路径相连的所有顶点的工作量之和定义。 -可以通过动态规划在整个图上实现这一过程，其时间复杂度为 <spanclass="math inline">\(O(|V| + |E|)\)</span>。</p><p>LNS规则也可以应用于单位工作量子任务的表调度，并保持伪多项式时间复杂度。</p><h4 id="注意">注意</h4><p>将整数值任务的 DAG <span class="math inline">\(G\)</span>分解为单位工作量的 DAG <span class="math inline">\(G^*\)</span>时，还需要为每个单位工作量顶点分配一个子图工作量。这与跨度的分配类似，不会影响算法的时间复杂度。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;摘录一下Marion的论文要点，方便查阅&lt;/p&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;任务模型&quot;&gt;任务模型&lt;/h3&gt;
&lt;p&gt;每个任务 &lt;span class=&quot;math inline&quot;&gt;\(\tau_i\)&lt;/span&gt; 由一组子任务
&lt;span class=&quot;math </summary>
      
    
    
    
    <category term="realtime sched" scheme="https://mackz-maxw.github.io/categories/realtime-sched/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux联合调度相关</title>
    <link href="https://mackz-maxw.github.io/2025/01/18/federated_sched/"/>
    <id>https://mackz-maxw.github.io/2025/01/18/federated_sched/</id>
    <published>2025-01-18T19:39:54.270Z</published>
    <updated>2025-01-22T02:30:10.613Z</updated>
    
    <content type="html"><![CDATA[<p>摘录一下Jing Li的论文要点，方便查阅</p><hr /><h2 id="性能界限的定义">性能界限的定义</h2><p>通常，可以为实时调度器推导出两种类型的性能界限：</p><ol type="1"><li><strong>资源增益界限</strong>（Resource Augmentation Bound）：<br />调度器 <span class="math inline">\(S\)</span> 提供一个资源增益界限 <spanclass="math inline">\(b \geq 1\)</span>，如果理想调度器能够在 <spanclass="math inline">\(m\)</span> 个速度为 1 的核心上调度任何任务集 <spanclass="math inline">\(\tau\)</span>，它能够在 <spanclass="math inline">\(m\)</span> 个速度为 <spanclass="math inline">\(b\)</span> 的核心上成功调度 <spanclass="math inline">\(\tau\)</span>。<ul><li>资源增益界限很好地反映了调度器与最优调度的接近程度，但有一个缺点：理想调度器只是一个假设的调度器，它总能找到一个可行调度（如果存在）。<br /></li><li>由于无法验证理想调度器是否能够在单位速度核心上调度给定任务集，因此资源增益界限无法提供可调度性测试。</li></ul></li><li><strong>利用率界限</strong>（Utilization Bound）：<br />调度器 <span class="math inline">\(S\)</span> 提供一个利用率界限 <spanclass="math inline">\(b\)</span>，如果它能够在 <spanclass="math inline">\(m\)</span>个核心上成功调度任何任务集，其总利用率不超过 <spanclass="math inline">\(m/b\)</span>。<ul><li>利用率界限比资源增益界限提供了更多信息：任何保证利用率界限 <spanclass="math inline">\(b\)</span> 的调度器都会自动保证资源增益界限 <spanclass="math inline">\(b\)</span>。<br /></li><li>此外，利用率界限本身是一种简单的可调度性测试，因为任务集的总利用率可以在线性时间内计算，并与<span class="math inline">\(m/b\)</span> 进行比较。</li></ul></li></ol><p>注意这些界限讨论的是调度的相对效率，而不是程序执行的速度，所以b值越小，调度更有效率。</p><ol start="3" type="1"><li><strong>容量增益界限</strong> Li 等人 [35]定义了一个名为<strong>容量增益界限</strong>（capacity augmentationbound）的概念，这一概念与利用率界限类似，但增加了一个新条件：<br />调度器 <span class="math inline">\(S\)</span> 提供容量增益界限 <spanclass="math inline">\(b\)</span>，如果它能够调度满足以下两个条件的任何任务集<span class="math inline">\(\tau\)</span>：</li></ol><ul><li><span class="math inline">\(\tau\)</span> 的总利用率最多为 <spanclass="math inline">\(m/b\)</span>；</li><li>每个任务的最差情况关键路径长度 <spanclass="math inline">\(L_i\)</span>（即在无限核心上的执行时间）最多为其截止时间的<span class="math inline">\(1/b\)</span> 的比例。</li></ul><p>容量增益界限与利用率界限非常相似，但它提供的信息比资源增益界限更多：<br />- 任何保证容量增益界限为 <span class="math inline">\(b\)</span>的调度器也自动保证资源增益界限为 <spanclass="math inline">\(b\)</span>。<br />-它同样可以作为一种简单的可调度性测试，并提供对系统可承受负载的估计。</p><hr /><h2 id="策略分类">策略分类</h2><p>最近的研究主要集中在为并行任务的各种调度策略证明<strong>资源增益界限</strong>和<strong>容量增益界限</strong>。这些工作可以分为两类：1. <strong>基于分解的策略</strong>（Decomposition-basedstrategies）：<br />并行任务被分解为一组顺序任务，并使用现有的顺序任务调度策略在多处理器上进行调度。这些策略通常需要事先明确DAG的结构，以便进行分解。</p><ol start="2" type="1"><li><strong>非分解策略</strong>（Non-decomposition-basedstrategies）：<br />程序可以动态展开，因此不需要离线知识。研究主要集中在两种调度策略上：</li></ol><hr /><h2 id="主要贡献">主要贡献</h2><p>本文的主要贡献如下： 1.<strong>提出了一种新的联合调度策略</strong>（federated schedulingstrategy）：<br />- 在此策略中，每个<strong>高利用率任务</strong>（利用率 ≥1）被分配到一个专用的核心集（cluster）。<br />-一个多处理器调度算法用于调度所有<strong>低利用率任务</strong>，这些任务依次运行在由剩余核心组成的共享核心集上。<br />- 联合调度可以看作是分区调度策略的推广，适用于并行任务。<br />- 这是目前已知的针对任意并行 DAG 调度器的最佳容量增益界限。</p><ol start="2" type="1"><li><p><strong>证明联合调度的容量增益界限为 2</strong>：<br />此外，我们还证明了没有任何调度器能够为并行任务提供比 <spanclass="math inline">\(2 - 1/m\)</span> 更好的容量增益界限。<br />因此，当 <span class="math inline">\(m\)</span>足够大时，联合调度的界限为 2 是最优的。</p></li><li><p><strong>改进了 G-EDF 的容量增益界限</strong>：<br />对于 DAG 任务，G-EDF 的容量增益界限被改进为<br /><span class="math display">\[\frac{3 + \sqrt{5}}{2} \approx 2.618\]</span> 当 <span class="math inline">\(m\)</span> 足够大时，G-EDF的容量增益界限达到这一匹配的下界。因此，这一结果填补了大 <spanclass="math inline">\(m\)</span>场景下的间隙，这是目前已知针对任意全局调度器的最佳容量增益界限。</p></li><li><p><strong>证明 G-RM 的容量增益界限为</strong> <spanclass="math inline">\(2 + \sqrt{3} \approx 3.732\)</span> ：</p><ul><li>这是目前已知针对任何固定优先级调度器的 DAG任务的最佳容量增益界限。<br /></li><li>即使仅限于同步任务，这仍是基于全局固定优先级调度（且无需分解）的最佳界限。</li></ul></li></ol><hr /><h2 id="系统模型">系统模型</h2><p>我们现在详细描述并行任务的DAG模型以及一些附加定义。</p><p>我们考虑一个由 <span class="math inline">\(n\)</span>个独立的间歇性实时任务 <span class="math inline">\(\tau = \{\tau_1,\tau_2, \dots, \tau_n\}\)</span> 组成的任务集。任务 <spanclass="math inline">\(\tau_i\)</span>表示任务实例（也称为作业）的无限到达和执行序列。我们考虑<strong>间歇性任务模型</strong>，其中对于任务<span class="math inline">\(\tau_i\)</span>： -<strong>最小间隔时间</strong>（或周期）<spanclass="math inline">\(T_i\)</span> 表示连续任务实例到达之间的时间； -<strong>相对截止时间</strong> <span class="math inline">\(D_i\)</span>表示完成作业的时间约束。</p><p>如果任务实例 <span class="math inline">\(\tau_i\)</span> 在时间 <spanclass="math inline">\(t\)</span> 到达，则其执行必须在绝对截止时间 <spanclass="math inline">\(t + D_i\)</span>之前完成，且下一个任务实例不能早于 <span class="math inline">\(t +T_i\)</span> 到达。<br />在本文中，我们考虑<strong>隐式截止时间任务</strong>，即每个任务 <spanclass="math inline">\(\tau_i\)</span> 的相对截止时间 <spanclass="math inline">\(D_i\)</span> 等于其最小间隔时间 <spanclass="math inline">\(T_i\)</span>，即 <span class="math inline">\(T_i =D_i\)</span>。</p><p>我们研究在具有 <span class="math inline">\(m\)</span>个相同核心的多核系统上调度这些任务集的可调度性。</p><h3 id="dag任务的特性">DAG任务的特性</h3><p>每个任务 <span class="math inline">\(\tau_i \in \tau\)</span>是一个并行任务，并被描述为一个<strong>有向无环图（DAG）</strong>。<br />- DAG中的每个节点（子任务）表示指令序列（一个线程），每条边表示节点之间的依赖关系。- 当一个节点的所有前驱节点完成时，该节点准备好执行。</p><p>在本文中，由于不需要基于DAG的具体结构进行分析，仅定义了与任务 <spanclass="math inline">\(\tau_i\)</span> 的执行模式相关的两个参数：</p><ol type="1"><li><p><strong>总执行时间（或工作量）<spanclass="math inline">\(C_i\)</span></strong>：<br />这是任务 <span class="math inline">\(\tau_i\)</span>的所有子任务在最坏情况下的执行时间总和。</p></li><li><p><strong>关键路径长度 <spanclass="math inline">\(L_i\)</span></strong>：<br />在给定DAG中，这是关键路径的长度，其中每个节点由对应子任务的最坏情况下执行时间表示。<br />关键路径长度是任务在无限核心下的最坏情况下执行时间。</p></li></ol><p>给定一个DAG，计算 <span class="math inline">\(C_i\)</span> 和 <spanclass="math inline">\(L_i\)</span> 都可以在线性时间内完成。</p><h3 id="任务的利用率">任务的利用率</h3><ul><li>任务 <span class="math inline">\(\tau_i\)</span>的<strong>利用率</strong>定义为 <span class="math inline">\(u_i =\frac{C_i}{T_i} = \frac{C_i}{D_i}\)</span>。<br /></li><li>任务集的总利用率表示为： <span class="math display">\[U_\Sigma = \sum_{\tau_i \in \tau} u_i\]</span></li></ul><hr /><h2 id="基于利用率的可调度性测试">基于利用率的可调度性测试</h2><p>在本文中，我们从容量增益界限的角度分析调度器。形式化定义如下：</p><h3 id="定义-1">定义 1</h3><p>给定总利用率为 <span class="math inline">\(U_\Sigma\)</span> 的任务集<span class="math inline">\(\tau\)</span>，如果调度算法 <spanclass="math inline">\(S\)</span> 在 <spanclass="math inline">\(m\)</span> 个速度为 <spanclass="math inline">\(b\)</span> 的核心上总能调度 <spanclass="math inline">\(\tau\)</span>，且满足以下条件，则其容量增益界限为<span class="math inline">\(b\)</span>：</p><ol type="1"><li><p><strong>利用率限制条件</strong>：<br /><span class="math display">\[\sum_{\tau_i \in \tau} u_i \leq \frac{m}{b}\]</span></p></li><li><p><strong>关键路径限制条件</strong>：<br />对于每个任务 <span class="math inline">\(\tau_i \in \tau\)</span>：<span class="math display">\[L_i \leq \frac{D_i}{b}\]</span></p></li></ol><h3 id="说明">说明</h3><ul><li>条件 (1) 表示任务集的总利用率不超过 <spanclass="math inline">\(m/b\)</span>。</li><li>条件 (2) 表示每个任务的关键路径长度不超过其相对截止时间的 <spanclass="math inline">\(1/b\)</span>。</li></ul><p>因此，为了验证任务集是否可调度，我们只需知道任务集的总利用率和最大关键路径利用率即可。</p><p>当 <span class="math inline">\(b = 1\)</span> 时，<spanclass="math inline">\(S\)</span> 是一个理想调度器；调度器的 <spanclass="math inline">\(b\)</span> 越小，其性能越优。</p><h2 id="iii.-联合调度federated-scheduling">III. 联合调度（FederatedScheduling）</h2><h3 id="a.-联合调度算法federated-scheduling-algorithm">A.联合调度算法（Federated Scheduling Algorithm）</h3><p>给定任务集 <spanclass="math inline">\(\tau\)</span>，联合调度算法的工作流程如下：</p><ol type="1"><li>首先，将任务划分为两个不相交的集合：<ul><li><span class="math inline">\(\tau_{\text{high}}\)</span>包含所有<strong>高利用率任务</strong>，即利用率至少为 1 的任务（<spanclass="math inline">\(u_i \geq 1\)</span>）。<br /></li><li><span class="math inline">\(\tau_{\text{low}}\)</span>包含所有剩余的<strong>低利用率任务</strong>。</li></ul></li></ol><p>考虑一个高利用率任务 <spanclass="math inline">\(\tau_i\)</span>，其最坏情况下执行时间为 <spanclass="math inline">\(C_i\)</span>，关键路径长度为 <spanclass="math inline">\(L_i\)</span>，截止时间为 <spanclass="math inline">\(D_i\)</span>（与其周期 <spanclass="math inline">\(T_i\)</span> 相等）。我们为任务 <spanclass="math inline">\(\tau_i\)</span> 分配 <spanclass="math inline">\(n_i\)</span> 个专用核心，其中： <spanclass="math display">\[n_i = \left\lceil \frac{C_i - L_i}{D_i - L_i} \right\rceil\]</span></p><ol start="2" type="1"><li><p>我们使用以下公式计算分配给高利用率任务的核心总数： <spanclass="math display">\[n_{\text{high}} = \sum_{\tau_i \in \tau_{\text{high}}} n_i\]</span></p></li><li><p>剩余的核心被分配给所有低利用率任务 <spanclass="math inline">\(\tau_{\text{low}}\)</span>，其核心数为： <spanclass="math display">\[n_{\text{low}} = m - n_{\text{high}}\]</span></p></li></ol><p>如果 <span class="math inline">\(n_{\text{low}}\)</span>非负且满足以下条件： <span class="math display">\[n_{\text{low}} \geq 2 \sum_{\tau_i \in \tau_{\text{low}}} u_i\]</span> 则联合调度算法接受任务集 <spanclass="math inline">\(\tau\)</span>。</p><h3 id="运行时调度runtime-scheduling">运行时调度（RuntimeScheduling）</h3><p>在有效的核心分配之后，运行时调度过程如下：</p><ol type="1"><li><strong>高利用率任务的调度</strong>：<ul><li>使用任何贪婪调度器（greedy scheduler）对高利用率任务 <spanclass="math inline">\(\tau_i\)</span> 进行调度。<br /></li><li>贪婪调度器确保当某节点准备好执行时，不会让核心处于空闲状态。</li></ul></li><li><strong>低利用率任务的调度</strong>：<ul><li>将低利用率任务视为顺序任务，并使用任何多处理器调度算法（如分区EDF或速率单调调度器）进行调度。<br /></li><li>低利用率任务的总利用率最多为 <spanclass="math inline">\(1/2\)</span>，因此可以在分配的 <spanclass="math inline">\(n_{\text{low}}\)</span> 核心上进行调度。</li></ul></li></ol><h3 id="关键点">关键点</h3><p>联合调度算法的一个重要特性是：我们可以安全地将低利用率任务视为顺序任务，因为<span class="math inline">\(C_i \leqD_i\)</span>，这表明这些任务在其截止时间内完成时不需要并行执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;摘录一下Jing Li的论文要点，方便查阅&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;性能界限的定义&quot;&gt;性能界限的定义&lt;/h2&gt;
&lt;p&gt;通常，可以为实时调度器推导出两种类型的性能界限：&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;strong&gt;资源增益界限&lt;/str</summary>
      
    
    
    
    <category term="realtime sched" scheme="https://mackz-maxw.github.io/categories/realtime-sched/"/>
    
    
  </entry>
  
  <entry>
    <title>Linux调度算法相关4</title>
    <link href="https://mackz-maxw.github.io/2025/01/04/linux_sched4/"/>
    <id>https://mackz-maxw.github.io/2025/01/04/linux_sched4/</id>
    <published>2025-01-05T03:00:13.516Z</published>
    <updated>2025-01-22T02:30:43.409Z</updated>
    
    <content type="html"><![CDATA[<h3 id="检索调度策略和优先级">检索调度策略和优先级</h3><ol type="1"><li><strong><code>sched_getscheduler()</code> 和<code>sched_getparam()</code> 系统调用</strong>：<ul><li>这两个系统调用可以检索进程的调度策略和优先级。</li></ul></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_getscheduler</span><span class="params">(<span class="type">pid_t</span> pid)</span>;</span><br><span class="line"><span class="comment">//返回调度策略，成功时返回调度策略标识符，出错时返回 -1。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_getparam</span><span class="params">(<span class="type">pid_t</span> pid, <span class="keyword">struct</span> sched_param *param)</span>;</span><br><span class="line"><span class="comment">//成功时返回 0，出错时返回 -1。</span></span><br></pre></td></tr></table></figure><h3id="调度参数和优先级获取的系统调用说明">调度参数和优先级获取的系统调用说明</h3><p>对于这两个系统调用（<code>sched_getscheduler</code> 和<code>sched_getparam</code>），<code>pid</code> 指定了要获取信息的进程ID。如果 <code>pid</code> 为 0，则获取调用进程的信息。<br />不论是否具有特权，这两个系统调用都可用于非特权进程，以获取任何进程的信息，无需凭证。</p><p><code>sched_getparam()</code> 系统调用在 <code>sched_param</code>结构体中的 <code>sched_priority</code>字段中返回指定进程的实时优先级。</p><hr /><h3 id="示例用法">示例用法</h3><p>成功执行后，<code>sched_getscheduler()</code> 返回表 35-1中列出的策略之一。<br />Listing 35-3 中的程序使用 <code>sched_getscheduler()</code> 和<code>sched_getparam()</code>来获取命令行参数指定的所有进程的调度策略和优先级。<br />下面的 shell 会话演示了该程序和 Listing 35-2 中的程序的使用方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ su  </span><br><span class="line">Password:  </span><br><span class="line"><span class="comment"># sleep 100 &amp;    # 创建一个进程</span></span><br><span class="line">[1] 2006  </span><br><span class="line"><span class="comment"># ./sched_view 2006    # 查看 sleep 进程的初始调度策略和优先级</span></span><br><span class="line">2006: OTHER 0  </span><br><span class="line"><span class="comment"># ./sched_set f 25 2006    # 将进程 2006 切换为 SCHED_FIFO 策略，优先级为 25</span></span><br><span class="line"><span class="comment"># ./sched_view 2006        # 验证修改</span></span><br><span class="line">2006: FIFO 25  </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j, pol;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">sp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        pol = sched_getscheduler(getLong(argv[j], <span class="number">0</span>, <span class="string">&quot;pid&quot;</span>)); <span class="comment">// 获取调度策略</span></span><br><span class="line">        <span class="keyword">if</span> (pol == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;sched_getscheduler&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sched_getparam(getLong(argv[j], <span class="number">0</span>, <span class="string">&quot;pid&quot;</span>), &amp;sp) == <span class="number">-1</span>) <span class="comment">// 获取调度参数</span></span><br><span class="line">            errExit(<span class="string">&quot;sched_getparam&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s: %-5s %2d\n&quot;</span>, argv[j],</span><br><span class="line">            (pol == SCHED_OTHER) ? <span class="string">&quot;OTHER&quot;</span> :     <span class="comment">// 普通调度策略</span></span><br><span class="line">            (pol == SCHED_RR) ? <span class="string">&quot;RR&quot;</span> :          <span class="comment">// 轮转调度策略</span></span><br><span class="line">            (pol == SCHED_FIFO) ? <span class="string">&quot;FIFO&quot;</span> :      <span class="comment">// 先进先出调度策略</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_BATCH                            <span class="comment">// Linux特定调度策略</span></span></span><br><span class="line">            (pol == SCHED_BATCH) ? <span class="string">&quot;BATCH&quot;</span> :</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_IDLE                             <span class="comment">// Linux特定空闲调度策略</span></span></span><br><span class="line">            (pol == SCHED_IDLE) ? <span class="string">&quot;IDLE&quot;</span> :</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="string">&quot;???&quot;</span>,                             <span class="comment">// 未知调度策略</span></span><br><span class="line">            sp.sched_priority);                <span class="comment">// 优先级</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="防止实时进程锁死系统">防止实时进程锁死系统</h3><p>由于 <strong>SCHED_RR</strong> 和 <strong>SCHED_FIFO</strong>进程会抢占任何低优先级的进程（例如运行程序的shell），在开发使用这些策略的应用程序时，我们需要注意一个可能的风险：一个失控的实时进程可能会通过占用CPU导致系统锁死。为避免这种情况，可以采用以下几种方法：</p><ul><li><p><strong>设置一个足够低的软CPU时间资源限制（<code>RLIMIT_CPU</code>）</strong><br />使用 <code>setrlimit()</code>函数（参考第36.3节）来设置。如果进程消耗了过多的CPU时间，将会被发送一个<code>SIGXCPU</code> 信号，该信号默认会杀死进程。</p></li><li><p><strong>使用 <code>alarm()</code> 设置报警计时器</strong><br />如果进程运行的实际时间超过了 <code>alarm()</code>调用中指定的秒数，则会被发送一个 <code>SIGALRM</code>信号并被终止。</p></li><li><p><strong>创建一个具有高实时优先级的守护进程</strong><br />该进程可以循环运行，按照指定的间隔睡眠，然后唤醒并监视其他进程的状态。此类监视可以包括：</p><ul><li>检查每个进程的CPU时间时钟值（参考23.5.3节中的<code>clock_getcpuclockid()</code> 函数）；</li><li>使用 <code>sched_getscheduler()</code> 和<code>sched_getparam()</code> 检查其调度策略和优先级。<br />如果某个进程被认为行为异常，守护线程可以通过降低其优先级或发送适当的信号终止该进程来控制它。</li></ul></li><li><p><strong>从Linux内核2.6.25开始，提供了非标准的资源限制<code>RLIMIT_RTTIME</code></strong><br />该限制用于控制实时调度策略进程在单次连续运行中可以消耗的CPU时间，单位为微秒。</p><ul><li><code>RLIMIT_RTTIME</code>限制了进程在不执行阻塞系统调用时所能消耗的CPU时间总量。<br /></li><li>当进程执行阻塞系统调用时，消耗的CPU时间计数会被重置为0。<br /></li><li>如果进程被更高优先级的进程抢占、由于时间片到期（<strong>SCHED_RR</strong>进程）或调用<code>sched_yield()</code>（第35.3.3节）而被调度出CPU，则计数也会被重置。<br /></li><li>如果进程达到 <code>RLIMIT_CPU</code> 限制，将收到一个<code>SIGXCPU</code> 信号，默认情况下会杀死进程。</li></ul></li></ul><h4 id="注意">注意</h4><p>内核2.6.25中的改动也有助于防止失控的实时进程锁死系统。有关详细信息，请参阅内核源代码文档：<code>scheduler/sched-rt-group.txt</code>。</p><h3 id="防止子进程继承特权调度策略">防止子进程继承特权调度策略</h3><p>Linux 2.6.32 引入了 <code>SCHED_RESET_ON_FORK</code> 作为可以在调用<code>sched_setscheduler()</code> 时指定的策略值之一。<br />这是一个标志值，它会与表35-1中的策略之一进行位或操作。如果设置了此标志，则由此进程通过<code>fork()</code>创建的子进程不会继承特权调度策略和优先级。规则如下：</p><ul><li>如果调用进程具有实时调度策略（<strong>SCHED_RR</strong> 或<strong>SCHED_FIFO</strong>），那么子进程的调度策略将被重置为标准的时间片轮转策略，<strong>SCHED_OTHER</strong>。</li><li>如果进程具有负的（即较高的）nice 值，则子进程的 nice值将被重置为0。</li></ul><h3 id="sched_reset_on_fork-的作用"><code>SCHED_RESET_ON_FORK</code>的作用</h3><p><code>SCHED_RESET_ON_FORK</code>标志旨在用于媒体播放等应用场景。它允许创建具有实时调度策略的单个进程，而这些策略不会传递给子进程。<br />使用 <code>SCHED_RESET_ON_FORK</code>标志可以防止通过创建多个运行在实时调度策略下的子进程来试图规避<strong>RLIMIT_RTTIME</strong> 资源限制的 fork 炸弹攻击。</p><p>一旦为一个进程启用了 <code>SCHED_RESET_ON_FORK</code>标志，只有具备特权的进程（即具有 <strong>CAP_SYS_NICE</strong>权限的进程）可以禁用它。 此时当创建子进程时，其 reset-on-fork标志会被禁用。</p><hr /><h3 id="让出-cpu">让出 CPU</h3><p>一个实时进程可以通过以下两种方式主动让出 CPU： 1.调用一个会阻塞进程的系统调用（例如，从终端执行 <code>read()</code>）。2. 调用 <code>sched_yield()</code>。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_yield</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">//成功时返回 0，出错时返回 -1。</span></span><br></pre></td></tr></table></figure> ###<code>sched_yield()</code> 的操作</p><p><code>sched_yield()</code>的操作非常简单。如果有其他与调用进程处于相同优先级队列中的可运行进程，则调用进程会被放到队列的末尾，并由队列头部的进程被调度使用CPU。<br />如果在此优先级上没有其他可运行进程排队，那么 <code>sched_yield()</code>什么都不做；调用进程将继续使用 CPU。</p><p>尽管 SUSv3 允许 <code>sched_yield()</code> 返回可能的错误，但在 Linux以及许多其他 UNIX 实现中，此系统调用始终成功。<br />然而，可移植的应用程序仍应始终检查是否有错误返回。</p><p>对于非实时进程使用 <code>sched_yield()</code> 的行为是未定义的。</p><hr /><h3 id="sched_rr-时间片"><strong><code>SCHED_RR</code>时间片</strong></h3><p><code>sched_rr_get_interval()</code> 系统调用使我们能够确定为<code>SCHED_RR</code> 进程每次被分配使用 CPU 时的时间片长度。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_rr_get_interval</span><span class="params">(<span class="type">pid_t</span> pid, <span class="keyword">struct</span> timespec *tp)</span>;</span><br><span class="line"><span class="comment">//成功时返回 0，出错时返回 -1。</span></span><br></pre></td></tr></table></figure> 与其他进程调度系统调用一样，<code>pid</code>用于标识我们希望获取信息的进程。指定 <code>pid</code> 为 0表示当前调用进程。<br />时间片的长度通过指向 <code>tp</code> 的 <code>timespec</code>结构返回：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">    <span class="type">time_t</span> tv_sec;   <span class="comment">/* 秒 */</span></span><br><span class="line">    <span class="type">long</span>   tv_nsec;  <span class="comment">/* 纳秒 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在最近的 2.6 内核中，实时轮转调度（SCHED_RR）的时间片为 0.1 秒。 ###总结</p><p>默认的内核调度算法采用的是轮转时间共享策略。在这种策略下，所有进程默认可以平等地访问CPU。不过，我们可以通过将进程的 nice 值设置为 -20（高优先级）到+19（低优先级）的范围内的数字，从而使调度器偏爱或减少对该进程的调度。然而，即使我们将进程设置为最低优先级，它也不会完全失去对CPU 的访问。</p><p>Linux 还实现了 POSIX 实时调度扩展，这允许应用程序精确控制进程对 CPU的分配。在实时调度的两种策略下运行的进程，<strong>SCHED_RR</strong>（轮转调度）和<strong>SCHED_FIFO</strong>（先进先出），总是优先于运行在非实时策略下的进程。实时进程的优先级范围是1（低优先级）到99（高优先级）。只要高优先级进程可运行，它就会完全排除低优先级进程对 CPU的访问。</p><p>在 <strong>SCHED_FIFO</strong> 策略下运行的进程会独占CPU，直到进程终止、自愿释放CPU，或者被一个更高优先级的进程抢占。同样的规则适用于<strong>SCHED_RR</strong>策略，不同之处在于，如果多个进程具有相同的优先级，则 CPU在这些进程之间以轮转方式共享。</p><p>此外，可以使用进程的 CPU 亲和性掩码（CPU affinitymask）来限制进程仅运行在多处理器系统的某些 CPU上。这有助于提高某些应用程序类型的性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;检索调度策略和优先级&quot;&gt;检索调度策略和优先级&lt;/h3&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;sched_getscheduler()&lt;/code&gt; 和
&lt;code&gt;sched_getparam()&lt;/code&gt; 系统调用&lt;/str</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux调度算法相关3</title>
    <link href="https://mackz-maxw.github.io/2025/01/02/linux_sched3/"/>
    <id>https://mackz-maxw.github.io/2025/01/02/linux_sched3/</id>
    <published>2025-01-03T01:43:33.351Z</published>
    <updated>2025-01-22T02:30:40.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实时进程调度-api">实时进程调度 API</h1><p>我们现在来看一下组成实时进程调度 API的各种系统调用。这些系统调用允许我们控制进程的调度策略和优先级。</p><h2 id="实时优先级范围">实时优先级范围</h2><p><code>sched_get_priority_min()</code> 和<code>sched_get_priority_max()</code>系统调用返回特定调度策略的可用优先级范围。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_get_priority_min</span><span class="params">(<span class="type">int</span> policy)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_get_priority_max</span><span class="params">(<span class="type">int</span> policy)</span>;</span><br><span class="line"><span class="comment">//返回值：成功时返回非负整数优先级，出错时返回 -1。</span></span><br></pre></td></tr></table></figure> -对于这两个系统调用，<code>policy</code>指定我们想要获取信息的调度策略。我们可以指定 <code>SCHED_RR</code> 或<code>SCHED_FIFO</code>。 - <code>sched_get_priority_min()</code>系统调用返回指定策略的最小优先级，<code>sched_get_priority_max()</code>返回最大优先级。 - 在 Linux 系统中，这两个系统调用分别返回数字 1 和99，适用于 <code>SCHED_RR</code> 和 <code>SCHED_FIFO</code> 策略。 -换句话说，<code>SCHED_RR</code> 和 <code>SCHED_FIFO</code>的优先级范围完全相同，<code>SCHED_RR</code> 和 <code>SCHED_FIFO</code>的进程在同一优先级时是同样有资格被调度的。首先调度哪个进程取决于它们在该优先级队列中的顺序。</p><h3 id="实时优先级范围的差异">实时优先级范围的差异</h3><ul><li>实时优先级范围在不同的 UNIX实现中有所不同。因此，在应用程序中避免硬编码优先级值时，我们应该根据从这些函数返回的值来指定优先级。</li><li>例如，最低的 <code>SCHED_RR</code> 优先级可以指定为<code>sched_get_priority_min(SCHED_RR)</code>，下一个较高的优先级可以指定为<code>sched_get_priority_min(SCHED_RR) + 1</code>，以此类推。</li></ul><h3 id="susv3-和-unix-实现的差异">SUSv3 和 UNIX 实现的差异</h3><ul><li>SUSv3 并不要求 <code>SCHED_RR</code> 和 <code>SCHED_FIFO</code>策略使用相同的优先级范围，但在大多数 UNIX 实现中，它们是相同的。</li><li>例如，在 Solaris 8 中，两个策略的优先级范围为 0 到 59，而在 FreeBSD6.1 中为 0 到 31。</li></ul><h1 id="修改和检索调度策略及优先级">修改和检索调度策略及优先级</h1><h2 id="修改调度策略和优先级">修改调度策略和优先级</h2><p><code>sched_setscheduler()</code> 系统调用可以更改指定进程（通过<code>pid</code> 参数指定）的调度策略和优先级。</p><ul><li><strong>参数说明</strong>：<ul><li>如果 <code>pid</code> 参数被设置为<code>0</code>，则更改的是调用该系统调用的当前进程的属性。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setscheduler</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> policy, <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span>;</span><br></pre></td></tr></table></figure><p>成功时返回 0。出错时返回 -1。</p><p>param：指向如下包含调度优先级信息的结构体的指针。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> sched_priority;  <span class="comment">/* 调度优先级 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> SUSv3定义了 <code>param</code>参数为一个结构体，以允许实现包括特定于实现的额外字段，这在提供额外的调度策略时可能很有用。然而，与大多数UNIX 实现一样，Linux 仅提供了 <code>sched_priority</code>字段，用于指定调度优先级。</p><p>对于 <code>SCHED_RR</code> 和 <code>SCHED_FIFO</code>策略，该字段的值必须位于由 <code>sched_get_priority_min()</code> 和<code>sched_get_priority_max()</code>确定的范围内；对于其他策略，该优先级必须为 0。</p><p><code>policy</code>参数决定了进程的调度策略。它可以是以下策略之一（如表 35-1 所示）：</p><h3 id="表-35-1linux-的实时和非实时调度策略">表 35-1：Linux的实时和非实时调度策略</h3><table><colgroup><col style="width: 16%" /><col style="width: 83%" /></colgroup><thead><tr><th>策略</th><th>描述</th></tr></thead><tbody><tr><td><code>SCHED_FIFO</code></td><td>实时先进先出（First-in First-out）</td></tr><tr><td><code>SCHED_RR</code></td><td>实时轮转（Round-robin）</td></tr><tr><td><code>SCHED_OTHER</code></td><td>标准轮转时间共享</td></tr><tr><td><code>SCHED_BATCH</code></td><td>类似于 <code>SCHED_OTHER</code>，但用于批处理（自 Linux 2.6.16起提供）</td></tr><tr><td><code>SCHED_IDLE</code></td><td>类似于 <code>SCHED_OTHER</code>，但优先级比 <code>nice +19</code>更低（自 Linux 2.6.23 起提供）</td></tr></tbody></table><h3 id="sched_setscheduler-系统调用"><code>sched_setscheduler()</code>系统调用</h3><ul><li>成功的 <code>sched_setscheduler()</code> 调用会将指定的进程（由<code>pid</code> 参数指定）移动到其优先级队列的末尾。</li></ul><p>SUSv3 指定，成功的 <code>sched_setscheduler()</code>调用应返回之前的调度策略。然而，Linux 与标准不同，成功调用时返回值为<code>0</code>。<br />便携式应用程序应通过检查返回值是否为 <code>-1</code>来判断是否成功。</p><ul><li>子进程通过 <code>fork()</code>继承其父进程的调度策略和优先级，并在调用 <code>exec()</code>时保留这些属性。</li></ul><h3 id="sched_setparam-系统调用"><code>sched_setparam()</code>系统调用</h3><ul><li><p><code>sched_setparam()</code> 系统调用提供了<code>sched_setscheduler()</code> 功能的子集：</p><ul><li>它可以修改进程的调度优先级，但不会更改其调度策略。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sched_setparam</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">const</span> <span class="keyword">struct</span> sched_param *param)</span>;</span><br></pre></td></tr></table></figure>成功时返回 0。出错时返回 -1。 <code>pid</code> 和 <code>param</code>参数的含义与 <code>sched_setscheduler()</code> 中的相同。</li></ul></li><li><p><strong>成功的 <code>sched_setparam()</code>调用</strong>：<br />成功调用 <code>sched_setparam()</code> 后，指定的进程（通过<code>pid</code> 参数指定）会被移动到其优先级队列的队尾。</p></li><li><p><strong>代码示例</strong>：<br />以下程序使用 <code>sched_setscheduler()</code>来根据命令行参数设置指定进程的调度策略和优先级。</p><ul><li><strong>参数说明</strong>：<ol type="1"><li>第一个参数是一个字母，用于指定调度策略（如 <code>SCHED_RR</code> 或<code>SCHED_FIFO</code>）。</li><li>第二个参数是一个整数，用于指定调度优先级。</li><li>剩余参数是需要更改调度属性的进程 ID 列表。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sched.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span><span class="comment">//自定义的头文件，提供错误处理和辅助函数</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> j, pol;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_param</span> <span class="title">sp</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">3</span> || <span class="built_in">strchr</span>(<span class="string">&quot;rfobi&quot;</span>, argv[<span class="number">1</span>][<span class="number">0</span>]) == <span class="literal">NULL</span>)</span><br><span class="line">        usageErr(<span class="string">&quot;%s policy priority [pid...]\n&quot;</span></span><br><span class="line">                 <span class="string">&quot;    policy is &#x27;r&#x27; (RR), &#x27;f&#x27; (FIFO), &quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_BATCH</span></span><br><span class="line">                 <span class="string">&quot; &#x27;b&#x27; (BATCH), &quot;</span> <span class="comment">/* Linux-specific */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_IDLE</span></span><br><span class="line">                 <span class="string">&quot; &#x27;i&#x27; (IDLE), &quot;</span>  <span class="comment">/* Linux-specific */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                 <span class="string">&quot;or &#x27;o&#x27; (OTHER)\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析调度策略</span></span><br><span class="line">    pol = (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;r&#x27;</span>) ? SCHED_RR :</span><br><span class="line">          (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;f&#x27;</span>) ? SCHED_FIFO :</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_BATCH</span></span><br><span class="line">          (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;b&#x27;</span>) ? SCHED_BATCH :</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SCHED_IDLE</span></span><br><span class="line">          (argv[<span class="number">1</span>][<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>) ? SCHED_IDLE :</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          SCHED_OTHER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析优先级</span></span><br><span class="line">    sp.sched_priority = getInt(argv[<span class="number">2</span>], <span class="number">0</span>, <span class="string">&quot;priority&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置每个指定进程的调度策略和优先级</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">3</span>; j &lt; argc; j++)</span><br><span class="line">        <span class="keyword">if</span> (sched_setscheduler(getLong(argv[j], <span class="number">0</span>, <span class="string">&quot;pid&quot;</span>), pol, &amp;sp) == <span class="number">-1</span>)</span><br><span class="line">            errExit(<span class="string">&quot;sched_setscheduler&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ###权限和资源限制对调度参数更改的影响</li></ol></li></ul></li></ul><h4 id="版本之前的内核行为">1. <strong>2.6.12版本之前的内核行为</strong></h4><ul><li>在 Linux 2.6.12内核之前，进程通常需要具有特权（<code>CAP_SYS_NICE</code>）才能更改调度策略和优先级。</li><li>唯一的例外是：如果调用者的有效用户 ID 与目标进程的真实或有效用户 ID匹配，则非特权进程可以将目标进程的调度策略更改为<code>SCHED_OTHER</code>。</li></ul><h4 id="版本及之后的内核行为">2. <strong>2.6.12版本及之后的内核行为</strong></h4><ul><li>自 Linux 2.6.12 起，引入了一个新的非标准资源限制<code>RLIMIT_RTPRIO</code>，调整了实时调度策略和优先级的设置规则：<ul><li>拥有特权的进程（<code>CAP_SYS_NICE</code>）可以对任意进程的调度策略和优先级进行更改。</li><li>非特权进程也可以根据以下规则更改调度策略和优先级：</li></ul></li></ul><ol type="1"><li><strong><code>RLIMIT_RTPRIO</code> 的非零软限制</strong>：<ul><li>如果进程具有非零的 <code>RLIMIT_RTPRIO</code>软限制，则可以任意更改其调度策略和优先级。</li><li>但有以下限制：<ul><li>实时优先级的最大值不能超过当前实时优先级和<code>RLIMIT_RTPRIO</code> 软限制中的较大值。</li></ul></li></ul></li><li><strong>如果<code>RLIMIT_RTPRIO</code> 的软限制为零</strong>：<ul><li>唯一可以进行的更改是：<ul><li>将实时优先级降低。</li><li>或从实时调度策略切换到非实时调度策略。</li></ul></li></ul></li><li><strong><code>SCHED_IDLE</code> 策略的特殊性</strong>：<ul><li>运行在 <code>SCHED_IDLE</code> 策略下的进程无法更改其调度策略，无论<code>RLIMIT_RTPRIO</code> 的值如何。</li></ul></li><li><strong>从其他非特权进程进行更改</strong>：<ul><li>如果调用者的有效用户 ID 与目标进程的真实或有效用户 ID匹配，则可以更改目标进程的调度策略和优先级。</li></ul></li><li><strong><code>RLIMIT_RTPRIO</code> 软限制的作用</strong>：<ul><li>仅决定进程对自身或其它非特权进程对该进程调度策略和优先级的更改。</li><li>一个非零限制并不赋予非特权进程对其他进程的调度策略和优先级进行更改的能力。</li></ul></li></ol><h3 id="特殊说明">特殊说明</h3><ul><li>自 Linux 2.6.25 起，添加了实时调度组（Realtime SchedulingGroups）的概念：<ul><li>可通过 <code>CONFIG_RT_GROUP_SCHED</code> 内核选项进行配置。</li><li>这一选项影响设置实时调度策略时可以进行的更改。</li><li>详情请参阅内核源码文档<code>Documentation/scheduler/sched-rt-group.txt</code>。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实时进程调度-api&quot;&gt;实时进程调度 API&lt;/h1&gt;
&lt;p&gt;我们现在来看一下组成实时进程调度 API
的各种系统调用。这些系统调用允许我们控制进程的调度策略和优先级。&lt;/p&gt;
&lt;h2 id=&quot;实时优先级范围&quot;&gt;实时优先级范围&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux调度算法相关2</title>
    <link href="https://mackz-maxw.github.io/2024/12/28/linux_sched2/"/>
    <id>https://mackz-maxw.github.io/2024/12/28/linux_sched2/</id>
    <published>2024-12-28T16:10:36.283Z</published>
    <updated>2025-01-22T02:30:36.654Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实时进程调度概述">实时进程调度概述</h1><h2 id="标准调度与实时调度的差异">标准调度与实时调度的差异</h2><p>标准内核调度算法通常可以为交互式和后台进程的混合提供足够的性能和响应能力。然而，实时应用程序对调度器的需求更加严格</p><h3 id="提供外部输入的最大响应时间保证">1.提供外部输入的最大响应时间保证</h3><ul><li>实时应用程序必须保证对外部输入的最大响应时间。在许多情况下，这些最大响应时间需要非常短，例如在毫秒或几分之一秒的级别。</li></ul><h4 id="附加措施">附加措施</h4><ul><li>一些时间关键型的应用可能需要采取其他措施来避免不可接受的延迟。例如：<ul><li>使用 <code>mlock()</code> 或 <code>mlockall()</code>将应用程序的所有虚拟内存锁定到 RAM 中，避免页面错误造成的延迟。</li></ul></li></ul><h3 id="保持对-cpu-的独占访问权">2. 保持对 CPU 的独占访问权</h3><ul><li>高优先级进程在完成任务或自愿放弃 CPU 之前，应该能够独占地使用CPU，确保任务的顺利执行。 ### 3. 进程顺序控制</li><li><h2id="实时应用程序需要对其成员进程精确顺序的调度权">实时应用程序需要对其成员进程精确顺序的调度权。</h2></li></ul><h1 id="实时调度的-posix-api">实时调度的 POSIX API</h1><h2 id="susv3-的实时调度-api">SUSv3 的实时调度 API</h2><p>SUSv3 定义了一个实时进程调度 API，部分满足了实时应用的严格需求： -提供两种实时调度策略： - <code>SCHED_FIFO</code>（先进先出） -<code>SCHED_RR</code>（轮转） - 使用这些策略的进程优先级总是高于采用<code>SCHED_OTHER</code>（普通时间共享）的进程。</p><h2 id="实时优先级范围">实时优先级范围</h2><ul><li>每种实时调度策略至少需要支持 32 个离散优先级。</li><li>高优先级的进程总是优先于低优先级的进程。</li></ul><h3 id="多处理器系统中的调度行为">多处理器系统中的调度行为</h3><p>在多处理器系统（包括超线程系统）中，调度行为有一些特殊性： 1. 每个CPU维护一个独立的运行队列。这种设计优于单一的系统级运行队列，可以提高性能。2. 进程只能在其所属 CPU 的运行队列中被调度。 3. <strong>举例</strong>：- 在一个双处理器系统中，如果有三个进程： - 进程 A：实时优先级为 20； -进程 B：实时优先级为 30； - 进程 C：实时优先级为 10； - 如果当前 CPU0正在运行 B，A 只能等待 CPU0 空闲，即使 A 的优先级高于 CPU1 上正在运行的C。</p><p>Linux 提供了 99 个实时优先级，从 1（最低）到99（最高）。这一区间适用于两种实时调度策略（<code>SCHED_RR</code> 和<code>SCHED_FIFO</code>）。两种策略中的优先级是等效的。</p><p>这意味着： - 如果两个进程具有相同的优先级，一个使用<code>SCHED_RR</code> 策略，另一个使用 <code>SCHED_FIFO</code>策略，那么哪个进程会被调度取决于它们被放入队列的顺序。</p><p>实际上，每个优先级都维护着一个可运行进程的队列。 -调度时，系统会从最高优先级的非空队列中选择队列头部的进程来运行。 ---</p><h1 id="posix-实时-vs-硬实时">POSIX 实时 vs 硬实时</h1><h3 id="posix-实时软实时">POSIX 实时（软实时）</h3><p>POSIX 提供的是软实时调度功能，具体表现为： - 可以控制进程何时被调度。- 不能完全保证处理输入时的响应时间。 -适用于绝大多数实时场景，但无法满足某些严格的硬实时需求。</p><h3 id="硬实时">硬实时</h3><ul><li>硬实时系统保证所有任务在规定的时限内完成。</li><li>实现硬实时通常需要操作系统支持额外的功能，而 Linux 默认不支持。</li><li>Linux 内核自 2.6.18版本以来添加了一些功能，目标是原生支持硬实时应用，但仍需配置和优化。</li></ul><hr /><h1 id="sched_rr-策略详解">SCHED_RR 策略详解</h1><h3 id="基本规则">基本规则</h3><p>在 <code>SCHED_RR</code> 策略下： - 同一优先级的任务按照轮转方式共享CPU，每个任务在每次使用 CPU 时获得一个固定长度的时间片。</p><h3 id="执行控制">执行控制</h3><p>任务保持对 CPU 的控制直到以下任一情况发生： 1. 时间片耗尽： -任务被移至同一优先级队列的末尾，其他同优先级任务可以被调度。 2. 自愿放弃CPU： - 例如，调用了 <code>sched_yield()</code> 或执行了阻塞操作。 3.任务终止。 4. 被更高优先级的任务抢占。</p><p>对于前两个事件（时间片耗尽或主动放弃 CPU）中的情况，当运行在<code>SCHED_RR</code> 策略下的进程失去对 CPU的访问权限时，它会被移至其优先级队列的末尾。<br />在最后一种情况中（被更高优先级的进程抢占），当高优先级进程结束执行后，被抢占的进程会继续运行，使用其剩余的时间片（即被抢占的进程会回到其优先级队列的头部）。</p><h3 id="sched_rr-和-sched_fifo"><code>SCHED_RR</code> 和<code>SCHED_FIFO</code></h3><p>在 <code>SCHED_RR</code> 和 <code>SCHED_FIFO</code>策略中，当前运行中的进程可能因以下原因之一被抢占： 1.一个更高优先级的进程从阻塞状态变为非阻塞状态（例如，I/O 操作完成）。 2.另一个进程的优先级被提升到高于当前运行进程的优先级。 3.当前运行进程的优先级被降低到低于某些其他可运行进程的优先级。</p><p><code>SCHED_RR</code>策略类似于标准的轮转时间共享调度算法（<code>SCHED_OTHER</code>），它允许一组相同优先级的进程共享CPU。</p><h3 id="两者的主要区别">两者的主要区别：</h3><ol type="1"><li><strong>优先级规则</strong>：<ul><li><code>SCHED_RR</code>策略严格区分优先级，高优先级的进程总是优先于低优先级的进程。</li><li>而 <code>SCHED_OTHER</code> 策略中，较低的 <code>nice</code>值（即较高的优先级）虽然增加了调度权重，但不能保证独占 CPU。</li></ul></li><li><strong>时间片保障</strong>：<ul><li>在 <code>SCHED_OTHER</code> 策略中，任何具有低优先级（高<code>nice</code> 值）的进程始终可以获得一定的 CPU 时间。</li><li><h2id="sched_rr-策略允许我们更精确地控制进程的调度顺序和执行时间"><code>SCHED_RR</code>策略允许我们更精确地控制进程的调度顺序和执行时间。</h2></li></ul></li></ol><h1 id="sched_fifo-策略详解">SCHED_FIFO 策略详解</h1><h3 id="基本规则-1">基本规则</h3><p><code>SCHED_FIFO</code>（先进先出）策略与 <code>SCHED_RR</code>类似，但没有时间片限制。 - 任务可以一直运行，直到以下任一情况发生： 1.主动放弃 CPU（例如阻塞操作）。 2. 任务终止。 3.被更高优先级任务抢占。</p><p>在第一种情况下，进程会被放置到其优先级队列的末尾。在最后一种情况下，当高优先级的进程停止执行（例如由于阻塞或终止）时，被抢占的进程会继续执行（即，被抢占的进程会保持在其优先级队列的队首）。</p><hr /><h1 id="sched_batch-和-sched_idle-策略">SCHED_BATCH 和 SCHED_IDLE策略</h1><h2 id="sched_batch-策略">SCHED_BATCH 策略</h2><ul><li><strong>功能</strong>：用于批处理型任务。</li><li><strong>特点</strong>：<ul><li>适用于 CPU 密集型任务。</li><li>对调度延迟不敏感。</li><li>调度器会根据任务的 <code>nice</code> 值决定优先级。</li></ul></li><li><strong>引入版本</strong>：Linux 2.6.16。</li></ul><h2 id="sched_idle-策略">SCHED_IDLE 策略</h2><ul><li><strong>功能</strong>：用于低优先级任务，仅在系统完全空闲时执行。</li><li><strong>特点</strong>：<ul><li>优先级比所有其他任务都低（甚至低于 <code>nice +19</code>）。</li><li><code>nice</code> 值对该策略没有影响。</li></ul></li><li><strong>引入版本</strong>：Linux 2.6.23。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实时进程调度概述&quot;&gt;实时进程调度概述&lt;/h1&gt;
&lt;h2 id=&quot;标准调度与实时调度的差异&quot;&gt;标准调度与实时调度的差异&lt;/h2&gt;
&lt;p&gt;标准内核调度算法通常可以为交互式和后台进程的混合提供足够的性能和响应能力。然而，实时应用程序对调度器的需求更加严格&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Linux调度算法相关</title>
    <link href="https://mackz-maxw.github.io/2024/12/27/linux_sched/"/>
    <id>https://mackz-maxw.github.io/2024/12/27/linux_sched/</id>
    <published>2024-12-27T18:35:39.817Z</published>
    <updated>2025-01-22T02:30:30.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实时调度策略及算法概述">实时调度策略及算法概述</h1><p>Linux 提供了两种实时调度策略，<code>SCHED_FIFO</code> 和<code>SCHED_RR</code>。非实时的普通调度策略是<code>SCHED_NORMAL</code>。</p><p>通过调度类框架，这些实时调度策略并非由完全公平调度器（CFS）管理，而是由一个特殊的实时调度器管理，该调度器定义在<code>kernel/sched_rt.c</code> 文件中。</p><h2 id="sched_fifo-策略">1. SCHED_FIFO 策略</h2><p><code>SCHED_FIFO</code>实现了一种简单的先进先出（FIFO）调度算法，<strong>没有时间片限制</strong>，可以无限期运行。- 一个可运行的 <code>SCHED_FIFO</code> 任务始终优先于任何<code>SCHED_NORMAL</code> 任务。 - 当 <code>SCHED_FIFO</code>任务变为可运行状态时，它会一直运行，直到阻塞或显式放弃处理器。 -<strong>抢占规则</strong>：只有更高优先级的 <code>SCHED_FIFO</code> 或<code>SCHED_RR</code> 任务可以抢占当前的 <code>SCHED_FIFO</code> 任务。- 如果多个 <code>SCHED_FIFO</code>任务具有相同优先级，它们以轮转的方式运行。</p><h2 id="sched_rr-策略">2. SCHED_RR 策略</h2><p><code>SCHED_RR</code> 与 <code>SCHED_FIFO</code>类似，但有时间片限制。 -每个任务运行到时间片耗尽时，会被切换到同一优先级队列中的下一个任务。 -只有更高优先级的任务可以抢占当前任务，即使 <code>SCHED_RR</code>任务的时间片耗尽，低优先级的进程也无法抢占它的执行。 -<strong>时间片的作用</strong>：仅用于同优先级进程之间的调度。</p><h2 id="静态优先级">3. 静态优先级</h2><ul><li>两种实时调度策略都实现了<strong>静态优先级</strong>。</li><li>内核不会为实时任务计算动态优先级。</li><li>给定优先级的实时任务总是会抢占低优先级的任务。</li></ul><h2 id="软实时与硬实时">4. 软实时与硬实时</h2><ul><li>Linux的实时调度策略提供的是<strong>软实时</strong>行为：内核会尽力在时限内调度应用程序，但不保证一定达成。</li><li>硬实时系统则保证严格的时限要求，而 Linux 并不原生支持。</li></ul><hr /><h1 id="实时优先级范围">实时优先级范围</h1><ul><li>实时优先级范围为 <code>0</code> 到<code>MAX_RT_PRIO - 1</code>，默认情况下 <code>MAX_RT_PRIO</code> 为<code>100</code>。99为最高实时优先级。</li><li>普通任务（<code>SCHED_NORMAL</code>）与实时任务共享优先级空间：<ul><li><code>-20</code> 到 <code>+19</code> 的 nice 值映射到优先级范围<code>100</code> 到<code>139</code>。这是用户空间的进程评级，-20为最高优先级。</li></ul></li></ul><hr /><h1 id="与调度器相关的系统调用">与调度器相关的系统调用</h1><p>以下是管理调度参数的系统调用列表：</p><table><thead><tr><th><strong>系统调用</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><code>nice()</code></td><td>设置进程的 nice 值</td></tr><tr><td><code>sched_setscheduler()</code></td><td>设置进程的调度策略</td></tr><tr><td><code>sched_getscheduler()</code></td><td>获取进程的调度策略</td></tr><tr><td><code>sched_setparam()</code></td><td>设置进程的实时优先级</td></tr><tr><td><code>sched_getparam()</code></td><td>获取进程的实时优先级</td></tr><tr><td><code>sched_get_priority_max()</code></td><td>获取实时调度的最大优先级</td></tr><tr><td><code>sched_get_priority_min()</code></td><td>获取实时调度的最小优先级</td></tr><tr><td><code>sched_rr_get_interval()</code></td><td>获取进程的时间片值</td></tr><tr><td><code>sched_setaffinity()</code></td><td>设置进程的处理器亲和性</td></tr><tr><td><code>sched_getaffinity()</code></td><td>获取进程的处理器亲和性</td></tr><tr><td><code>sched_yield()</code></td><td>临时将处理器让给其他任务</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;实时调度策略及算法概述&quot;&gt;实时调度策略及算法概述&lt;/h1&gt;
&lt;p&gt;Linux 提供了两种实时调度策略，&lt;code&gt;SCHED_FIFO&lt;/code&gt; 和
&lt;code&gt;SCHED_RR&lt;/code&gt;。非实时的普通调度策略是
&lt;code&gt;SCHED_NORMAL</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>设置Ubuntu</title>
    <link href="https://mackz-maxw.github.io/2024/12/20/Ubuntu_setup/"/>
    <id>https://mackz-maxw.github.io/2024/12/20/Ubuntu_setup/</id>
    <published>2024-12-21T04:10:52.726Z</published>
    <updated>2025-01-22T02:30:56.761Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设置apt源">设置apt源</h3><p>检查Ubuntu的系统版本和代号是否与要安装的源一致 在终端中输入：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure> source APT源： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c &#x27;echo &quot;deb http://mirrors.aliyun.com/ubuntu/ jammy main restricted universe multiverse&quot; &gt; /etc/apt/sources.list&#x27;</span><br></pre></td></tr></table></figure> 检查source list：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/apt/sources.list</span><br></pre></td></tr></table></figure> 从源获取包信息： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></p><h3 id="vim技巧">vim技巧</h3><p>虚拟块模式（选择一块代码）：ctrl + q 在虚拟块模式中删除选中：d</p><h3 id="设置vim">设置vim</h3><p>生成并打开设置文件： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/vim/vimrc ~/.vimrc</span><br><span class="line">cd ~</span><br><span class="line">ls -a</span><br><span class="line">vim .vimrc</span><br></pre></td></tr></table></figure> 具体设置更改： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax on   &quot; 语法高亮</span><br><span class="line">set background=dark</span><br><span class="line">filetype plugin indent on</span><br><span class="line">set showmatch          &quot; Show matching brackets.</span><br><span class="line">set ignorecase         &quot; Do case insensitive matching</span><br><span class="line">set smartcase          &quot; Do smart case matching</span><br><span class="line">set incsearch          &quot; Incremental search</span><br><span class="line">set hidden             &quot; Hide buffers when they are abandoned</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;设置apt源&quot;&gt;设置apt源&lt;/h3&gt;
&lt;p&gt;检查Ubuntu的系统版本和代号是否与要安装的源一致 在终端中输入：
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>学习GCC和GDB</title>
    <link href="https://mackz-maxw.github.io/2024/12/20/Learn_gdb/"/>
    <id>https://mackz-maxw.github.io/2024/12/20/Learn_gdb/</id>
    <published>2024-12-21T04:10:52.726Z</published>
    <updated>2025-01-22T02:30:26.176Z</updated>
    
    <content type="html"><![CDATA[<h3 id="gcc编译">GCC编译</h3><p>gcc编译hello.c，指定输出为hello： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure> 运行可执行文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hello</span><br></pre></td></tr></table></figure></p><h3 id="一个简单的makefile示例">一个简单的Makefile示例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello:hello.c   # 目标文件名:依赖文件列表</span><br><span class="line">gcc hello.c -o hello# 用于生成目标文件的命令序列</span><br><span class="line">.PHONY: clean   # 声明伪目标，使用make clean执行clean操作而不是生成clean文件</span><br><span class="line">clean:</span><br><span class="line">rm hello</span><br></pre></td></tr></table></figure><h3 id="debug-bash脚本">debug bash脚本</h3><p>直接输出： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;function_name(): value of \\$var is $&#123;var&#125;&quot;</span><br></pre></td></tr></table></figure>可以在脚本shebang列设置需要使用的xtrace选项： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash -x</span><br></pre></td></tr></table></figure>仅在指定列设置xtrace选项： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">read -p &quot;Path to be added: &quot; $path</span><br><span class="line">set -xv</span><br><span class="line">if [ &quot;$path&quot; = &quot;/home/mike/bin&quot; ]; then</span><br><span class="line">echo $path &gt;&gt; $PATH</span><br><span class="line">echo &quot;new path: $PATH&quot;</span><br><span class="line">else</span><br><span class="line">echo &quot;did not modify PATH&quot;</span><br><span class="line">fi</span><br><span class="line">set +xv</span><br></pre></td></tr></table></figure>使用trap，EXIT模式仅检测退出时状态: <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">trap &#x27;echo score is $score, status is $status&#x27; EXIT</span><br><span class="line">if [ -z $1 ]; then</span><br><span class="line">status=&quot;default&quot;</span><br><span class="line">else</span><br><span class="line">status=$1</span><br><span class="line">fi</span><br><span class="line">score=0</span><br><span class="line">if [ $&#123;USER&#125; = &#x27;superman&#x27; ]; then</span><br><span class="line">score=99</span><br><span class="line">elif [ $# -gt 1 ]; then</span><br><span class="line">score=$2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>DEBUG模式可以检测每步状态： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">trap &#x27;echo &quot;line $&#123;LINENO&#125;: score is $score&quot;&#x27; DEBUG</span><br></pre></td></tr></table></figure></p><h3 id="gdb-debug">GDB debug</h3><p>使用友好的GDB debug会话： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -ggdb test.c -o test.out</span><br></pre></td></tr></table></figure> 设置核心转储： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ! grep -qi &#x27;kernel.core_pattern&#x27; /etc/sysctl.conf; then</span><br><span class="line">  sudo sh -c &#x27;echo &quot;kernel.core_pattern=core.%p.%u.%s.%e.%t&quot; &gt;&gt; /etc/sysctl.conf&#x27;</span><br><span class="line">  sudo sysctl -p</span><br><span class="line">fi</span><br><span class="line">ulimit -c unlimited # 使得当前会话解除核心文件大小限制</span><br></pre></td></tr></table></figure>永久解除核心文件大小限制： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo bash -c &quot;cat &lt;&lt; EOF &gt; /etc/security/limits.conf</span><br><span class="line">* soft core unlimited</span><br><span class="line">* hard core unlimited</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure> 检查核心文件元数据：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file core.1341870.1000.8.test.out.1598867712</span><br></pre></td></tr></table></figure> 使用GDB分析核心转储： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb ./test.out ./core.1341870.1000.8.test.out.1598867712</span><br></pre></td></tr></table></figure>在GDB会话中，可以使用以下操作： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt# 回溯</span><br><span class="line">(gdb) f 2# 转到特定帧</span><br><span class="line">(gdb) list # 打印源代码</span><br><span class="line">(gdb) p a/b # 打印变量或表达式</span><br></pre></td></tr></table></figure></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;gcc编译&quot;&gt;GCC编译&lt;/h3&gt;
&lt;p&gt;gcc编译hello.c，指定输出为hello： &lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;l</summary>
      
    
    
    
    
  </entry>
  
</feed>
