<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mackz-maxw.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="乘上燃犀船，还未曾去过倒悬山。">
<meta property="og:type" content="website">
<meta property="og:title" content="Maxw的小站">
<meta property="og:url" content="https://mackz-maxw.github.io/page/3/index.html">
<meta property="og:site_name" content="Maxw的小站">
<meta property="og:description" content="乘上燃犀船，还未曾去过倒悬山。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mackz-Maxw">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://mackz-maxw.github.io/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Maxw的小站</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Maxw的小站" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Maxw的小站</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Maxw学习记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Mackz-Maxw</p>
  <div class="site-description" itemprop="description">乘上燃犀船，还未曾去过倒悬山。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">110</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/mackz-maxw" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mackz-maxw" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/20/oper_sys22processMgmt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/20/oper_sys22processMgmt/" class="post-title-link" itemprop="url">操作系统基础 | 5.1 进程管理简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-21 00:55:36" itemprop="dateCreated datePublished" datetime="2025-08-21T00:55:36+08:00">2025-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-28 09:19:55" itemprop="dateModified" datetime="2025-08-28T09:19:55+08:00">2025-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="进程"><strong>进程</strong></h3>
<p>一个进程是一个正在执行中的程序（存储在某种介质上的目标代码）。然而，进程不仅仅只是执行的程序代码（在
Unix
中常称为文本段）。它们还包括一系列资源，例如打开的文件和待处理的信号、内核内部数据、处理器状态、包含一个或多个内存映射的内存地址空间、一个或多个执行线程，以及包含全局变量的数据段。实际上，进程是运行程序代码的动态产物。内核需要高效且透明地管理所有这些细节。</p>
<p>执行线程（通常简称为线程）是进程内部的活动对象。每个线程包含一个唯一的程序计数器、进程栈和一组处理器寄存器。内核调度的是单个线程，而不是进程。在传统的
Unix
系统中，每个进程由一个线程组成。然而，在现代系统中，由多个线程组成的多线程程序非常普遍。正如您后面将看到的，Linux
对线程的实现很独特：它并不区分线程和进程。对 Linux
而言，线程只是一种特殊的进程。</p>
<p>在现代操作系统上，进程提供了两种虚拟化：虚拟化处理器和虚拟内存。虚拟化处理器给进程一种假象，让它以为自己在独享系统，尽管处理器可能正与数百个其他进程共享。虚拟内存让进程可以分配和管理内存，就好像它独占了系统中的所有内存一样。</p>
<p>有趣的是，请注意线程共享虚拟内存抽象，而每个线程则拥有自己的虚拟化处理器。</p>
<p>程序本身并不是一个进程；进程是活动中的程序及其相关资源。实际上，可以存在两个或更多个执行同一程序的进程。事实上，也可以存在两个或更多共享各种资源（如打开的文件或地址空间）的进程。</p>
<p>毫不奇怪，进程在其创建时开始它的生命周期。在 Linux 中，这是通过
<code>fork()</code>
系统调用来完成的，该系统调用通过复制一个现有进程来创建一个新进程。调用
<code>fork()</code>
的进程是父进程，而新进程是子进程。父进程恢复执行，而子进程则在相同的地方开始执行：即从
<code>fork()</code> 调用返回的地方。<code>fork()</code>
系统调用从内核返回两次：一次在父进程中，一次在新生的子进程中。</p>
<p>通常，在 <code>fork()</code>
之后立即需要执行一个新的、不同的程序。<code>exec()</code>
系列函数调用会创建一个新的地址空间并将一个新的程序加载到其中。在当代的
Linux 内核中，<code>fork()</code> 实际上是通过 <code>clone()</code>
系统调用实现的，这将在后面讨论。</p>
<p>最后，程序通过 <code>exit()</code>
系统调用退出。此函数终止进程并释放其所有资源。父进程可以通过
<code>wait4()</code>¹
系统调用查询已终止子进程的状态，该系统调用使一个进程能够等待特定进程的终止。当一个进程退出时，它会被置于一种特殊的<strong>僵尸
(zombie)</strong> 状态，该状态表示已终止的进程，直到父进程调用
<code>wait()</code> 或 <code>waitpid()</code>。</p>
<blockquote>
<p>¹ 内核实现了 <code>wait4()</code> 系统调用。Linux 系统通过 C
库通常提供 <code>wait()</code>, <code>waitpid()</code>,
<code>wait3()</code>, 和 <code>wait4()</code>
函数。所有这些函数都返回关于已终止进程的状态信息，尽管语义略有不同。</p>
</blockquote>
<p><strong>注意</strong> 进程的另一个名称是<strong>任务
(task)</strong>。Linux
内核在内部将进程称为任务。在本书中，我会交替使用这两个术语，尽管当我说“任务”时，通常是从内核的角度来指代一个进程。</p>
<hr />
<h3
id="进程描述符和任务结构-task-structure"><strong>进程描述符和任务结构
(Task Structure)</strong></h3>
<p>内核在一个称为<strong>任务列表 (task list)</strong>²
的环形双向链表中存储进程列表。任务列表中的每个元素都是一个类型为
<code>struct task_struct</code> 的进程描述符，该结构定义在
<code>&lt;linux/sched.h&gt;</code>
中。进程描述符包含了一个特定进程的所有信息。</p>
<p><code>task_struct</code> 是一个相对较大的数据结构，在 32 位机器上约为
1.7
千字节。然而，考虑到该结构包含了内核所拥有和需要的关于一个进程的所有信息，这个大小已经相当小了。进程描述符包含了描述正在执行的程序的数据——打开的文件、进程的地址空间、待处理的信号、进程的状态等等。</p>
<blockquote>
<p>² 一些操作系统设计文献称此列表为任务数组 (task array)。由于 Linux
的实现是链表而非静态数组，因此在 Linux 中它被称为任务列表 (task
list)。</p>
</blockquote>
<hr />
<h3 id="分配进程描述符"><strong>分配进程描述符</strong></h3>
<p><code>task_struct</code> 结构通过 <strong>slab 分配器 (slab
allocator)</strong> 进行分配，以提供对象重用和缓存着色。在 2.6
系列内核之前，<code>struct task_struct</code>
存储在每个进程的内核栈的末端。这使得像 x86
这样寄存器数量较少的体系结构，可以通过栈指针计算进程描述符的位置，而无需使用额外的寄存器来存储该位置。由于现在进程描述符是通过
slab 分配器动态创建的，因此引入了一个新的结构
<code>struct thread_info</code>，该结构再次存在于栈的底部（对于向下增长的栈）或栈的顶部（对于向上增长的栈）³。参见图
3.2。</p>
<blockquote>
<p>³ 创建 <code>struct thread_info</code>
并不仅仅是因为寄存器受限的体系结构。新结构也使得在汇编代码中计算其值的偏移量变得相当容易。</p>
</blockquote>
<p><code>thread_info</code> 结构在 x86 上的
<code>&lt;asm/thread_info.h&gt;</code> 中定义如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>    *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>    *<span class="title">exec_domain</span>;</span></span><br><span class="line">    __u32                 flags;</span><br><span class="line">    __u32                 status;</span><br><span class="line">    __u32                 cpu;</span><br><span class="line">    <span class="type">int</span>                   preempt_count;</span><br><span class="line">    <span class="type">mm_segment_t</span>          addr_limit;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span>  <span class="title">restart_block</span>;</span></span><br><span class="line">    <span class="type">void</span>                  *sysenter_return;</span><br><span class="line">    <span class="type">int</span>                   uaccess_err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>(图 3.2 示意图说明)</strong> 进程内核栈<br />
栈起始处（向低地址方向增长）<br />
- 最高内存地址<br />
- 栈指针<br />
- <code>struct thread_struct</code> (进程的
<code>struct task_struct</code>)<br />
- 最低内存地址, <code>current_thread_info()</code><br />
<code>thread_info</code> 包含一个指向进程描述符的指针</p>
<blockquote>
<p>栈的增长方向：x86 体系的栈是向下（向低地址方向）增长的。 - 栈底
(Stack Base)：为了充分利用这块内存，栈被初始化为从这块分配区的最高地址
(0x10000)
开始。这个初始的栈指针位置就是栈底。它是栈的“起点”，但却是分配内存块的“末尾”。
- 栈顶 (Stack Top)：随着函数调用、压入参数等操作，%esp
寄存器的值会不断减小（向 0xE000 方向移动）。%esp
当前指向的位置称为栈顶。它是栈的“当前操作端”，向低地址方向延伸。</p>
</blockquote>
<p>每个任务的 <code>thread_info</code> 结构都分配在其栈的末端。该结构的
<code>task</code> 元素是一个指向任务实际 <code>task_struct</code>
的指针。</p>
<hr />
<h3 id="存储进程描述符"><strong>存储进程描述符</strong></h3>
<p>系统通过一个唯一的<strong>进程标识值 (process identification
value)</strong> 或 <strong>PID</strong> 来识别进程。PID
是一个由不透明类型⁴ <code>pid_t</code> 表示的数值，通常是一个
<code>int</code>。然而，为了与早期的 Unix 和 Linux
版本向后兼容，默认最大值仅为 32,768（一个 <code>short int</code>
的值），尽管可以选择将该值增加到高达 400 万（这由
<code>&lt;linux/threads.h&gt;</code> 控制）。内核在每个进程描述符的
<code>pid</code> 字段中存储此值。</p>
<blockquote>
<p>⁴ 不透明类型 (opaque
type)：指其内部细节被隐藏，只通过特定接口访问的数据类型。</p>
</blockquote>
<p>这个最大值很重要，因为它本质上是系统上可能同时存在的最大进程数。虽然
32,768
对于桌面系统可能足够，但大型服务器可能需要多得多的进程。此外，该值越低，数值回绕（wrap
around）就越快，这会破坏“数值大的进程比数值小的进程更晚运行”这一有用概念。如果系统愿意打破与旧应用程序的兼容性，管理员可以通过
<code>/proc/sys/kernel/pid_max</code> 来增加最大值。</p>
<p>在内核内部，通常直接通过指向其 <code>task_struct</code>
结构的指针来引用任务。事实上，大多数处理进程的内核代码都直接使用
<code>struct task_struct</code>。因此，能够快速查找当前正在执行的任务的进程描述符是非常有用的，这是通过
<code>current</code>
宏来完成的。这个宏必须由每个体系结构独立实现。一些体系结构将当前运行进程的
<code>task_struct</code>
结构的指针保存在一个寄存器中，以实现高效访问。其他体系结构，如
x86（几乎没有多余的寄存器可用），则利用 <code>struct thread_info</code>
存储在内核栈上这一条件，来计算 <code>thread_info</code> 的位置，进而找到
<code>task_struct</code>。</p>
<p>在 x86 上，<code>current</code> 是通过滤除栈指针的最低 13 位来获得
<code>thread_info</code> 结构计算的。这是由
<code>current_thread_info()</code> 函数完成的。汇编代码如下：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl $-8192, %eax</span><br><span class="line">andl %esp, %eax</span><br></pre></td></tr></table></figure> 这里假设栈大小是 8KB。当启用 4KB 栈时，使用 4096 代替
8192。</p>
<p>最后，<code>current</code> 解引用 <code>thread_info</code> 的
<code>task</code> 成员以返回 <code>task_struct</code>：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current_thread_info()-&gt;task;</span><br></pre></td></tr></table></figure></p>
<p>将此方法与 PowerPC（IBM 的现代基于 RISC
的微处理器）采用的方法对比，后者将当前的 <code>task_struct</code>
存储在一个寄存器中。因此，在 PPC 上 <code>current</code>
仅仅返回存储在寄存器 <code>r2</code> 中的值。PPC
可以采用这种方法是因为，与 x86
不同，它有大量的寄存器。由于访问进程描述符是一项常见且重要的工作，PPC
内核开发人员认为使用一个寄存器是值得的。</p>
<h3 id="进程状态-process-state"><strong>进程状态 (Process
State)</strong></h3>
<p>进程描述符中的 <code>state</code> 字段描述了进程的当前状况（参见图
3.3）。系统中的每个进程都确切地处于五种不同状态中的一种。该值由以下五个标志之一表示：</p>
<ul>
<li><strong>TASK_RUNNING
(运行)</strong>：进程是可运行的；它要么正在执行，要么在运行队列（runqueue）中等待运行（运行队列将在第
4
章讨论）。这是在用户空间执行的进程唯一可能的状态；它也应用于正在内核空间中主动运行的进程。</li>
<li><strong>TASK_INTERRUPTIBLE
(可中断睡眠)</strong>：进程正在睡眠（即被阻塞），等待某个条件的发生。当此条件满足时，内核会将进程的状态设置为
<code>TASK_RUNNING</code>。如果进程接收到信号，它也会被提前唤醒并变为可运行状态。</li>
<li><strong>TASK_UNINTERRUPTIBLE (不可中断睡眠)</strong>：此状态与
<code>TASK_INTERRUPTIBLE</code>
类似，区别在于即使接收到信号，它也不会被唤醒并变为可运行状态。此状态用于进程必须不受中断地等待，或者预期事件会很快发生的场合。由于处在此状态的任务不响应信号，因此
<code>TASK_UNINTERRUPTIBLE</code> 的使用频率低于
<code>TASK_INTERRUPTIBLE</code>⁵。</li>
<li>**__TASK_TRACED (被跟踪)**：进程正被另一个进程（例如调试器通过
<code>ptrace</code>）所跟踪。</li>
<li>**__TASK_STOPPED
(停止)**：进程执行已停止；任务既不在运行，也没有资格运行。如果任务收到
<code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code> 或
<code>SIGTTOU</code>
信号，或者在被调试时收到任何信号，就会发生这种状态。</li>
</ul>
<blockquote>
<p>⁵ 这就是为什么在 <code>ps(1)</code> 命令中会出现那些状态为 D (即
<code>TASK_UNINTERRUPTIBLE</code>)
的、令人头疼的无法杀死的进程。因为该任务不响应信号，你无法向它发送
<code>SIGKILL</code>
信号。此外，即使你能终止该任务，这样做通常也不明智，因为该任务可能正在进行一项重要操作（并可能持有信号量）。</p>
</blockquote>
<h3
id="操作当前进程状态-manipulating-the-current-process-state"><strong>操作当前进程状态
(Manipulating the Current Process State)</strong></h3>
<p>内核代码经常需要更改进程的状态。首选机制是使用： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_task_state(task, state);        <span class="comment">/* 将任务 &#x27;task&#x27; 的状态设置为 &#x27;state&#x27; */</span></span><br></pre></td></tr></table></figure>
此函数将给定的任务设置为给定的状态。在适用的情况下，它还提供一个<strong>内存屏障
(memory barrier)</strong> 以强制在其他处理器上的执行顺序（这仅在 SMP
系统上需要）。否则，它等价于： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task-&gt;state = state;</span><br></pre></td></tr></table></figure> 方法
<code>set_current_state(state)</code> 等同于
<code>set_task_state(current, state)</code>。请参阅
<code>&lt;linux/sched.h&gt;</code> 以了解这些及相关函数的实现。</p>
<hr />
<h3 id="进程上下文-process-context"><strong>进程上下文 (Process
Context)</strong></h3>
<p>进程最重要的部分之一是正在执行的程序代码。这些代码从可执行文件中读入，并在程序的地址空间内执行。正常的程序执行发生在<strong>用户空间
(user-space)</strong>。当程序执行系统调用或触发异常时，它就进入了<strong>内核空间
(kernel-space)</strong>。此时，内核被称为“代表进程执行”并处于<strong>进程上下文
(process context)</strong> 中。在进程上下文中，<code>current</code>
宏是有效的⁶。退出内核后，进程会在用户空间恢复执行，除非在此期间有更高优先级的进程变为可运行状态（这种情况下将调用调度器来选择更高优先级的进程）。</p>
<blockquote>
<p>⁶ 除了进程上下文，还有<strong>中断上下文 (interrupt
context)</strong>。在中断上下文中，系统并非代表某个进程运行，而是在执行一个中断处理程序。没有进程与中断处理程序相关联。</p>
</blockquote>
<p>系统调用和异常处理程序是进入内核的明确定义的接口。进程只能通过这些接口之一开始在内核空间中执行——所有对内核的访问都是通过这些接口进行的。</p>
<hr />
<h3 id="进程家族树-the-process-family-tree"><strong>进程家族树 (The
Process Family Tree)</strong></h3>
<p>在 Unix 系统（Linux
也不例外）的进程之间存在着一个清晰的层次结构。所有进程都是 <strong>init
进程</strong>（其 PID 为 1）的后代。内核在启动过程的最后步骤中启动
<code>init</code>。然后，<code>init</code>
进程读取系统初始化脚本并执行更多程序，最终完成启动过程。</p>
<p>系统中的每个进程都有且只有一个<strong>父进程
(parent)</strong>。同样，每个进程有零个或多个<strong>子进程
(children)</strong>。同一父进程的所有直接子进程称为<strong>兄弟进程
(siblings)</strong>。进程之间的关系存储在进程描述符中。每个
<code>task_struct</code> 都有一个指向父进程 <code>task_struct</code>
的指针（名为 <code>parent</code>），以及一个子进程的链表（名为
<code>children</code>）。</p>
<p>因此，给定当前进程，可以通过以下代码获取其父进程的描述符：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">my_parent</span> =</span> current-&gt;parent;</span><br></pre></td></tr></table></figure> 类似地，可以这样遍历一个进程的所有子进程：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each(<span class="built_in">list</span>, &amp;current-&gt;children) &#123;</span><br><span class="line">    task = list_entry(<span class="built_in">list</span>, <span class="keyword">struct</span> task_struct, sibling);</span><br><span class="line">    <span class="comment">/* task 现在指向 current 的某个子进程 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>init 任务的进程描述符是静态分配的，名为
<code>init_task</code>。所有进程间关系的一个很好例证是下面这段代码总能执行成功：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="keyword">for</span> (task = current; task != &amp;init_task; task = task-&gt;parent)</span><br><span class="line">    ;</span><br><span class="line"><span class="comment">/* 循环结束后，task 指向了 init */</span></span><br></pre></td></tr></table></figure>
实际上，你可以从系统中的任何一个进程出发，循着进程层次结构到达任何其他进程。</p>
<p>然而，通常我们更希望简单地遍历系统中的所有进程。这很容易，因为任务列表是一个<strong>循环双向链表
(circular doubly linked
list)</strong>。给定任何一个有效任务，要获取链表中的下一个任务，可以使用：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_entry(task-&gt;tasks.next, <span class="keyword">struct</span> task_struct, tasks)</span><br></pre></td></tr></table></figure> 获取上一个任务的方式相同： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_entry(task-&gt;tasks.prev, <span class="keyword">struct</span> task_struct, tasks)</span><br></pre></td></tr></table></figure>
这两个操作分别由宏 <code>next_task(task)</code> 和
<code>prev_task(task)</code> 提供。最后，提供了宏
<code>for_each_process(task)</code>
用于遍历整个任务列表。每次迭代时，<code>task</code>
指向列表中的下一个任务： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">for_each_process(task) &#123;</span><br><span class="line">    <span class="comment">/* 这段代码无意义地打印每个任务的名称和 PID */</span></span><br><span class="line">    printk(<span class="string">&quot;%s[%d]\n&quot;</span>, task-&gt;comm, task-&gt;pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>注意</strong>
在拥有大量进程的系统中，遍历每个任务的开销很大；代码在这样做之前应该有充分的理由（并且没有其他替代方案）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/19/oper_sys21lab_kMod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/19/oper_sys21lab_kMod/" class="post-title-link" itemprop="url">操作系统基础 | 4.7 内核模块实验</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-20 01:15:49" itemprop="dateCreated datePublished" datetime="2025-08-20T01:15:49+08:00">2025-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-21 00:31:13" itemprop="dateModified" datetime="2025-08-21T00:31:13+08:00">2025-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/lab/" itemprop="url" rel="index"><span itemprop="name">lab</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="可加载的内核模块">可加载的内核模块</h3>
<h4 id="练习-1">练习 1</h4>
<p>准备好实验报告</p>
<hr />
<h4 id="练习-2-编译内核模块">练习 2: 编译内核模块</h4>
<ol type="1">
<li><strong>步骤</strong>: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Linux Lab 集群上</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /project/scratch01/compile/your-username/modules</span><br><span class="line"><span class="built_in">cd</span> /project/scratch01/compile/your-username/modules</span><br><span class="line"><span class="comment"># 保存 simple_module.c 和 Makefile (内容: obj-m := simple_module.o)</span></span><br><span class="line">module add arm-rpi</span><br><span class="line"><span class="built_in">export</span> LINUX_SOURCE=/path/to/your/linux_source/linux <span class="comment"># 设置内核源码路径</span></span><br><span class="line">make -C <span class="variable">$LINUX_SOURCE</span> ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- M=<span class="variable">$PWD</span> modules</span><br></pre></td></tr></table></figure></li>
<li><strong>答案</strong>: 提交 <code>make</code> 命令的完整输出。</li>
</ol>
<hr />
<h4 id="练习-3-加载模块与系统日志">练习 3: 加载模块与系统日志</h4>
<ol type="1">
<li><strong>步骤</strong> (在树莓派上): <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/modules</span><br><span class="line"><span class="comment"># 使用 sftp 将 simple_module.ko 传输到此目录</span></span><br><span class="line">sudo dmesg --clear</span><br><span class="line">sudo insmod ~/modules/simple_module.ko</span><br><span class="line">dmesg <span class="comment"># 查看日志</span></span><br></pre></td></tr></table></figure></li>
<li><strong>答案</strong>: 提交 <code>dmesg</code>
中显示的模块加载信息。</li>
</ol>
<hr />
<h4 id="练习-4-验证模块列表与卸载">练习 4: 验证模块列表与卸载</h4>
<ol type="1">
<li><strong>步骤</strong>: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsmod <span class="comment"># 确认 simple_module 在列表中</span></span><br><span class="line">sudo rmmod simple_module</span><br><span class="line">lsmod <span class="comment"># 确认已移除</span></span><br><span class="line">dmesg <span class="comment"># 查看卸载信息</span></span><br></pre></td></tr></table></figure></li>
<li><strong>答案</strong>: 提交 <code>lsmod</code>
的输出（证明已卸载）和 <code>dmesg</code> 中显示的模块卸载信息。</li>
</ol>
<hr />
<h4 id="练习-5-访问内核变量-jiffies">练习 5: 访问内核变量 jiffies</h4>
<ol type="1">
<li><strong>步骤</strong>:
<ul>
<li>复制 <code>simple_module.c</code> 为
<code>jiffies_module.c</code>。</li>
<li>修改其 init 和 exit 函数，使用 <code>printk</code> 打印
<code>jiffies</code> 变量（类型
<code>extern unsigned long volatile jiffies;</code>）。</li>
<li>更新 Makefile: <code>obj-m += jiffies_module.o</code>。</li>
<li>重新编译并传输 <code>jiffies_module.ko</code> 到树莓派。</li>
<li>加载并卸载模块，观察 <code>dmesg</code>。</li>
</ul></li>
<li><strong>答案</strong>:
<ul>
<li>提交 <code>dmesg</code> 中显示加载和卸载时 <code>jiffies</code>
值的日志消息。</li>
<li>计算并说明两条消息之间发生的滴答数（tick count）。</li>
</ul></li>
</ol>
<hr />
<h3 id="需提交的内容">需提交的内容</h3>
<p>请提交一个包含以下内容的压缩包或文档： 1. <strong>答案文件</strong>:
包含上述所有练习的答案。 2. <strong>源代码文件</strong>: 你新创建的
<code>jiffies_module.c</code> 文件。</p>
<hr />
<h3 id="可选拓展练习">可选拓展练习</h3>
<h4 id="练习-6-模块初始化返回值实验">练习 6: 模块初始化返回值实验</h4>
<ul>
<li><strong>任务</strong>: 修改 init
函数，使其分别返回正数和负数（错误码，参见
<code>/include/uapi/asm-generic/errno-base.h</code>）。</li>
<li><strong>提示</strong>:
描述加载模块时发生的情况及其在系统日志中的表现。</li>
</ul>
<h4 id="练习-7-探查导出的内核符号">练习 7: 探查导出的内核符号</h4>
<ul>
<li><strong>任务</strong>: 查看 <code>/proc/kallsyms</code> 文件（例如
<code>cat /proc/kallsyms</code>），了解内核符号表。查找带有
<code>__kstrtab_</code> 和 <code>__ksymtab_</code>
前缀的符号（这些是可供模块使用的导出符号）。</li>
<li><strong>提示</strong>: 内核符号是 Linux
内核代码中定义的函数、变量、数据结构等的名称标签。它们代表了在内核地址空间中的一个特定内存地址。
可以将内核符号理解为内核的“公共接口”或“入口点”。主要有两种类型：</li>
<li>导出的符号：这些是内核明确声明为可以被外部模块使用的符号。例如，printk（内核的
printf）、kmalloc（内核的内存分配函数）等。模块通过使用 EXPORT_SYMBOL()
或 EXPORT_SYMBOL_GPL() 宏来导出它们的符号，以便其他模块可以使用。</li>
<li>非导出的符号：这些是内核内部的静态函数或变量，只在它们被定义的文件或内核的特定部分中使用。它们对于内核模块是不可见的，主要用于内核自身的组织</li>
<li>EXPORT_SYMBOL(printk) 在编译后创建了两个内部符号：__ksymtab_printk
和 __kstrtab_printk。
<ul>
<li>__ksymtab_printk 是一个结构体，包含了 printk 的地址和指向
__kstrtab_printk 的指针。</li>
<li>__kstrtab_printk 是一个字符串，存储着 printk 的名字。</li>
</ul></li>
<li>内核使用这个结构来高效地通过名字查找函数的地址</li>
</ul>
<h4 id="练习-8-实现用户态读取-cpu-周期计数器-ccnt-的模块">练习 8:
实现用户态读取 CPU 周期计数器 (CCNT) 的模块</h4>
<ul>
<li><strong>任务</strong> (如果之前在系统调用工作室未完成):
<ul>
<li>将提供的驱动文件放入你的内核源码树的
<code>arch/arm/include/asm</code> 目录。</li>
<li>下载 <code>enable_ccnt.c</code> 内核模块代码到你的模块目录。</li>
<li>编译、传输并加载此模块 (<code>insmod enable_ccnt.ko</code>)。</li>
<li>使用 <code>dmesg | tail</code> 验证加载成功。</li>
</ul></li>
<li><strong>任务</strong> (主要部分):
<ul>
<li>在树莓派上创建一个用户态程序。</li>
<li>该程序应 <code>#include</code> 你获取的驱动头文件。</li>
<li>调用 <code>unsigned long long pmccntr_get(void)</code>
函数两次。</li>
</ul></li>
<li><strong>答案</strong>:
<ul>
<li>说明运行一次 <code>pmccntr_get()</code> 函数大约需要多少 CPU
周期（计算两次调用的差值）。</li>
<li>如果你在系统调用工作室完成过类似的练习，请对比直接调用此函数与通过系统调用获取周期计数所需的周期数。</li>
</ul></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/19/oper_sys20rebuildIDRApi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/19/oper_sys20rebuildIDRApi/" class="post-title-link" itemprop="url">操作系统基础 | 4.6 内核API重构案例：IDR API</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-20 01:07:16 / 修改时间：01:11:57" itemprop="dateCreated datePublished" datetime="2025-08-20T01:07:16+08:00">2025-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>文章内容来自 LWN.net</p>
<h3 id="文章摘要-summary">文章摘要 (Summary)</h3>
<p>这篇发表于 2013 年 2 月的文章讨论了 Linux 内核中 <strong>IDR 子系统
API 的一次重大简化改革</strong>，由开发者 Tejun Heo 主导。IDR
机制用于高效分配和管理整数 ID（例如设备名、POSIX 定时器 ID 等），其旧
API 因其复杂性和潜在的竞争条件而闻名。</p>
<p><strong>核心问题：旧 API 的缺陷</strong> 1.
<strong>两步分配</strong>：需要先调用 <code>idr_pre_get()</code>
预分配内存（可休眠），再调用 <code>idr_get_new()</code> 获取
ID（可原子上下文）。 2.
<strong>必须重试循环</strong>：<code>idr_get_new()</code>
可能因预分配内存被其他 CPU 耗尽而失败（返回
<code>-EAGAIN</code>），要求调用者编写冗长且易错的循环重试代码。 3.
<strong>全局资源竞争</strong>：<code>idr_pre_get()</code>
预分配的内存是全局的，多个 CPU 竞争时，后执行的
<code>idr_get_new()</code>
可能因资源不足而失败，迫使代码退出原子上下文进行重试，这条路径往往缺乏测试。</p>
<p><strong>解决方案：新 API 的改进</strong> Tejun Heo
引入了三个新函数来简化流程： 1.
<code>idr_preload(gfp_t gfp_mask)</code>: 为<strong>当前 CPU</strong>
预分配内存，并<strong>禁用抢占</strong>以防止预分配的内存被偷。 2.
<code>idr_alloc(...)</code>: <strong>单次调用</strong>即可完成 ID
分配和关联。它接受 ID
范围参数，并仅在真正需要时（未预分配或预分配不足）才使用
<code>gfp_mask</code> 分配内存。它只会在内存分配彻底失败时报错，消除了对
<code>-EAGAIN</code> 的重试循环需求。 3. <code>idr_preload_end()</code>:
在 <code>idr_alloc</code> 后调用，<strong>重新启用抢占</strong>。</p>
<p><strong>关键优势：</strong> *
<strong>更简单</strong>：消除了遍布内核的百余处重复、易错的样板代码。 *
<strong>更可靠</strong>：通过每 CPU
预分配和禁用抢占，基本消除了在原子上下文中因资源竞争而失败的需要。 *
<strong>更灵活</strong>：<code>idr_alloc</code> 可以指定 ID
范围，并且如果能在进程上下文调用，甚至可以完全省略
<code>idr_preload</code>/<code>idr_preload_end</code>。</p>
<p><strong>社区反应：</strong> 尽管大部分开发者接受了这个改动（给出了
Acked-by），但 Eric Biederman 表达了强烈反对，认为新 API 的
<code>idr_preload</code>
像是一种难以理解的“魔法”。然而，文章作者（Jonathan
Corbet）预测，<strong>新 API
带来的巨大简化优势将使其最终被内核社区接受</strong>。</p>
<h3 id="新旧-api-对比总结">新旧 API 对比总结</h3>
<div class="line-block">特性 | 旧 API (2013 年前) | 新 API (Tejun Heo
提议) |<br />
：--- | :--- | :--- |<br />
<strong>核心函数</strong> | <code>idr_pre_get()</code>,
<code>idr_get_new()</code> | <code>idr_preload()</code>,
<code>idr_alloc()</code>, <code>idr_preload_end()</code> |<br />
<strong>调用模式</strong> |
<strong>两步过程</strong>，必须配合<strong>重试循环</strong> |
<strong>单次调用</strong>
(<code>idr_alloc</code>)，<strong>无需循环</strong> |<br />
<strong>预分配内存</strong> | <strong>全局共享</strong>，易被其他 CPU
消耗 | <strong>每 CPU
独享</strong>，配合<strong>禁用抢占</strong>，不会被偷 |<br />
<strong>错误处理</strong> | 可能返回
<code>-EAGAIN</code>，要求调用者重试 | 仅在所有内存分配都失败时才报错
|<br />
<strong>原子上下文</strong> | 支持，但重试时必须退出原子上下文 |
更好支持，通过 <code>preload</code>/<code>preload_end</code> 保障
|<br />
<strong>代码复杂度</strong> | 高，需要大量重复的样板代码 |
低，调用逻辑非常简洁 |</div>
<h3 id="结论">结论</h3>
<p>这篇文章记录了一个经典的内核优化案例：通过巧妙的设计（利用每 CPU
数据和禁用抢占）将一个复杂、易错、充满竞争条件的旧接口，重构为一个简洁、可靠、高效的新接口。尽管存在一些争议，但<strong>简化并提升广泛使用的底层
API
的价值是极其巨大的</strong>，这很可能是新方案最终被采纳的原因。这正是
Linux 内核持续演进的一个缩影。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/19/kamacode36stock2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/19/kamacode36stock2/" class="post-title-link" itemprop="url">代码随想录 | 刷题-动态规划9</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-20 01:04:53" itemprop="dateCreated datePublished" datetime="2025-08-20T01:04:53+08:00">2025-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-10 01:03:01" itemprop="dateModified" datetime="2025-09-10T01:03:01+08:00">2025-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="买卖股票的最佳时机iv">188.买卖股票的最佳时机IV</h3>
<p>买卖股票三的扩展版，从最多两次交易扩充到k次交易。注意买入和卖出某个数量的股票都要单列一列dp，并采用不同的状态转移方式。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>*k+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=<span class="number">2</span>*k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">1</span>)dp[<span class="number">0</span>][i] -= prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=<span class="number">2</span>*k; j+=<span class="number">2</span>)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>] - prices[i], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j&lt;=<span class="number">2</span>*k; j+=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// printf(&quot;index of prices: %d, sold out stock id: %d\n&quot;, i, j);</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + prices[i], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">2</span>*k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="最佳买卖股票时机含冷冻期">309.最佳买卖股票时机含冷冻期</h3>
<p>我这道题还是写复杂了。其实不规定买入次数，就不需要每次买卖都开一个状态了，每天都计算持有/非持有状态即可，还可以省空间复杂度
我采用的思路延续了每次买入都有两个不同状态的方案，当计算卖出的时候往前比较两天，就是需要注意第二天持有股票状态的递推公式的特殊情况（选择第二天买入还是第一天买入）。其实采用仅四个状态也可以：
状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）
不持有股票状态，这里就有两种卖出股票状态 -
状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）
- 状态三：今天卖出股票
状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> status = prices.<span class="built_in">size</span>()*<span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(status+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= status; i += <span class="number">2</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] -= prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= status; j += <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// printf(&quot;prices: %d, hold stock cnt: %d\n&quot;, i, j);</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-2</span>][j<span class="number">-1</span>] - prices[i], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(-prices[i], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= status; j += <span class="number">2</span>)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + prices[i], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(auto l: dp)&#123;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;&quot;prices line &quot;;</span></span><br><span class="line">        <span class="comment">//     for(auto i: l)&#123;</span></span><br><span class="line">        <span class="comment">//         cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][status];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="买卖股票的最佳时机含手续费">714.买卖股票的最佳时机含手续费</h3>
<p>这题延续 <em>122.买卖股票的最佳时机II</em> 的思路即可
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> status = prices.<span class="built_in">size</span>()*<span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt; prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]-fee, dp[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i], dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int i = 0; i&lt;dp.size(); i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j = 0; j&lt;dp[0].size(); j++)&#123;</span></span><br><span class="line">        <span class="comment">//         cout&lt;&lt;dp[i][j]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/12/oper_sys19kernelMod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/12/oper_sys19kernelMod/" class="post-title-link" itemprop="url">操作系统基础 | 4.5 内核数据结构-内核模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-13 00:14:02" itemprop="dateCreated datePublished" datetime="2025-08-13T00:14:02+08:00">2025-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-16 06:49:37" itemprop="dateModified" datetime="2025-08-16T06:49:37+08:00">2025-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="linux-内核模块开发简介">Linux 内核模块开发简介</h3>
<h4 id="设备类型分类">设备类型分类</h4>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 9%" />
<col style="width: 26%" />
<col style="width: 26%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>缩写</strong></th>
<th><strong>访问方式</strong></th>
<th><strong>典型设备</strong></th>
<th><strong>特殊文件</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>块设备</strong></td>
<td>blkdevs</td>
<td>按块随机访问（支持寻址）</td>
<td>硬盘/SSD/光驱</td>
<td><code>/dev/sda1</code></td>
</tr>
<tr>
<td><strong>字符设备</strong></td>
<td>cdevs</td>
<td>字节流顺序访问</td>
<td>键盘/打印机/伪设备</td>
<td><code>/dev/ttyS0</code></td>
</tr>
<tr>
<td><strong>网络设备</strong></td>
<td>-</td>
<td>套接字API（破坏"一切皆文件"原则）</td>
<td>网卡/无线适配器</td>
<td>无设备节点</td>
</tr>
<tr>
<td><strong>混杂设备</strong></td>
<td>miscdevs</td>
<td>字符设备简化形式</td>
<td>简单专用设备</td>
<td><code>/dev/random</code> 等</td>
</tr>
</tbody>
</table>
<p><strong>伪设备示例</strong>： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/dev/random   <span class="comment"># 内核随机数生成器</span></span><br><span class="line">/dev/null     <span class="comment"># 空设备（丢弃所有写入）</span></span><br><span class="line">/dev/zero     <span class="comment"># 零设备（提供无限\0字节）</span></span><br><span class="line">/dev/full     <span class="comment"># 满设备（写入总返回ENOSPC错误）</span></span><br><span class="line">/dev/mem      <span class="comment"># 物理内存访问设备</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h3 id="内核模块开发">内核模块开发</h3>
<h4 id="hello-world-模块示例">Hello World 模块示例</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模块加载时执行 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;I bear a charmed life.\n&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 返回0表示成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模块卸载时执行 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Out, out, brief candle!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册入口/出口函数 */</span></span><br><span class="line">module_init(hello_init);  <span class="comment">// 不是函数调用，而是宏定义</span></span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模块元信息 */</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);                  <span class="comment">// 必须声明许可证</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Shakespeare&quot;</span>);           <span class="comment">// 作者信息</span></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Hello World Module&quot;</span>); <span class="comment">// 模块描述</span></span><br></pre></td></tr></table></figure>
<h4 id="关键机制解析">关键机制解析</h4>
<ol type="1">
<li><strong>入口函数</strong>：
<ul>
<li>形式：<code>int init_func(void)</code></li>
<li>职责：注册资源/初始化硬件/分配数据结构</li>
<li>返回值：0=成功，非0=失败</li>
</ul></li>
<li><strong>出口函数</strong>：
<ul>
<li>形式：<code>void exit_func(void)</code></li>
<li>职责：释放资源/复位硬件/清理状态</li>
</ul></li>
<li><strong>许可证声明</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);  <span class="comment">// 合法选项：GPL/MIT/BSD等</span></span><br></pre></td></tr></table></figure>
<ul>
<li>非GPL模块会导致内核标记为"tainted"</li>
<li>无法调用GPL-only符号</li>
</ul></li>
</ol>
<hr />
<h3 id="模块构建指南">模块构建指南</h3>
<h4 id="集成到内核源码树推荐">集成到内核源码树（推荐）</h4>
<ol type="1">
<li><strong>选择路径</strong>：
<ul>
<li>字符设备 → <code>drivers/char/</code></li>
<li>块设备 → <code>drivers/block/</code></li>
<li>USB设备 → <code>drivers/usb/</code></li>
</ul></li>
<li><strong>修改Makefile</strong>： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># drivers/char/Makefile 添加</span></span><br><span class="line">obj-<span class="variable">$(CONFIG_FISHING_POLE)</span> += fishing/</span><br><span class="line"></span><br><span class="line"><span class="comment"># drivers/char/fishing/Makefile 内容</span></span><br><span class="line">obj-<span class="variable">$(CONFIG_FISHING_POLE)</span> += fishing.o</span><br><span class="line">fishing-objs := main.o line.o  <span class="comment"># 多文件模块</span></span><br><span class="line">EXTRA_CFLAGS += -DTITANIUM_POLE  <span class="comment"># 自定义编译标志</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="外部独立构建">外部独立构建</h4>
<ol type="1">
<li><p><strong>Makefile示例</strong>： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj-m := fishing.o</span><br><span class="line">fishing-objs := fishing-main.o fishing-line.o</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C /path/to/kernel/source M=<span class="variable">$(PWD)</span> modules</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>构建命令</strong>： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在模块目录执行</span></span><br><span class="line">make -C /lib/modules/$(<span class="built_in">uname</span> -r)/build M=<span class="variable">$PWD</span> modules</span><br></pre></td></tr></table></figure> ### 模块管理</p></li>
</ol>
<h4 id="模块安装路径规范">模块安装路径规范</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标准安装路径模板</span></span><br><span class="line">/lib/modules/$(<span class="built_in">uname</span> -r)/kernel/&lt;源码树路径&gt;/&lt;模块名&gt;.ko</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：2.6.34内核的钓鱼竿模块</span></span><br><span class="line">/lib/modules/2.6.34/kernel/drivers/char/fishing.ko</span><br></pre></td></tr></table></figure>
<p><strong>安装命令</strong>： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make modules_install  <span class="comment"># 需root权限</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h3 id="模块依赖管理">模块依赖管理</h3>
<h4 id="依赖关系生成">1. 依赖关系生成</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成完整依赖关系</span></span><br><span class="line">sudo depmod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增量更新（仅处理新模块）</span></span><br><span class="line">sudo depmod -A</span><br></pre></td></tr></table></figure>
<h4 id="依赖存储位置">2. 依赖存储位置</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依赖关系文件路径</span></span><br><span class="line">/lib/modules/$(<span class="built_in">uname</span> -r)/modules.dep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件内容示例</span></span><br><span class="line">kernel/drivers/char/fishing.ko: kernel/drivers/net/bait.ko</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>智能加载原理</strong>：<br />
当加载 <code>chum.ko</code> 时，系统自动解析其依赖并先加载
<code>bait.ko</code></p>
</blockquote>
<hr />
<h3 id="模块加载与卸载">模块加载与卸载</h3>
<h4 id="基础工具不推荐">基础工具（不推荐）</h4>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 27%" />
<col style="width: 29%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>命令</strong></th>
<th><strong>缺陷</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>加载</td>
<td><code>insmod module.ko</code></td>
<td>无依赖解析</td>
<td><code>insmod fishing.ko</code></td>
</tr>
<tr>
<td>卸载</td>
<td><code>rmmod module_name</code></td>
<td>不检查依赖</td>
<td><code>rmmod fishing</code></td>
</tr>
</tbody>
</table>
<h4 id="高级工具推荐">高级工具（推荐）</h4>
<p><strong>1. 智能加载</strong>： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载模块（自动处理依赖）</span></span><br><span class="line">sudo modprobe fishing pole_length=300 material=titanium</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看加载的模块</span></span><br><span class="line">lsmod | grep fishing</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 安全卸载</strong>： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载模块（自动移除未用依赖）</span></span><br><span class="line">sudo modprobe -r fishing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制卸载（危险！）</span></span><br><span class="line">sudo modprobe -rf fishing  <span class="comment"># 可能破坏依赖树</span></span><br></pre></td></tr></table></figure></p>
<h3 id="内核配置与模块开发高级指南">内核配置与模块开发高级指南</h3>
<h4 id="配置选项管理-kconfig">配置选项管理 (Kconfig)</h4>
<p>linux使用kbuild系统，可以通过修改Kconfig文件便捷地管理配置选项
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># drivers/char/Kconfig 示例</span><br><span class="line">config FISHING_POLE</span><br><span class="line">    tristate &quot;Fish Master 3000 support&quot;  # 三态选项，表示模块在编译配置中可以内置编译到内核（Y），作为模块编译（M）或者不编译（N）</span><br><span class="line">    default n                            # 默认禁用</span><br><span class="line">    depends on FISH_TANK &amp;&amp; !NO_FISHING  # 依赖条件</span><br><span class="line">    select BAIT                          # 强制关联选项</span><br><span class="line">    help                                 # 帮助文档</span><br><span class="line">        Enable support for the Fish Master 3000 computer interface.</span><br><span class="line">        Choose Y to build into kernel, M for module (fishing.ko), or N to disable.</span><br></pre></td></tr></table></figure></p>
<p><strong>核心指令解析</strong>： | <strong>指令</strong> |
<strong>功能</strong> | <strong>示例</strong> |
|----------------|----------------------------------|-----------------------------------|
| <code>tristate</code> | 三态选项 (Y/M/N) | 驱动标准配置 | |
<code>bool</code> | 布尔选项 (Y/N) | 特性开关 | | <code>default</code> |
默认值 | <code>default y</code> 默认启用 | | <code>depends on</code> |
依赖关系 | <code>depends on NET</code> 需网络支持 | |
<code>select</code> | 强制启用其他选项 | <code>select CRC32</code>
自动启用CRC校验 | | <code>if</code> | 条件显示 |
<code>if EMBEDDED</code> 嵌入式场景可见 | | <code>help</code> | 帮助文档
| 用户配置时的说明文本 |</p>
<hr />
<h3 id="模块参数系统">模块参数系统</h3>
<h4 id="基础参数声明">1. 基础参数声明</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> pole_length = <span class="number">200</span>;  <span class="comment">// 默认值</span></span><br><span class="line">module_param(pole_length, <span class="type">int</span>, <span class="number">0644</span>);  <span class="comment">// 整型参数</span></span><br><span class="line">MODULE_PARM_DESC(pole_length, <span class="string">&quot;Pole length in cm&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="高级参数类型">2. 高级参数类型</h4>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 32%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>charp</code></td>
<td>字符串指针</td>
<td><code>module_param(name, charp, 0);</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td>布尔值</td>
<td><code>module_param(enable, bool, 0);</code></td>
</tr>
<tr>
<td><code>module_param_string</code></td>
<td>直接复制到数组</td>
<td><code>char target[32]; module_param_string(dest, target, sizeof(target), 0);</code></td>
</tr>
<tr>
<td><code>module_param_array</code></td>
<td>数组参数</td>
<td><code>int ids[5]; int count; module_param_array(ids, int, &amp;count, 0);</code></td>
</tr>
</tbody>
</table>
<h4 id="参数传递方式">3. 参数传递方式</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载时指定参数</span></span><br><span class="line">sudo modprobe fishing pole_length=300 material=carbon</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看参数信息</span></span><br><span class="line">modinfo fishing</span><br><span class="line">parm:           pole_length:Pole length <span class="keyword">in</span> cm (int)</span><br><span class="line">parm:           material:Construction material (charp)</span><br></pre></td></tr></table></figure>
<h4 id="sysfs集成">4. sysfs集成</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数自动暴露到sysfs</span></span><br><span class="line">/sys/module/fishing/parameters/pole_length  <span class="comment"># 权限0644=rwr--r--</span></span><br></pre></td></tr></table></figure>
<hr />
<h3 id="符号导出机制">符号导出机制</h3>
<h4 id="基础导出">1. 基础导出</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明可被模块调用的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_pole_strength</span><span class="params">(<span class="keyword">struct</span> pole *p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;load_capacity;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(get_pole_strength);  <span class="comment">// 全局导出</span></span><br></pre></td></tr></table></figure>
<h4 id="gpl受限导出">2. GPL受限导出</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPORT_SYMBOL_GPL(calculate_bait_ratio);  <span class="comment">// 仅GPL模块可用</span></span><br></pre></td></tr></table></figure>
<h4 id="导出规则">3. 导出规则</h4>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 35%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr>
<th><strong>导出类型</strong></th>
<th><strong>调用权限</strong></th>
<th><strong>典型场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EXPORT_SYMBOL</code></td>
<td>所有模块</td>
<td>通用内核API</td>
</tr>
<tr>
<td><code>EXPORT_SYMBOL_GPL</code></td>
<td>仅GPL许可证模块</td>
<td>核心子系统接口</td>
</tr>
<tr>
<td>未导出符号</td>
<td>仅内核内部使用</td>
<td>静态函数/私有实现</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="配置系统元选项">配置系统元选项</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">config EXPERIMENTAL</span><br><span class="line">    bool &quot;Enable experimental features&quot;  # 高风险功能开关</span><br><span class="line">    default n</span><br><span class="line"></span><br><span class="line">config DEBUG_KERNEL</span><br><span class="line">    bool &quot;Kernel debugging&quot;  # 调试选项总开关</span><br><span class="line">    default y if DEBUG</span><br></pre></td></tr></table></figure>
<p><strong>关键元选项</strong>： -
<code>CONFIG_EMBEDDED</code>：嵌入式系统优化选项 -
<code>CONFIG_BROKEN_ON_SMP</code>：标记非SMP安全驱动 -
<code>CONFIG_EXPERIMENTAL</code>：实验性功能入口</p>
<hr />
<h3 id="开发工作流示例">开发工作流示例</h3>
<h4 id="添加新驱动">1. 添加新驱动</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建Kconfig</span></span><br><span class="line"><span class="comment"># drivers/char/fishing/Kconfig</span></span><br><span class="line">config FISHING_PRO</span><br><span class="line">    tristate <span class="string">&quot;Professional Fishing Module&quot;</span></span><br><span class="line">    select FISHING_ADVANCED</span><br><span class="line">    <span class="built_in">help</span></span><br><span class="line">      Support <span class="keyword">for</span> professional-grade fishing equipment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改上级Kconfig</span></span><br><span class="line"><span class="comment"># drivers/char/Kconfig</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">&quot;drivers/char/fishing/Kconfig&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="实现参数化模块">2. 实现参数化模块</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> material[<span class="number">20</span>] = <span class="string">&quot;fiberglass&quot;</span>;</span><br><span class="line">module_param_string(material, material, <span class="keyword">sizeof</span>(material), <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lengths[] = &#123;<span class="number">180</span>, <span class="number">240</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> nr_lengths = <span class="number">2</span>;</span><br><span class="line">module_param_array(lengths, <span class="type">int</span>, &amp;nr_lengths, <span class="number">0444</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> enable_ai;</span><br><span class="line">module_param(enable_ai, <span class="type">bool</span>, <span class="number">0644</span>);</span><br></pre></td></tr></table></figure>
<h4 id="编译验证">3. 编译验证</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置内核</span></span><br><span class="line">make menuconfig</span><br><span class="line"><span class="comment"># -&gt; Device Drivers -&gt; Character devices -&gt; Professional Fishing Module (M)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">make -j$(<span class="built_in">nproc</span>) modules</span><br><span class="line">sudo make modules_install</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="生产环境最佳实践">生产环境最佳实践</h3>
<ol type="1">
<li><p><strong>参数安全</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> max_load = <span class="number">100</span>;</span><br><span class="line">module_param(max_load, <span class="type">int</span>, <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_func</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (max_load &gt; MAX_SAFE_LIMIT) &#123;</span><br><span class="line">        pr_warn(<span class="string">&quot;Dangerous load limit %d, capping at %d\n&quot;</span>, </span><br><span class="line">                max_load, MAX_SAFE_LIMIT);</span><br><span class="line">        max_load = MAX_SAFE_LIMIT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>版本兼容</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5,15,0)</span></span><br><span class="line"><span class="comment">// 新版内核API</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// 旧版兼容实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>错误处理</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> err = register_device();</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 彻底回滚初始化</span></span><br><span class="line">    unregister_previous();</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<blockquote>
<p><strong>性能提示</strong>：高频访问的模块参数应复制到局部变量，避免频繁查sysfs</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/12/oper_sys18btree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/12/oper_sys18btree/" class="post-title-link" itemprop="url">操作系统基础 | 4.4 内核数据结构-二叉树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-12 22:25:51" itemprop="dateCreated datePublished" datetime="2025-08-12T22:25:51+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-13 00:13:25" itemprop="dateModified" datetime="2025-08-13T00:13:25+08:00">2025-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="二叉树">二叉树</h3>
<h4 id="二叉搜索树bst核心特性">1. 二叉搜索树（BST）核心特性</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">根节点左子树的所有节点值 &lt; 根节点值</span><br><span class="line">根节点右子树的所有节点值 &gt; 根节点值</span><br><span class="line">所有子树都是二叉搜索树</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>操作复杂度</strong>：
<ul>
<li>查找：O(log n)<br />
</li>
<li>有序遍历：O(n)</li>
</ul></li>
<li><strong>缺陷</strong>：不平衡树可能导致操作退化到O(n)</li>
</ul>
<h4 id="自平衡二叉搜索树">2. 自平衡二叉搜索树</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">叶子节点深度差 ≤ 1   →   树高度 = O(log n)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>平衡机制</strong>：在插入/删除时自动调整结构</li>
<li><strong>常见类型</strong>：
<ul>
<li>AVL树（严格平衡）</li>
<li><strong>红黑树</strong>（半平衡，Linux首选）</li>
</ul></li>
</ul>
<hr />
<h3 id="红黑树red-black-trees">红黑树（Red-Black Trees）</h3>
<h4 id="六大约束条件">六大约束条件</h4>
<ol type="1">
<li>节点非红即黑</li>
<li>叶子节点（NIL）为黑</li>
<li>叶子节点不存储数据</li>
<li>非叶子节点必有双子</li>
<li><strong>红节点的子节点必为黑</strong>（核心约束）</li>
<li>根到任意叶子的黑节点数相同</li>
</ol>
<h4 id="优势">优势</h4>
<ul>
<li>插入/删除只需O(1)次旋转（AVL需O(log n)）</li>
<li>查找效率稳定在O(log n)</li>
<li>内存开销小（仅1bit存储颜色）</li>
</ul>
<hr />
<h3 id="linux实现rbtree">Linux实现（rbtree）</h3>
<h4 id="初始化">初始化</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/rbtree.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">root</span> =</span> RB_ROOT;  <span class="comment">// 声明并初始化根节点</span></span><br></pre></td></tr></table></figure>
<h4 id="节点定义">节点定义</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span>  <span class="comment">// 嵌入红黑树节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="查找实现页缓存示例">查找实现（页缓存示例）</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">rb_search_page_cache</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">unsigned</span> <span class="type">long</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span> =</span> inode-&gt;i_rb_page_cache.rb_node;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> rb_entry(n, <span class="keyword">struct</span> page, rb_page_cache);</span><br><span class="line">        <span class="keyword">if</span> (offset &lt; page-&gt;offset)</span><br><span class="line">            n = n-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (offset &gt; page-&gt;offset)</span><br><span class="line">            n = n-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> page;  <span class="comment">// 命中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 未命中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入实现">插入实现</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">rb_insert_page_cache</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">unsigned</span> <span class="type">long</span> offset, </span></span><br><span class="line"><span class="params">                                  <span class="keyword">struct</span> rb_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> =</span> &amp;inode-&gt;i_rb_page_cache.rb_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 查找插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> rb_entry(parent, <span class="keyword">struct</span> page, rb_page_cache);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (offset &lt; page-&gt;offset)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (offset &gt; page-&gt;offset)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> page;  <span class="comment">// 已存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行插入</span></span><br><span class="line">    rb_link_node(node, parent, p);      <span class="comment">// 链接新节点</span></span><br><span class="line">    rb_insert_color(node, &amp;inode-&gt;i_rb_page_cache);  <span class="comment">// 重平衡</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 插入成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="xarray对比说明">XArray对比说明</h3>
<h4 id="适用场景差异">适用场景差异</h4>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 34%" />
<col style="width: 26%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr>
<th><strong>数据结构</strong></th>
<th><strong>最佳场景</strong></th>
<th><strong>内核应用实例</strong></th>
<th><strong>XArray替代性</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>红黑树</td>
<td>范围查询/有序遍历</td>
<td>进程调度CFS</td>
<td>❌ 不可替代</td>
</tr>
<tr>
<td>XArray</td>
<td>稀疏ID映射/快速点查</td>
<td>页缓存/文件描述符</td>
<td>✅ 专精领域</td>
</tr>
</tbody>
</table>
<h4 id="性能对比">性能对比</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">操作        红黑树        XArray</span><br><span class="line">---------------------------------</span><br><span class="line">插入        O(log n)      O(k)  // k=键长</span><br><span class="line">范围查询     O(log n + m)  O(m)  // m=结果数</span><br><span class="line">内存开销     40字节/节点   8字节/条目</span><br></pre></td></tr></table></figure>
<h4 id="xarray替代红黑树的条件">XArray替代红黑树的条件</h4>
<ol type="1">
<li><strong>键为整数类型</strong>（非复杂比较键）</li>
<li><strong>无需有序遍历</strong></li>
<li><strong>超高并发需求</strong>（XArray内置RCU） <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XArray实现类似功能</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">xa_store</span><span class="params">(<span class="keyword">struct</span> xarray *xa, <span class="type">unsigned</span> <span class="type">long</span> index, <span class="type">void</span> *entry)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">xa_load</span><span class="params">(<span class="keyword">struct</span> xarray *xa, <span class="type">unsigned</span> <span class="type">long</span> index)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr />
<h3 id="关键结论">关键结论</h3>
<ol type="1">
<li><strong>红黑树适用场景</strong>：
<ul>
<li>VFS目录树（<code>dentry</code>缓存）</li>
<li>进程调度器（CFS运行队列）</li>
<li>EPoll事件管理</li>
</ul></li>
<li><strong>XArray优先场景</strong>：
<ul>
<li>文件页缓存（<code>address_space</code>）</li>
<li>内存反向映射</li>
<li>UID到指针映射</li>
</ul></li>
</ol>
<blockquote>
<p><strong>迁移建议</strong>：新代码中整数键映射优先采用XArray；复杂键/范围查询仍需红黑树。<br />
<strong>性能数据</strong>：XArray在ext4文件系统中减少40%缓存操作耗时（内核5.15测试）</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/11/kamacode35stock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/11/kamacode35stock/" class="post-title-link" itemprop="url">代码随想录 | 刷题-动态规划8</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-12 00:46:58" itemprop="dateCreated datePublished" datetime="2025-08-12T00:46:58+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-20 01:04:30" itemprop="dateModified" datetime="2025-08-20T01:04:30+08:00">2025-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="买卖股票的最佳时机">121. 买卖股票的最佳时机</h3>
<p>贪心方法：取最左最小值，取最右最大值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;prices.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((prices[j] - prices[i])&gt;profit)profit = prices[j] - prices[i];</span><br><span class="line">            <span class="keyword">if</span>(prices[j] &lt; prices[i])i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
动态规划方法：每天保存两个数值 - 当天持有股票的最大值 -
第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金
即：dp[i - 1][0] -
第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i] -
当天不持有股票的最大值 -
第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金
即：dp[i - 1][1] -
第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] +
dp[i - 1][0]</p>
<h3 id="买卖股票的最佳时机ii">122.买卖股票的最佳时机II</h3>
<p>尝试一下动态规划方法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printdp</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i: dp)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j: i)&#123;</span><br><span class="line">                cout&lt;&lt;j&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// printdp(dp);</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i], dp[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printdp(dp);</span></span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="买卖股票的最佳时机iii">123.买卖股票的最佳时机III</h3>
<p>为什么“选择两个最大的上升区间”这种解决方式不正确：
由于交易次数限制，并不是所有上升区间都需要被单独考虑。有时一笔交易可能覆盖多个上升区间</p>
<p>本题建议使用动态规划，推导四个状态： - 第一次持有股票 -
第一次不持有股票 - 第二次持有股票 - 第二次不持有股票 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i], dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i], dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i], dp[i<span class="number">-1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">3</span>]+prices[i], dp[i<span class="number">-1</span>][<span class="number">4</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/08/oper_sys17%E6%98%A0%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/08/oper_sys17%E6%98%A0%E5%B0%84/" class="post-title-link" itemprop="url">操作系统基础 | 4.3 内核数据结构-映射</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-09 02:01:45" itemprop="dateCreated datePublished" datetime="2025-08-09T02:01:45+08:00">2025-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-11 00:18:43" itemprop="dateModified" datetime="2025-08-11T00:18:43+08:00">2025-08-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="映射maps">映射（Maps）</h3>
<h4 id="基本概念">基本概念</h4>
<p>映射（又称关联数组）是由唯一键组成的集合，每个键关联一个特定值。键与值的关系称为<strong>映射关系</strong>，支持以下基本操作：<br />
- <strong>添加</strong>（Add）：插入键值对<br />
- <strong>移除</strong>（Remove）：删除指定键<br />
- <strong>查找</strong>（Lookup）：通过键获取值</p>
<p>尽管哈希表是一种映射实现，但并非所有映射都基于哈希。映射也可使用<strong>自平衡二叉搜索树</strong>存储数据：<br />
-
<strong>哈希表</strong>：平均时间复杂度更优（O(1)），但最坏情况为线性（O(n)）<br />
- <strong>二叉搜索树</strong>：最坏情况为对数复杂度（O(log
n)），且支持有序遍历，无需哈希函数（仅需定义比较操作符）</p>
<p>在Linux内核中，映射的特定实现称为<code>idr</code>（ID Radix
Tree-旧版实现，现为XArray），专用于将唯一ID（UID）映射到指针。</p>
<hr />
<h4 id="初始化idr">初始化idr</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/idr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">id_huh</span>;</span>       <span class="comment">// 静态定义  </span></span><br><span class="line">idr_init(&amp;id_huh);      <span class="comment">// 初始化  </span></span><br></pre></td></tr></table></figure>
<hr />
<h4 id="分配uid">分配UID</h4>
<h5 id="预分配资源">1. 预分配资源</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">idr_pre_get</span><span class="params">(<span class="keyword">struct</span> idr *idp, <span class="type">gfp_t</span> gfp_mask)</span>;  </span><br><span class="line">```  </span><br><span class="line">- **功能**：必要时调整底层树结构，准备分配新UID  </span><br><span class="line">- **参数**：  </span><br><span class="line">  - `idp`：目标idr结构  </span><br><span class="line">  - `gfp_mask`：内存分配标志（如`GFP_KERNEL`）  </span><br><span class="line">- **返回值**：成功返回<span class="number">1</span>，失败返回<span class="number">0</span>（与其他内核函数相反！）  </span><br><span class="line"></span><br><span class="line">##### <span class="number">2.</span> 分配UID并关联指针  </span><br><span class="line">```c</span><br><span class="line"><span class="type">int</span> <span class="title function_">idr_get_new</span><span class="params">(<span class="keyword">struct</span> idr *idp, <span class="type">void</span> *ptr, <span class="type">int</span> *id)</span>;  </span><br><span class="line">```  </span><br><span class="line">- **功能**：分配新UID，将其与`ptr`关联  </span><br><span class="line">- **返回值**：  </span><br><span class="line">  - 成功：返回<span class="number">0</span>，UID存储在`id`中  </span><br><span class="line">  - 失败：返回`-EAGAIN`（需重试`idr_pre_get`）或`-ENOSPC`（idr已满）  </span><br><span class="line"></span><br><span class="line">##### 示例：分配UID  </span><br><span class="line">```c</span><br><span class="line"><span class="type">int</span> id, ret;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!idr_pre_get(&amp;id_huh, GFP_KERNEL)) </span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">    ret = idr_get_new(&amp;id_huh, ptr, &amp;id); </span><br><span class="line">&#125; <span class="keyword">while</span> (ret == -EAGAIN);</span><br></pre></td></tr></table></figure>
<h5 id="分配指定最小uid">分配指定最小UID</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">idr_get_new_above</span><span class="params">(<span class="keyword">struct</span> idr *idp, <span class="type">void</span> *ptr, <span class="type">int</span> starting_id, <span class="type">int</span> *id)</span>;  </span><br><span class="line">```  </span><br><span class="line">- **功能**：分配不小于`starting_id`的UID，确保UID单调递增  </span><br><span class="line">```c</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> next_id = <span class="number">1</span>;  <span class="comment">// 全局计数器</span></span><br><span class="line"><span class="keyword">if</span> (!idr_get_new_above(&amp;id_huh, ptr, next_id, &amp;id))</span><br><span class="line">    next_id = id + <span class="number">1</span>;    <span class="comment">// 更新下一个起始ID  </span></span><br></pre></td></tr></table></figure>
<h5 id="xarray方式-linux-4.2以后">XArray方式 (Linux 4.2以后)</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 原子分配 (无需预分配) */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">xa_alloc</span><span class="params">(<span class="keyword">struct</span> xarray *xa, <span class="type">unsigned</span> <span class="type">int</span> *id, </span></span><br><span class="line"><span class="params">             <span class="type">void</span> *entry, <span class="keyword">struct</span> xa_limit limit, <span class="type">gfp_t</span> gfp)</span>;</span><br><span class="line"><span class="comment">/* 分配递增ID示例 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> next_id = <span class="number">1</span>;</span><br><span class="line">xa_alloc(&amp;xa_huh, &amp;next_id, ptr, XA_LIMIT(next_id, UINT_MAX), GFP_KERNEL);</span><br><span class="line"><span class="comment">// 成功后 next_id 自动递增</span></span><br></pre></td></tr></table></figure>
<hr />
<h4 id="查找与删除">查找与删除</h4>
<h5 id="查找uid">查找UID</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">idr_find</span><span class="params">(<span class="keyword">struct</span> idr *idp, <span class="type">int</span> id)</span>;  </span><br><span class="line">```  </span><br><span class="line">- **返回值**：成功返回关联指针，失败返回`<span class="literal">NULL</span>`  </span><br><span class="line">- **注意**：在分配UID时，禁止将`<span class="literal">NULL</span>`作为有效idr值映射，否则无法区分查找失败与有效`<span class="literal">NULL</span>`  </span><br><span class="line"></span><br><span class="line">##### 移除UID  </span><br><span class="line">```c</span><br><span class="line"><span class="type">void</span> <span class="title function_">idr_remove</span><span class="params">(<span class="keyword">struct</span> idr *idp, <span class="type">int</span> id)</span>;  </span><br><span class="line">```  </span><br><span class="line">- **注意**：无错误返回值，需调用者确保UID存在  </span><br><span class="line"></span><br><span class="line">##### XArray方式</span><br><span class="line">```c</span><br><span class="line"><span class="comment">/* 查找 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">xa_load</span><span class="params">(<span class="keyword">struct</span> xarray *xa, <span class="type">unsigned</span> <span class="type">long</span> index)</span>;</span><br><span class="line"><span class="comment">/* 删除并返回删除项 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">xa_erase</span><span class="params">(<span class="keyword">struct</span> xarray *xa, <span class="type">unsigned</span> <span class="type">long</span> index)</span>;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="销毁">销毁</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">idr_destroy</span><span class="params">(<span class="keyword">struct</span> idr *idp)</span>;                  <span class="comment">// 释放未使用内存  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">idr_remove_all</span><span class="params">(<span class="keyword">struct</span> idr *idp)</span>;               <span class="comment">// 强制移除所有UID  </span></span><br><span class="line">```  </span><br><span class="line">**典型流程**：  </span><br><span class="line">```c</span><br><span class="line"><span class="title function_">idr_remove_all</span><span class="params">(&amp;id_huh)</span>;  <span class="comment">// 先清空所有映射  </span></span><br><span class="line">idr_destroy(&amp;id_huh);     <span class="comment">// 再释放内存，确保所有idr内存被释放  </span></span><br><span class="line">kfree(user_data_ptr);  <span class="comment">// 释放实际业务数据</span></span><br></pre></td></tr></table></figure>
<h5 id="xarray方式">XArray方式</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 销毁并释放所有资源 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">xa_destroy</span><span class="params">(<span class="keyword">struct</span> xarray *xa)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 安全销毁流程示例 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="type">void</span> *entry;</span><br><span class="line">    <span class="comment">// 遍历释放关联资源</span></span><br><span class="line">    xa_for_each(&amp;xa_huh, id, entry) &#123;</span><br><span class="line">        xa_erase(&amp;xa_huh, id);</span><br><span class="line">        kfree(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    xa_destroy(&amp;xa_huh); <span class="comment">// 释放XArray管理内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="关键注意事项">关键注意事项</h4>
<ol type="1">
<li><strong>并发控制</strong>：
<ul>
<li><code>idr_pre_get</code>无需加锁<br />
</li>
<li><code>idr_get_new</code>等操作需自旋锁保护（参见第9/10章）</li>
</ul></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/07/oper_sys16%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/07/oper_sys16%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">操作系统基础 | 4.2 内核数据结构-队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-08 00:28:10" itemprop="dateCreated datePublished" datetime="2025-08-08T00:28:10+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-09 00:28:09" itemprop="dateModified" datetime="2025-08-09T00:28:09+08:00">2025-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="队列">队列</h3>
<p>任何操作系统内核中常见的编程模式是<strong>生产者与消费者</strong>。实现此模式的最简单方式通常是使用队列，即<strong>先进先出</strong>（FIFO）。</p>
<p>Linux内核的通用队列实现称为<code>kfifo</code>，代码位于<code>kernel/kfifo.c</code>，头文件为<code>&lt;linux/kfifo.h&gt;</code>。本节讨论2.6.33版本更新后的API（早期版本用法略有不同，编写代码前请确认头文件）。</p>
<hr />
<h4 id="kfifo">kfifo</h4>
<p>Linux的<code>kfifo</code>与其他队列抽象类似，提供两个核心操作：<br />
- <strong>入队</strong>（<code>in</code>）：将数据写入队列<br />
- <strong>出队</strong>（<code>out</code>）：从队列中读取数据</p>
<p><code>kfifo</code>对象维护两个偏移量：<br />
- <strong>in偏移量</strong>：下一次入队的起始位置<br />
- <strong>out偏移量</strong>：下一次出队的起始位置</p>
<p><strong>规则</strong>：<br />
1.
<code>out</code>偏移量始终≤<code>in</code>偏移量（否则会读取未入队的数据）。<br />
2. 当<code>out == in</code>时，队列为空（无法出队）。<br />
3. 当<code>in</code>到达队列末尾时，需重置队列才能继续入队。</p>
<hr />
<h4 id="创建队列">创建队列</h4>
<h5 id="动态初始化常用">动态初始化（常用）</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kfifo_alloc</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">gfp_t</span> gfp_mask)</span>;</span><br><span class="line">```  </span><br><span class="line">- **功能**：分配大小为`size`字节的队列（`size`必须为<span class="number">2</span>的幂次），内存分配标志为`gfp_mask`（参见第<span class="number">12</span>章“内存管理”）。  </span><br><span class="line">- **返回值**：成功返回`<span class="number">0</span>`，失败返回错误码。  </span><br><span class="line">- **示例**：  </span><br><span class="line">  ```c</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> <span class="title">fifo</span>;</span></span><br><span class="line">  <span class="type">int</span> ret = kfifo_alloc(&amp;fifo, PAGE_SIZE, GFP_KERNEL);</span><br><span class="line">  <span class="keyword">if</span> (ret)</span><br><span class="line">      <span class="keyword">return</span> ret; <span class="comment">// 初始化失败</span></span><br></pre></td></tr></table></figure>
<h5 id="自定义缓冲区">自定义缓冲区</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfifo_init</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo, <span class="type">void</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br><span class="line">```  </span><br><span class="line">- **功能**：使用用户提供的`buffer`初始化队列，`size`必须为<span class="number">2</span>的幂次。  </span><br><span class="line"></span><br><span class="line">##### 静态声明（较少用）  </span><br><span class="line">```c</span><br><span class="line"><span class="title function_">DECLARE_KFIFO</span><span class="params">(name, size)</span>;  <span class="comment">// 声明队列</span></span><br><span class="line">INIT_KFIFO(name);           <span class="comment">// 初始化队列</span></span><br><span class="line">```  </span><br><span class="line">- **要求**：`size`必须为<span class="number">2</span>的幂次。  </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 数据入队  </span><br><span class="line">```c</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_in</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br><span class="line">```  </span><br><span class="line">- **功能**：从`from`复制`len`字节到队列`fifo`。  </span><br><span class="line">- **返回值**：实际入队的字节数（若空间不足，可能小于`len`）。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 数据出队  </span><br><span class="line">##### 标准出队  </span><br><span class="line">```c</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_out</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo, <span class="type">void</span> *to, <span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br><span class="line">```  </span><br><span class="line">- **功能**：从队列`fifo`复制最多`len`字节到`to`缓冲区。  </span><br><span class="line">- **返回值**：实际出队的字节数。  </span><br><span class="line">- **注意**：出队后数据不再保留在队列中。  </span><br><span class="line"></span><br><span class="line">##### 查看数据（不删除）  </span><br><span class="line">```c</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_out_peek</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo, <span class="type">void</span> *to, <span class="type">unsigned</span> <span class="type">int</span> len, <span class="type">unsigned</span> offset)</span>;</span><br><span class="line">```  </span><br><span class="line">- **功能**：与`kfifo_out`类似，但**不移动out偏移量**，数据仍可后续读取。  </span><br><span class="line">- **参数**：`offset`指定队列中的起始位置（<span class="number">0</span>表示队头）。  </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 获取队列信息</span><br><span class="line"><span class="number">1.</span> **获取队列总容量**</span><br><span class="line">```c</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_size</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回队列底层缓冲区的总字节数</li>
</ul>
<ol start="2" type="1">
<li><strong>获取已入队数据量</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_len</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>返回当前队列中已存储的字节数</li>
<li>（注：内核命名存在不一致性，需特别注意）</li>
</ul>
<ol start="3" type="1">
<li><strong>获取剩余空间</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_avail</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>返回可继续写入的剩余字节数</li>
</ul>
<ol start="4" type="1">
<li><strong>队列状态检查</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">kfifo_is_empty</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">kfifo_is_full</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>返回非零值表示队列为空/满</li>
<li>返回零表示非空/非满</li>
</ul>
<h4 id="重置与销毁队列">重置与销毁队列</h4>
<ol type="1">
<li><strong>重置队列</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">kfifo_reset</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>清空队列所有内容（不释放内存）</li>
</ul>
<ol start="2" type="1">
<li><strong>销毁动态分配的队列</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfifo_free</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>释放通过<code>kfifo_alloc()</code>创建的队列</li>
<li>注意：使用<code>kfifo_init()</code>创建的队列需手动释放关联缓冲区</li>
</ul>
<h4 id="实际应用示例">实际应用示例</h4>
<p>创建8KB大小的kfifo队列： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kfifo.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> <span class="title">my_fifo</span>;</span>  <span class="comment">// 声明 kfifo 结构体</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="comment">// 分配 8KB 队列</span></span><br><span class="line">ret = kfifo_alloc(&amp;my_fifo, <span class="number">8192</span>, GFP_KERNEL);  <span class="comment">// 8192 = 8 * 1024</span></span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    pr_err(<span class="string">&quot;Failed to allocate kfifo: error %d\n&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 验证大小</span></span><br><span class="line">pr_info(<span class="string">&quot;Created FIFO size: %u bytes\n&quot;</span>, kfifo_size(&amp;my_fifo));  <span class="comment">// 输出 8192</span></span><br></pre></td></tr></table></figure> &gt; 队列总容量 = 8 KB = 8 ×
1024 字节 = 8192 字节（环形缓冲区无需减一） &gt;
<code>unsigned int</code>大小 = 4
字节（也可能是8字节，可以通过<code>sizeof(unsigned int)</code>获取）
&gt; 这样一个队列最多可以容纳8192 字节 / 4 字节 = 2048
个<code>unsigned int</code></p>
<p><strong>入队操作</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 入队0-31的整数 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    kfifo_in(fifo, &amp;i, <span class="keyword">sizeof</span>(i));</span><br></pre></td></tr></table></figure></p>
<p><strong>查看队首元素（不移除）</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line"><span class="type">int</span> ret = kfifo_out_peek(fifo, &amp;val, <span class="keyword">sizeof</span>(val), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="keyword">sizeof</span>(val))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">printk(KERN_INFO <span class="string">&quot;%u\n&quot;</span>, val); <span class="comment">/* 输出: 0 */</span></span><br></pre></td></tr></table></figure></p>
<p><strong>完整出队操作</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (kfifo_avail(fifo)) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> ret = kfifo_out(fifo, &amp;val, <span class="keyword">sizeof</span>(val));</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="keyword">sizeof</span>(val))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;%u\n&quot;</span>, val); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出: 0 1 2 ... 31 (严格保持FIFO顺序) */</span></span><br></pre></td></tr></table></figure> -
输出顺序为0→31证明是标准的FIFO队列 - 若输出为31→0则变为栈结构（LIFO） -
所有操作均保持原子性，适合生产者-消费者场景
（注：实际开发中通常入队复杂结构体而非基础类型）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/06/oper_sys15%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/06/oper_sys15%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">操作系统基础 | 4.1 内核数据结构-链表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-07 00:30:09" itemprop="dateCreated datePublished" datetime="2025-08-07T00:30:09+08:00">2025-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-08 00:27:55" itemprop="dateModified" datetime="2025-08-08T00:27:55+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="链表linked-lists">链表（Linked Lists）</h3>
<h4 id="单链表与双链表">单链表与双链表</h4>
<ul>
<li><strong>单链表</strong>：每个节点只包含指向下一个节点的指针。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *data;                   <span class="comment">// 数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> *<span class="title">next</span>;</span>    <span class="comment">// 指向下一个节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>双链表</strong>：每个节点包含指向前一个和后一个节点的指针。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *data;                   <span class="comment">// 数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> *<span class="title">next</span>;</span>    <span class="comment">// 指向下一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> *<span class="title">prev</span>;</span>    <span class="comment">// 指向前一个节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="循环链表circular-linked-lists">循环链表（Circular Linked
Lists）</h4>
<ul>
<li>普通链表的最后一个节点的 next 指针通常指向 NULL，表示结束。</li>
<li>循环链表的最后一个节点的 next
指针指向第一个节点，形成环状结构。循环链表可以是单向或双向的。</li>
<li>Linux 内核的链表实现本质上是循环双链表，灵活性最高。</li>
</ul>
<h4 id="链表的遍历">链表的遍历</h4>
<ul>
<li>链表的遍历是线性的：从头节点开始，依次通过 next
指针访问每个节点。</li>
<li>非循环链表的最后一个节点 next 为 NULL；循环链表的最后一个节点 next
指向头节点。</li>
<li>双链表可以支持从尾节点向前遍历。</li>
<li>链表适合需要频繁插入、删除和遍历全部元素的场景，不适合随机访问。</li>
</ul>
<h3 id="linux-内核链表实现方式">Linux 内核链表实现方式</h3>
<h4 id="与传统链表的区别">1. 与传统链表的区别</h4>
<ul>
<li>传统链表通常是在数据结构里直接加 <code>next</code> 和
<code>prev</code> 指针，把结构本身变成链表节点。</li>
<li>Linux
内核采用<strong>嵌入链表节点</strong>的方式：在自定义结构体里嵌入一个
<code>struct list_head</code> 成员，而不是直接用
<code>next</code>/<code>prev</code> 指针。</li>
</ul>
<h4 id="内核链表节点结构">2. 内核链表节点结构</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>只包含指向前后节点的指针，不存储数据。</li>
</ul>
<h4 id="如何使用">3. 如何使用</h4>
<ul>
<li>在你的结构体里嵌入 <code>struct list_head</code> 成员，例如：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fox</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tail_length;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> weight;</span><br><span class="line">    <span class="type">bool</span> is_fantastic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">// 链表节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这样，<code>fox.list.next</code> 指向下一个
fox，<code>fox.list.prev</code> 指向上一个 fox。</li>
</ul>
<h4 id="链表操作">4. 链表操作</h4>
<ul>
<li>内核提供了丰富的链表操作函数（如
<code>list_add()</code>），这些函数只操作
<code>list_head</code>，不关心具体数据类型。</li>
<li>通过 <code>container_of</code> 宏，可以从 <code>list_head</code>
指针反查到包含它的结构体： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    ((type *)((char *)(ptr) - offsetof(type, member)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br></pre></td></tr></table></figure></li>
<li>用 <code>list_entry()</code>
可以从链表节点指针获取到完整的结构体数据。</li>
</ul>
<h4 id="链表初始化">5. 链表初始化</h4>
<ul>
<li>动态分配结构体后，用 <code>INIT_LIST_HEAD(&amp;obj-&gt;list)</code>
在运行时初始化链表节点。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fox</span> *red_fox; </span><br><span class="line">red_fox = <span class="built_in">kmalloc</span>(<span class="built_in">sizeof</span>(*red_fox), GFP_KERNEL); </span><br><span class="line">red_fox-&gt;tail_length = <span class="number">40</span>; </span><br><span class="line">red_fox-&gt;weight = <span class="number">6</span>; </span><br><span class="line">red_fox-&gt;is_fantastic = <span class="literal">false</span>; </span><br><span class="line"><span class="built_in">INIT_LIST_HEAD</span>(&amp;red_fox-&gt;list);</span><br></pre></td></tr></table></figure></li>
<li>静态定义时可用 <code>LIST_HEAD_INIT()</code> 宏在编译时初始化。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fox</span> red_fox = &#123; </span><br><span class="line">   .tail_length = <span class="number">40</span>, </span><br><span class="line">   .weight = <span class="number">6</span>, </span><br><span class="line">   .list  = <span class="built_in">LIST_HEAD_INIT</span>(red_fox.list),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="链表头">6. 链表头</h4>
<ul>
<li>通常会定义一个专门的 <code>list_head</code>
变量作为链表头，用于管理整个链表： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(fox_list)</span>;</span><br></pre></td></tr></table></figure></li>
<li>这个链表头本质上也是一个 <code>list_head</code>
节点，但不存储实际数据，只作为入口。</li>
</ul>
<h3 id="linux-内核链表的操作方法">Linux 内核链表的操作方法</h3>
<ol type="1">
<li><p><strong>所有链表操作函数都只操作 <code>struct list_head</code>
指针，和具体数据类型无关。</strong></p>
<ul>
<li>这些函数都定义在
<code>&lt;linux/list.h&gt;</code>，实现为内联函数，效率高。</li>
<li>所有操作都是 O(1)
常数时间，无论链表长度如何，插入、删除等操作速度都一样。</li>
</ul></li>
<li><p><strong>常用操作函数：</strong></p>
<ul>
<li><strong>添加节点</strong>（底层的循环链表特性，每一个节点都可以填入head）
<ul>
<li><code>list_add(new, head)</code>：把新节点插入到 head
节点之后（将最后一个节点填入head，实现栈）。</li>
<li><code>list_add_tail(new, head)</code>：把新节点插入到 head
节点之前（将第一个节点填入head，实现队列）。</li>
</ul></li>
<li><strong>删除节点</strong>
<ul>
<li><code>list_del(entry)</code>：把 entry
节点从链表中移除，但不释放内存。</li>
<li><code>list_del_init(entry)</code>：移除节点并重新初始化它，方便后续复用。</li>
</ul></li>
<li><strong>移动节点</strong>
<ul>
<li><code>list_move(list, head)</code>：把节点 list 移到 head
节点之后。</li>
<li><code>list_move_tail(list, head)</code>：把节点 list 移到 head
节点之前。</li>
</ul></li>
<li><strong>拼接链表</strong>
<ul>
<li><code>list_splice(list, head)</code>：把 list 指向的链表拼接到 head
节点之后。</li>
<li><code>list_splice_init(list, head)</code>：拼接后把原链表重新初始化。</li>
</ul></li>
<li><strong>判断链表是否为空</strong>
<ul>
<li><code>list_empty(head)</code>：判断链表是否为空，返回非零表示空。</li>
</ul></li>
</ul></li>
<li><p><strong>内部函数优化</strong></p>
<ul>
<li>如果你已经有了节点的 next 和 prev 指针，可以直接调用内部函数（如
<code>__list_del(prev, next)</code>），省去多余的指针解引用。</li>
<li>这些内部函数一般以双下划线 <code>__</code>
开头，只有在你已经拿到指针时才建议用。</li>
</ul></li>
</ol>
<h3 id="linux-内核链表的遍历">Linux 内核链表的遍历</h3>
<p>完整遍历包含n个节点的链表是O(n)时间复杂度操作。</p>
<h4 id="基础遍历方法">基础遍历方法</h4>
<p>最基础的遍历宏是<code>list_for_each()</code>，接收两个<code>list_head</code>参数：
-
<strong>第一个参数</strong>：指向当前项的指针（需调用者提供的临时变量）
- <strong>第二个参数</strong>：要遍历的链表头节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line">list_for_each(p, fox_list) &#123;</span><br><span class="line">    <span class="comment">/* p指向链表中的某个节点 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但仅获取<code>list_head</code>指针通常无用，我们需要的是包含该链表节点的结构体（前文已讨论）指针。此时应使用<code>list_entry()</code>宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fox</span> *<span class="title">f</span>;</span></span><br><span class="line">list_for_each(p, &amp;fox_list) &#123;</span><br><span class="line">    f = list_entry(p, <span class="keyword">struct</span> fox, <span class="built_in">list</span>); <span class="comment">// 获取包含list_head的fox结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实用遍历方法">实用遍历方法</h4>
<p>上述方法不够直观，因此内核主要使用<code>list_for_each_entry()</code>宏，该宏自动完成<code>list_entry()</code>转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry(pos, head, member)</span><br></pre></td></tr></table></figure>
<p>参数说明： -
<code>pos</code>：包含<code>list_head</code>的结构体指针（相当于<code>list_entry()</code>返回值）
- <code>head</code>：链表头节点指针（如<code>fox_list</code>） -
<code>member</code>：<code>list_head</code>在结构体中的成员名（如<code>list</code>）</p>
<p>示例： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fox</span> *<span class="title">f</span>;</span></span><br><span class="line">list_for_each_entry(f, &amp;fox_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">    <span class="comment">/* 每次迭代f指向下一个fox结构体 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>实际案例</strong>（来自内核文件系统通知系统inotify）：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inotify_watch *<span class="title function_">inode_find_handle</span><span class="params">(<span class="keyword">struct</span> inode *inode, </span></span><br><span class="line"><span class="params">                                              <span class="keyword">struct</span> inotify_handle *ih)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inotify_watch</span> *<span class="title">watch</span>;</span></span><br><span class="line">    list_for_each_entry(watch, &amp;inode-&gt;inotify_watches, i_list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (watch-&gt;ih == ih)</span><br><span class="line">            <span class="keyword">return</span> watch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此函数遍历<code>inode-&gt;inotify_watches</code>链表，查找匹配<code>inotify_handle</code>的节点。</p>
<h4 id="反向遍历">反向遍历</h4>
<p><code>list_for_each_entry_reverse()</code>功能与正向遍历相同，但沿<code>prev</code>指针逆向移动：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry_reverse(pos, head, member)</span><br></pre></td></tr></table></figure> 适用场景： 1. 性能优化：当目标节点更靠近链表尾部时 2.
顺序要求：如实现LIFO栈操作 若无特殊需求，建议使用正向遍历。</p>
<h4 id="安全删除遍历">安全删除遍历</h4>
<p>标准遍历方法在迭代过程中删除节点会导致问题（后续迭代无法获取正确的next/prev指针）。内核提供安全版本：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry_safe(pos, next, head, member)</span><br></pre></td></tr></table></figure>
参数<code>next</code>用于临时存储下一节点指针，确保当前节点可安全删除。</p>
<p><strong>inotify示例</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inotify_inode_is_dead</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inotify_watch</span> *<span class="title">watch</span>, *<span class="title">next</span>;</span></span><br><span class="line">    mutex_lock(&amp;inode-&gt;inotify_mutex);</span><br><span class="line">    list_for_each_entry_safe(watch, next, &amp;inode-&gt;inotify_watches, i_list) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inotify_handle</span> *<span class="title">ih</span> =</span> watch-&gt;ih;</span><br><span class="line">        mutex_lock(&amp;ih-&gt;mutex);</span><br><span class="line">        inotify_remove_watch_locked(ih, watch); <span class="comment">// 删除watch节点</span></span><br><span class="line">        mutex_unlock(&amp;ih-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;inode-&gt;inotify_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逆向安全遍历版本： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry_safe_reverse(pos, n, head, member)</span><br></pre></td></tr></table></figure></p>
<h4 id="注意事项">注意事项</h4>
<ol type="1">
<li>"safe"宏仅防护循环体内的删除操作，若存在并发操作仍需加锁</li>
<li>更多链表操作方法详见<code>&lt;linux/list.h&gt;</code></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
  <div class="languages">
    <label class="lang-select-label">
      <i class="fa fa-language"></i>
      <span>简体中文</span>
      <i class="fa fa-angle-up" aria-hidden="true"></i>
    </label>
    <select class="lang-select" data-canonical="" aria-label="选择语言">
      
        <option value="zh-CN" data-href="/page/3/index.html" selected="">
          简体中文
        </option>
      
        <option value="en" data-href="/en/page/3/index.html" selected="">
          English
        </option>
      
    </select>
  </div>

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Mackz-Maxw</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
