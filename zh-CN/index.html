<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mackz-maxw.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="乘上燃犀船，还未曾去过倒悬山。">
<meta property="og:type" content="website">
<meta property="og:title" content="Maxw的小站">
<meta property="og:url" content="https://mackz-maxw.github.io/zh-CN/index.html">
<meta property="og:site_name" content="Maxw的小站">
<meta property="og:description" content="乘上燃犀船，还未曾去过倒悬山。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mackz-Maxw">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://mackz-maxw.github.io/zh-CN/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"zh-CN/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Maxw的小站</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Maxw的小站" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Maxw的小站</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Maxw学习记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Mackz-Maxw</p>
  <div class="site-description" itemprop="description">乘上燃犀船，还未曾去过倒悬山。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">92</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/mackz-maxw" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mackz-maxw" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/27/oper_sys24fork/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/27/oper_sys24fork/" class="post-title-link" itemprop="url">操作系统基础 | 5.3 信号；fork</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-28 09:15:23 / 修改时间：09:17:07" itemprop="dateCreated datePublished" datetime="2025-08-28T09:15:23+08:00">2025-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="信号的概念">信号的概念</h3>
<p>信号（Signal）是通知进程已发生某种事件的一种机制。信号有时被描述为<strong>软件中断</strong>（software
interrupts）。信号与硬件中断类似，因为它们会中断程序的正常执行流程；在大多数情况下，无法精确预测信号何时到达。一个进程（如果它具有适当的权限）可以向另一个进程发送信号。这种用途下，信号可以作为一种同步技术，甚至作为一种原始的<strong>进程间通信（IPC）</strong>
形式。进程也可以向自己发送信号。</p>
<p>然而，传递给进程的许多信号的通常来源是<strong>内核</strong>（kernel）。导致内核为进程生成信号的事件类型包括：</p>
<ul>
<li><strong>发生硬件异常</strong>：这意味着硬件检测到故障条件并通知内核，内核随后向相关进程发送相应的信号。硬件异常的例子包括：执行格式错误的机器语言指令、除以0、或引用了无法访问的内存区域。</li>
<li><strong>用户键入了能生成信号的终端特殊字符</strong>。这些字符包括中断字符（通常是
<code>Control-C</code>）和挂起字符（通常是
<code>Control-Z</code>）。</li>
<li><strong>发生软件事件</strong>。例如：文件描述符上有输入可用、终端窗口大小改变、定时器超时、进程的CPU时间限制已超过、或该进程的一个子进程终止。</li>
</ul>
<p>每个信号都被定义为一个唯一的（小）整数，从1开始顺序编号。这些整数在
<code>&lt;signal.h&gt;</code> 头文件中用 <code>SIGxxxx</code>
形式的符号名定义。由于每个信号使用的实际数字因实现而异，因此在程序中总是使用这些符号名称。例如，当用户键入中断字符时，<code>SIGINT</code>（信号编号2）被传递给进程。</p>
<p>信号分为两大类。第一组构成了<strong>传统或标准信号</strong>（standard
signals），内核使用它们来通知进程事件。在Linux上，标准信号编号从1到31。本章我们描述标准信号。另一组信号由<strong>实时信号</strong>（realtime
signals）组成，其与标准信号的区别将在第22.8节描述。</p>
<p>信号被认为是<strong>由某个事件产生</strong>（generated）。一旦产生，信号随后会被<strong>递送</strong>（delivered）给一个进程，该进程随后会采取某些<strong>动作</strong>（action）来响应信号。在信号产生和递送之间的时间段，信号被称为<strong>处于等待状态</strong>（pending）。通常，一个等待中的信号会在进程下一次被调度运行时立即递送，如果进程已经在运行则立即递送（例如，进程向自己发送信号）。</p>
<p>然而，有时我们需要确保一段代码不会因信号的递送而中断。为此，我们可以将一个信号添加到进程的<strong>信号掩码</strong>（signal
mask）中——这是一组当前<strong>被阻塞</strong>（blocked）递送的信号。如果一个信号在阻塞状态下产生，它将保持等待状态，直到后来被<strong>解除阻塞</strong>（unblocked）（从信号掩码中移除）。各种系统调用允许进程向其信号掩码中添加和移除信号。</p>
<p>根据信号的不同，信号被递送时，进程会执行以下<strong>默认动作</strong>（default
actions）之一：</p>
<ul>
<li><strong>忽略信号</strong>（Ignored）：即信号被内核丢弃，对进程没有影响。（进程甚至不知道它发生了。）</li>
<li><strong>进程被终止</strong>（Terminated）（杀死）。这有时被称为异常进程终止，与进程使用
<code>exit()</code> 终止的正常进程终止相对。</li>
<li><strong>生成核心转储文件</strong>（Core dump
file）且进程被终止。核心转储文件包含进程虚拟内存的一个映像，可以将其加载到调试器中，以检查进程终止时的状态。</li>
<li><strong>进程被停止</strong>（Stopped）——进程的执行被暂停。</li>
<li><strong>进程被恢复</strong>（Resumed）执行——在之前被停止后恢复执行。</li>
</ul>
<p>程序可以改变信号递送时发生的动作，而不是接受特定信号的默认动作。这被称为设置信号的<strong>处置方式</strong>（disposition）。程序可以为信号设置以下处置方式之一：</p>
<ul>
<li>发生<strong>默认动作</strong>。这对于撤销之前将信号处置方式更改为非默认值的操作很有用。</li>
<li><strong>忽略</strong>信号。这对于那些默认动作是终止进程的信号很有用。</li>
<li>执行一个<strong>信号处理程序</strong>（signal
handler）。信号处理程序是由程序员编写的函数，它执行适当的任务以响应信号的递送。例如，shell
有一个用于 <code>SIGINT</code> 信号（由中断字符 <code>Control-C</code>
产生）的处理程序，该处理程序使其停止当前正在做的事情并将控制权返回给主输入循环，从而再次向用户显示
shell 提示符（用户按下 <code>Control-C</code>
-shell中断当前处理-用户可以再次在shell中输入指令了）。通知内核应调用某个处理函数通常被称为<strong>安装</strong>（installing）或<strong>建立</strong>（establishing）一个信号处理程序。当信号处理程序因信号递送而被调用时，我们说信号已被<strong>处理</strong>（handled）或，同义词，被<strong>捕获</strong>（caught）。
<em>注意：不可能将信号的处置方式设置为终止或转储核心（除非其中一个是该信号的默认处置方式）。最接近这一点的是为该信号安装一个处理程序，然后该处理程序调用
<code>exit()</code> 或 <code>abort()</code>。<code>abort()</code>
函数（第21.2.2节）为进程生成一个 <code>SIGABRT</code>
信号，这会导致其转储核心并终止。</em></li>
</ul>
<p>Linux特有的 <code>/proc/PID/status</code>
文件包含各种位掩码字段，可以检查这些字段以确定进程对信号的处理情况。位掩码以十六进制数显示，最低有效位代表信号1，左边下一位代表信号2，依此类推。这些字段是：
* <code>SigPnd</code>（线程内等待信号，per-thread pending signals） *
<code>ShdPnd</code>（进程范围内等待信号，process-wide pending
signals；自Linux 2.6起） * <code>SigBlk</code>（阻塞信号，blocked
signals） * <code>SigIgn</code>（忽略信号，ignored signals） *
<code>SigCgt</code>（捕获信号，caught signals）。
（当我们第33.2节描述多线程进程中的信号处理时，<code>SigPnd</code> 和
<code>ShdPnd</code> 字段之间的区别将变得清晰。）同样的信息也可以使用
<code>ps(1)</code> 命令的各种选项来获取。</p>
<h3 id="fork-exit-wait-和-execve-概述"><code>fork()</code>,
<code>exit()</code>, <code>wait()</code> 和 <code>execve()</code>
概述</h3>
<ul>
<li><p><strong><code>fork()</code></strong> <code>fork()</code>
系统调用允许一个进程（称为<strong>父进程</strong>）创建一个新的进程（称为<strong>子进程</strong>）。这是通过使新的子进程成为父进程的（近乎）完全副本来实现的：子进程获取父进程栈、数据、堆和文本段（第6.3节）的副本。“Fork”一词源于我们可以将父进程视为<strong>分裂
(forking)</strong> 以产生自身的两个副本这一构想。</p></li>
<li><p><strong><code>exit(status)</code></strong> <code>exit()</code>
库函数<strong>终止</strong>一个进程，使该进程使用的所有资源（内存、打开的文件描述符等）可供内核后续重新分配。<code>status</code>
参数是一个整数，用于确定进程的<strong>终止状态</strong>。通过
<code>wait()</code> 系统调用，父进程可以检索此状态。 <code>exit()</code>
库函数是基于 <code>_exit()</code>
系统调用构建的。在第25章，我们将解释这两个接口之间的区别。在此我们只需注意，在
<code>fork()</code>
之后，通常只有父进程和子进程中的<strong>一个</strong>通过调用
<code>exit()</code> 终止；<strong>另一个</strong>进程应使用
<code>_exit()</code> 终止。</p></li>
<li><p><strong><code>wait(&amp;status)</code></strong>
<code>wait(&amp;status)</code>
系统调用有两个目的。首先，如果该进程的某个子进程尚未调用
<code>exit()</code> 终止，那么 <code>wait()</code>
会<strong>暂停</strong>该进程的执行，直到它的一个子进程终止为止。其次，子进程的终止状态通过
<code>wait()</code> 的 <code>status</code>
参数<strong>返回</strong>。</p></li>
<li><p><strong><code>execve(pathname, argv, envp)</code></strong>
<code>execve(pathname, argv, envp)</code>
系统调用将一个新的程序（<code>pathname</code>，带有参数列表
<code>argv</code> 和环境列表
<code>envp</code>）<strong>加载</strong>到一个进程的内存中。现有的程序文本被丢弃，并为新程序<strong>全新创建</strong>栈、数据和堆段。此操作通常被称为
<strong>execing</strong> 一个新程序。后面我们会看到，有几个库函数是基于
<code>execve()</code>
构建的，每个函数都在编程接口上提供了有用的变体。当我们不关心这些接口变体时，我们遵循通用惯例，将这些调用统称为
<code>exec()</code>，但请注意，并没有叫这个名字的系统调用或库函数。</p></li>
</ul>
<p><strong>与其他系统的对比：</strong> 一些其他操作系统将
<code>fork()</code> 和 <code>exec()</code>
的功能组合到单个操作中——即所谓的
<strong>spawn</strong>——该操作创建一个新进程然后执行指定的程序。相比之下，UNIX
的方法通常更简单、更优雅。将这两个步骤分开使得 API
更简单（<code>fork()</code>
系统调用不需要参数），并且允许程序在两个步骤之间执行的操作具有极大的灵活性。此外，只进行
<code>fork()</code> 而不接着执行 <code>exec()</code> 通常也很有用。</p>
<p>SUSv3 规定了可选的 <code>posix_spawn()</code> 函数，它结合了
<code>fork()</code> 和 <code>exec()</code> 的效果。此函数以及 SUSv3
规定的几个相关 API 已在 glibc 中为 Linux 实现。SUSv3 规定
<code>posix_spawn()</code>
是为了允许为那些不提供交换设施或内存管理单元（这在许多嵌入式系统中很典型）的硬件架构编写可移植应用程序。在此类架构上，传统的
<code>fork()</code> 难以或无法实现。</p>
<p><strong>协同工作概述：</strong> <code>fork()</code>,
<code>exit()</code>, <code>wait()</code>, 和 <code>execve()</code>
通常是如何一起使用的。（shell
持续执行一个循环，该循环读取命令、对其进行各种处理，然后 fork
一个子进程来 exec 该命令。）</p>
<h3 id="创建新进程fork">创建新进程：<code>fork()</code></h3>
<p><code>fork()</code>
系统调用创建一个新的进程，即<strong>子进程</strong>，它是调用进程，即<strong>父进程</strong>的一个几乎完全相同的副本。</p>
<p>理解 <code>fork()</code>
的关键在于认识到，在它完成工作后，存在<strong>两个进程</strong>，并且在每个进程中，执行都从
<code>fork()</code>
<strong>返回的地方继续</strong>。两个进程执行相同的程序代码，但它们拥有独立的栈、数据和堆段副本。子进程的栈、数据和堆段最初是父进程内存相应部分的精确副本。在
<code>fork()</code>
之后，每个进程都可以修改其栈、数据和堆段中的变量，而<strong>不会影响另一个进程</strong>。</p>
<p>在程序代码中，我们可以通过 <code>fork()</code>
的返回值来区分这两个进程：</p>
<ul>
<li>对于<strong>父进程</strong>，<code>fork()</code>
返回新创建子进程的<strong>进程ID
(PID)</strong>。这很有用，因为父进程可能会创建多个子进程，并因此需要（通过
<code>wait()</code> 或其相关函数）跟踪它们。</li>
<li>对于<strong>子进程</strong>，<code>fork()</code> 返回
<strong>0</strong>。</li>
<li>如果无法创建新进程，<code>fork()</code> 返回
<strong>-1</strong>。失败的可能原因包括：已达到允许该（真实）用户ID创建的进程数的资源限制（<code>RLIMIT_NPROC</code>，在第36.3节描述），或者已达到系统范围内可创建进程数的上限。</li>
</ul>
<p>必要时，子进程可以使用 <code>getpid()</code> 获取自身的进程ID，使用
<code>getppid()</code> 获取其父进程的进程ID。</p>
<p>调用 <code>fork()</code> 时有时会使用以下惯用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> childPid; <span class="comment">/* 在父进程中用于记录成功 fork() 后的子进程 PID */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (childPid = fork()) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">/* fork() 失败 */</span></span><br><span class="line">    <span class="comment">/* 处理错误 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">/* 成功 fork() 后的子进程进入此处 */</span></span><br><span class="line">    <span class="comment">/* 执行子进程特定的操作 */</span></span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 或 exit()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">/* 成功 fork() 后的父进程进入此处 */</span></span><br><span class="line">    <span class="comment">/* 执行父进程特定的操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重要的是要认识到，在 <code>fork()</code>
之后，<strong>无法确定接下来是哪个进程被调度使用CPU</strong>。在编写不佳的程序中，这种不确定性可能导致称为<strong>竞争条件
(race conditions)</strong> 的错误，我们将在第24.4节进一步描述。</p>
<p>代码清单24-1演示了 <code>fork()</code>
的用法。该程序创建一个子进程，修改它在 <code>fork()</code>
期间继承的全局变量和自动变量的副本。在程序中（由父进程执行的代码中）使用
<code>sleep()</code>，是为了让子进程能在父进程之前被调度到CPU上，从而使子进程可以在父进程继续执行之前完成其工作并终止。使用
<code>sleep()</code>
这种方式并<strong>不是</strong>保证此结果的万无一失的方法；我们将在第24.5节探讨一种更好的方法。
<strong>代码清单 24-1: 使用 fork()</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> idata = <span class="number">111</span>;             <span class="comment">/* 分配在数据段 (data segment) */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> istack = <span class="number">222</span>;               <span class="comment">/* 分配在栈段 (stack segment) */</span></span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (childPid = fork()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:                         <span class="comment">/* 子进程分支 */</span></span><br><span class="line">        idata *= <span class="number">3</span>;                 <span class="comment">/* 修改继承的变量副本 */</span></span><br><span class="line">        istack *= <span class="number">3</span>;                <span class="comment">/* 修改继承的变量副本 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:                        <span class="comment">/* 父进程分支 */</span></span><br><span class="line">        sleep(<span class="number">3</span>);                   <span class="comment">/* 给子进程一个执行的机会 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程和子进程都会执行到这里 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID=%ld %s idata=%d istack=%d\n&quot;</span>, (<span class="type">long</span>) getpid(),</span><br><span class="line">            (childPid == <span class="number">0</span>) ? <span class="string">&quot;(child) &quot;</span> : <span class="string">&quot;(parent)&quot;</span>, idata, istack);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当我们运行清单24-1中的程序时，会看到以下输出： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./t_fork</span><br><span class="line">PID=28557 (child)  idata=333 istack=666</span><br><span class="line">PID=28556 (parent) idata=111 istack=222</span><br></pre></td></tr></table></figure>
上面的输出证明，子进程在 <code>fork()</code>
时获得了栈段和数据段的<strong>自有副本</strong>，并且它能够修改这些段中的变量而<strong>不影响父进程</strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/23/oper_sys23%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/23/oper_sys23%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E8%AF%A6%E8%A7%A3/" class="post-title-link" itemprop="url">操作系统基础 | 5.2 进程管理详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-23 23:49:20" itemprop="dateCreated datePublished" datetime="2025-08-23T23:49:20+08:00">2025-08-23</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-27 10:13:53" itemprop="dateModified" datetime="2025-08-27T10:13:53+08:00">2025-08-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="进程创建-process-creation"><strong>进程创建 (Process
Creation)</strong></h3>
<p>Unix 中的进程创建方式是独特的。大多数操作系统实现一种 <strong>spawn
机制</strong>来在新地址空间中创建新进程、读入可执行文件并开始执行。Unix
则采用了一种不寻常的方法，将这些步骤分离成两个不同的函数：<code>fork()</code>
和 <code>exec()</code>⁷。第一个函数 <code>fork()</code>
创建一个作为当前任务副本的<strong>子进程</strong>。它与父进程的区别仅在于其
PID（是唯一的）、其 PPID（父进程的 PID，被设置为原始进程的
PID）以及某些资源和统计信息（如待处理的信号，这些不被继承）。第二个函数
<code>exec()</code>
将一个新的可执行文件加载到地址空间中并开始执行。<code>fork()</code> 后接
<code>exec()</code> 这种组合，类似于大多数操作系统提供的单一函数。</p>
<p>⁷ 这里的 <code>exec()</code> 指的是 <code>exec()</code>
函数家族中的任何成员。内核实现了 <code>execve()</code>
系统调用，基于此实现了 <code>execlp()</code>, <code>execle()</code>,
<code>execv()</code>, 和 <code>execvp()</code>。</p>
<h4 id="写时复制-copy-on-write"><strong>写时复制
(Copy-on-Write)</strong></h4>
<p>传统上，在 <code>fork()</code>
时，父进程拥有的所有资源都会被复制，并将副本交给子进程。这种方法很朴素且低效，因为它复制了许多本可以共享的数据。更糟糕的是，如果新进程要立即执行一个新的映像（image），所有这些复制都将被浪费。在
Linux 中，<code>fork()</code> 是通过使用<strong>写时复制 (Copy-on-Write
或 COW)</strong>
页来实现的。写时复制是一种延迟或完全防止数据复制的技术。父进程和子进程可以共享一份单一的副本，而不是复制整个进程地址空间。</p>
<p>然而，数据会被标记，如果对其进行写入，就会创建一个副本，每个进程都会收到一个独一无二的副本。因此，资源的复制<strong>仅发生在它们被写入时</strong>；在此之前，它们以只读方式共享。这种技术将地址空间中每一页的复制延迟到实际被写入的时候。如果这些页永远不被写入——例如，如果在
<code>fork()</code> 之后立即调用
<code>exec()</code>——它们就永远不需要被复制。</p>
<p><code>fork()</code> 产生的唯一开销是复制父进程的<strong>页表 (page
tables)</strong>
以及为子进程创建一个唯一的进程描述符。在常见的场景中（进程在 fork
后立即执行一个新的可执行映像），这种优化避免了大量数据（整个地址空间，很容易达到几十兆字节）的浪费性复制。这是一个重要的优化，因为
Unix 哲学鼓励快速的进程执行。</p>
<h4 id="forking"><strong>Forking</strong></h4>
<p>Linux 通过 <code>clone()</code> 系统调用来实现
<code>fork()</code>。这个调用接受一系列标志（flags），用以指定父进程和子进程应共享哪些资源（如果有的话）。（关于这些标志的更多信息，请参阅本章后面的“Linux
的线程实现”一节。）<code>fork()</code>, <code>vfork()</code>, 和
<code>__clone()</code> 库调用都使用必要的标志来调用 <code>clone()</code>
系统调用。而 <code>clone()</code> 系统调用又会调用
<code>do_fork()</code>。</p>
<p>forking 的大部分工作由 <code>do_fork()</code> 处理，该函数定义在
<code>kernel/fork.c</code> 中。此函数调用
<code>copy_process()</code>，然后启动进程运行。有趣的工作是由
<code>copy_process()</code> 完成的：</p>
<ol type="1">
<li>它调用
<code>dup_task_struct()</code>，该函数为新进程创建一个新的内核栈、<code>thread_info</code>
结构和
<code>task_struct</code>。新的值与当前任务的值完全相同。此时，子进程和父进程的描述符是完全相同的。</li>
<li>然后检查确保新的子进程不会超过当前用户所能拥有的进程数量资源限制。</li>
<li>子进程需要与父进程区分开来。进程描述符的各种成员被清除或设置为初始值。不被继承的进程描述符成员主要是统计信息。<code>task_struct</code>
中的大部分值保持不变。</li>
<li>子进程的状态被设置为 <code>TASK_UNINTERRUPTIBLE</code>
以确保它还不会运行。</li>
<li><code>copy_process()</code> 调用 <code>copy_flags()</code> 来更新
<code>task_struct</code> 的 <code>flags</code>
成员。<code>PF_SUPERPRIV</code>
标志（表示任务是否使用了超级用户权限）被清除。<code>PF_FORKNOEXEC</code>
标志（表示进程尚未调用 <code>exec()</code>）被设置。</li>
<li>它调用 <code>alloc_pid()</code> 为新任务分配一个可用的 PID。</li>
<li>根据传递给 <code>clone()</code> 的标志，<code>copy_process()</code>
要么复制要么共享打开的文件、文件系统信息、信号处理程序、进程地址空间和命名空间。这些资源通常在给定进程的线程之间共享；否则，它们是唯一的，因此在这里被复制。</li>
<li>最后，<code>copy_process()</code>
进行清理工作，并向调用者返回一个指向新子进程的指针。</li>
</ol>
<p>回到 <code>do_fork()</code>，如果 <code>copy_process()</code>
成功返回，新的子进程会被唤醒并运行。内核有意地让<strong>子进程先运行</strong>⁸。在子进程通常只是立即调用
<code>exec()</code>
的常见情况下，这消除了如果父进程先运行并开始写入地址空间可能发生的任何写时复制开销。</p>
<blockquote>
<p>⁸
虽然目标是让子进程先运行，但这目前（指原书写作时）并不能正确运行。</p>
</blockquote>
<h4 id="vfork"><strong>vfork()</strong></h4>
<p><code>vfork()</code> 系统调用与 <code>fork()</code>
效果相同，但<strong>不会复制父进程的页表项 (page table
entries)</strong>。相反，子进程作为父进程地址空间中的唯一线程执行，并且<strong>父进程被阻塞</strong>，直到子进程调用
<code>exec()</code>
或退出。不允许子进程写入地址空间。在引入这个调用的旧版 3BSD
时代，这是一个受欢迎的优化，因为当时还没有使用写时复制页来实现
<code>fork()</code>。如今，有了写时复制和子进程优先运行的语义，<code>vfork()</code>
的唯一好处就是<strong>不复制父进程的页表项</strong>。</p>
<p>如果 Linux 有一天实现了写时复制页表项，那么 <code>vfork()</code>
将不再有任何好处⁹。由于 <code>vfork()</code> 的语义很棘手（例如，如果
<code>exec()</code> 失败了会发生什么？），理想情况下系统不需要
<code>vfork()</code>，内核也不必实现它。完全可以将 <code>vfork()</code>
实现为一个普通的 <code>fork()</code> —— 这就是 Linux 在 2.2
版本之前所做的。</p>
<p><code>vfork()</code> 系统调用是通过向 <code>clone()</code>
系统调用传递一个特殊标志来实现的：</p>
<ol type="1">
<li>在 <code>copy_process()</code> 中，<code>task_struct</code> 的成员
<code>vfork_done</code> 被设置为 <code>NULL</code>。</li>
<li>在 <code>do_fork()</code>
中，如果给定了特殊标志，<code>vfork_done</code>
会被指向一个特定的地址。</li>
<li>子首次运行后，父进程——不会立即返回——而是等待子进程通过
<code>vfork_done</code> 指针向其发出信号。</li>
<li>在 <code>mm_release()</code>
函数中（该函数在任务退出内存地址空间时使用），会检查
<code>vfork_done</code> 是否为
<code>NULL</code>。如果不是，则向父进程发送信号。</li>
<li>回到 <code>do_fork()</code>，父进程被唤醒并返回。</li>
</ol>
<p>如果这一切都按计划进行，那么子进程现在在新的地址空间中执行，而父进程则在其原始地址空间中恢复执行。开销是降低了，但实现并不优雅。</p>
<blockquote>
<p>⁹ 页表写时复制可作为补丁，已大概率加入主流内核</p>
</blockquote>
<h3
id="linux-的线程实现-the-linux-implementation-of-threads"><strong>Linux
的线程实现 (The Linux Implementation of Threads)</strong></h3>
<p>线程是一种流行的现代编程抽象。它们在同一程序的共享内存地址空间内提供多个执行线程。它们还可以共享打开的文件和其他资源。线程实现了并发编程，并且在多处理器系统上实现了真正的并行。</p>
<p>Linux 拥有一个独特的线程实现。<strong>对 Linux
内核而言，没有“线程”的概念</strong>。Linux
将所有线程实现为标准进程。Linux
内核并不提供任何特殊的调度语义或数据结构来表示线程。相反，一个线程仅仅是一个与其他进程共享某些资源的进程。每个线程都有一个唯一的
<code>task_struct</code>，并且在内核看来就是一个普通的进程——线程只是恰巧与其他进程共享了资源（例如地址空间）。</p>
<p>这种线程实现方法与 Microsoft Windows 或 Sun Solaris
等操作系统形成了巨大对比，这些操作系统在内核中提供了对线程的明确支持（有时称线程为<strong>轻量级进程
(Lightweight Processes)</strong>）。“轻量级进程”这个名字概括了 Linux
与其他系统在哲学上的差异。对这些其他操作系统而言，线程是一种抽象，旨在提供比笨重进程更轻量、更快速的执行单元。而对
Linux
而言，线程仅仅是进程之间共享资源的一种方式（而进程本身已经相当轻量）¹⁰。</p>
<p>例如，假设一个包含四个线程的进程。在具有显式线程支持的系统中，可能会存在一个进程描述符，该描述符又指向四个不同的线程。进程描述符描述共享资源，如地址空间或打开的文件。线程则描述它们独自拥有的资源。相反，在
Linux 中，简单地存在四个进程，因而有四个普通的 <code>task_struct</code>
结构。这四个进程被设置为共享某些资源。结果非常优雅。</p>
<blockquote>
<p>¹⁰ 例如，可以对比 benchmark 一下 Linux
的进程创建时间与其他操作系统的进程（甚至线程！）创建时间。结果对 Linux
有利。</p>
</blockquote>
<h4 id="创建线程-creating-threads"><strong>创建线程 (Creating
Threads)</strong></h4>
<p>线程的创建方式与普通任务相同，区别在于需要向 <code>clone()</code>
系统调用传递一些标志（flags），这些标志指定了要共享的特定资源：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, <span class="number">0</span>);</span><br></pre></td></tr></table></figure> 上述代码产生的行为与普通的 <code>fork()</code>
相同，但<strong>地址空间、文件系统资源、文件描述符和信号处理程序是共享的</strong>。换句话说，新任务和其父进程就是通常所说的线程。相比之下，一个普通的
<code>fork()</code> 可以实现为： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(SIGCHLD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure> 而 <code>vfork()</code>
可以实现为： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clone(CLONE_VFORK | CLONE_VM | SIGCHLD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure> 提供给 <code>clone()</code>
的标志有助于指定新进程的行为，并详细说明父进程和子进程将共享哪些资源。表
3.1 列出了在 <code>&lt;linux/sched.h&gt;</code> 中定义的 clone
标志及其作用。</p>
<p><strong>(表 3.1 Clone 标志及含义)</strong> | 标志 (Flag) | 含义
(Meaning) | | :----------------------- |
:-----------------------------------------------------------------------------
| | <code>CLONE_FILES</code> | 父子进程共享打开的文件。 | |
<code>CLONE_FS</code> |
父子进程共享文件系统信息（如根目录、当前工作目录）。 | |
<code>CLONE_IDLETASK</code> | 将 PID 设置为零（仅由空闲任务使用）。 | |
<code>CLONE_NEWNS</code> | 为子进程创建新的命名空间 (namespace)。 | |
<code>CLONE_PARENT</code> |
子进程与父进程拥有相同的父进程（即调用者的父进程）。 | |
<code>CLONE_PTRACE</code> | 继续跟踪子进程。 | |
<code>CLONE_SETTID</code> | 将 TID（线程 ID）写回用户空间。 | |
<code>CLONE_SETTLS</code> | 为子进程创建新的 TLS（线程本地存储）。 | |
<code>CLONE_SIGHAND</code> | 父子进程共享信号处理程序和阻塞的信号掩码。
| | <code>CLONE_SYSVSEM</code> | 父子进程共享 System V SEM_UNDO 语义。 |
| <code>CLONE_THREAD</code> |
父子进程位于同一个线程组中。这是将新进程标识为线程而非普通进程的关键标志。
| | <code>CLONE_VFORK</code> | 使用了
<code>vfork()</code>，父进程将睡眠直到子进程唤醒它。 | |
<code>CLONE_UNTRACED</code> | 不允许跟踪进程强制对子进程使用
<code>CLONE_PTRACE</code>。 | | <code>CLONE_STOP</code> | 以
<code>TASK_STOPPED</code> 状态启动进程。 | |
<code>CLONE_CHILD_CLEARTID</code> | 在子进程中清除 TID。 | |
<code>CLONE_CHILD_SETTID</code> | 在子进程中设置 TID。 | |
<code>CLONE_PARENT_SETTID</code> | 在父进程中设置 TID。 | |
<code>CLONE_VM</code> |
父子进程共享地址空间。这是创建线程的关键标志之一。 |</p>
<h4 id="内核线程-kernel-threads"><strong>内核线程 (Kernel
Threads)</strong></h4>
<p>内核在后台执行某些操作通常很有用。内核通过<strong>内核线程 (kernel
threads)</strong>
来实现这一点——内核线程是<strong>仅存在于内核空间的标准进程</strong>。内核线程与普通进程的显著区别在于内核线程<strong>没有地址空间</strong>（它们的
<code>mm</code> 指针指向它们的地址空间，为
<code>NULL</code>）。它们只在内核空间中运行，不会上下文切换到用户空间。然而，内核线程与普通进程一样，是可调度和可抢占的。</p>
<p>Linux 将一些任务委托给内核线程，最著名的是 <code>flush</code> 任务和
<code>ksoftirqd</code> 任务。您可以在 Linux 系统上运行
<code>ps -ef</code> 命令来查看内核线程。数量很多！</p>
<blockquote>
<p>-ef 是 every full(info) 的简写。在所有进程中，CMD 带 []，TTY 为
?，PPID 为 2 或 0， UID是0或者root，是内核线程的特征</p>
</blockquote>
<p>内核线程在系统启动时由其他内核线程创建。实际上，内核线程只能由另一个内核线程创建。内核通过从
<code>kthreadd</code> 内核进程 <strong>fork</strong>
出所有新的内核线程来自动处理此事。在
<code>&lt;linux/kthread.h&gt;</code>
中声明的，用于从现有内核线程生成新内核线程的接口是： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">kthread_create</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params">                                   <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                                   <span class="type">const</span> <span class="type">char</span> namefmt[], ...)</span>;</span><br></pre></td></tr></table></figure>
新任务由 kthread 内核进程通过 <code>clone()</code>
系统调用创建。新进程将运行 <code>threadfn</code> 函数，该函数接收
<code>data</code> 参数。进程将被命名为
<code>namefmt</code>，该参数接受在可变参数列表中的 printf
风格格式化参数。进程创建时处于<strong>不可运行状态 (unrunnable
state)</strong>；只有在通过 <code>wake_up_process()</code>
显式唤醒后，它才会开始运行。可以使用单个函数 <code>kthread_run()</code>
来创建并使进程可运行： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">kthread_run</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params">                                <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">char</span> namefmt[], ...)</span>;</span><br></pre></td></tr></table></figure> 这个例程（作为宏实现）简单地调用了
<code>kthread_create()</code> 和 <code>wake_up_process()</code>：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kthread_run(threadfn, data, namefmt, ...)                     \</span></span><br><span class="line"><span class="meta">(&#123;                                                                    \</span></span><br><span class="line"><span class="meta">    struct task_struct *k;                                        \</span></span><br><span class="line"><span class="meta">                                                                      \</span></span><br><span class="line"><span class="meta">    k = kthread_create(threadfn, data, namefmt, ## __VA_ARGS__);  \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (!IS_ERR(k))                                               \</span></span><br><span class="line"><span class="meta">        wake_up_process(k);                                   \</span></span><br><span class="line"><span class="meta">    k;                                                            \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure> 启动后，内核线程会继续存在，直到它调用
<code>do_exit()</code>，或者内核的另一部分调用
<code>kthread_stop()</code>（传入由 <code>kthread_create()</code> 返回的
<code>task_struct</code> 结构体的地址）： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kthread_stop</span><span class="params">(<span class="keyword">struct</span> task_struct *k)</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="进程终止-process-termination"><strong>进程终止 (Process
Termination)</strong></h3>
<p>这很遗憾，但进程最终都会消亡。当一个进程终止时，内核会释放该进程所拥有的资源，并通知其父进程关于子进程消亡的消息。</p>
<p>通常，进程销毁是<strong>自我诱导 (self-induced)</strong>
的。当进程调用 <code>exit()</code>
系统调用时就会发生，这可以是在它准备终止时显式调用，也可以是在从任何程序的
main 子程序返回时隐式调用（即 C 编译器会在 <code>main()</code>
返回后放置一个对 <code>exit()</code>
的调用）。进程也可能<strong>非自愿地 (involuntarily)</strong>
终止。这发生在进程收到一个它无法处理或忽略的信号或异常时。</p>
<p>无论进程如何终止，大部分工作都由 <code>do_exit()</code> 处理（定义在
<code>kernel/exit.c</code> 中），它完成一系列收尾工作：</p>
<ol type="1">
<li>它在 <code>task_struct</code> 的 <code>flags</code> 成员中设置
<code>PF_EXITING</code> 标志。</li>
<li>它调用 <code>del_timer_sync()</code>
来移除任何内核定时器。确保返回时没有定时器在排队，也没有定时器处理程序在运行。</li>
<li>如果启用了 BSD 进程记账 (process accounting)，<code>do_exit()</code>
会调用 <code>acct_update_integrals()</code> 来写出记账信息。</li>
<li>它调用 <code>exit_mm()</code> 来释放该进程持有的
<code>mm_struct</code>。如果没有其他进程在使用这个地址空间（即地址空间未被共享），内核就会销毁它。</li>
<li>它调用 <code>exit_sem()</code>。如果进程正在排队等待一个 IPC
信号量，它在这里被移出队列。</li>
<li>然后它调用 <code>exit_files()</code> 和 <code>exit_fs()</code>
来分别递减与文件描述符和文件系统数据相关的对象的引用计数。如果某个引用计数降为零，说明该对象不再被任何进程使用，随即被销毁。</li>
<li>它将任务的退出码（存储在 <code>task_struct</code> 的
<code>exit_code</code> 成员中）设置为 <code>exit()</code>
提供的代码或任何强制终止它的内核机制所提供的代码。退出码存储在这里，供父进程选择性检索。</li>
<li>它调用 <code>exit_notify()</code>
来向任务的父进程发送信号，将该任务的任何子进程<strong>重新设定父进程
(reparent)</strong> 给其线程组中的另一个线程或 init
进程，并将任务的退出状态（存储在 <code>task_struct</code> 结构的
<code>exit_state</code> 中）设置为 <code>EXIT_ZOMBIE</code>。</li>
<li><code>do_exit()</code> 调用 <code>schedule()</code>
来切换到新进程（参见第 4
章）。因为该进程现在已不可调度，这是该任务将执行的最后代码。<code>do_exit()</code>
永不返回。</li>
</ol>
<p>至此，与任务关联的所有对象（假设该任务是唯一使用者）都已释放。该任务不可运行（并且不再有地址空间可供运行），并处于
<code>EXIT_ZOMBIE</code>（僵尸）退出状态。它占用的唯一内存是它的内核栈、<code>thread_info</code>
结构和 <code>task_struct</code>
结构。该任务存在的唯一目的是向其父进程提供信息。在父进程检索到信息，或通知内核它不感兴趣之后，进程持有的剩余内存将被释放并返回给系统使用。</p>
<h4
id="移除进程描述符-removing-the-process-descriptor"><strong>移除进程描述符
(Removing the Process Descriptor)</strong></h4>
<p>在 <code>do_exit()</code>
完成后，已终止进程的进程描述符仍然存在，但该进程已成为僵尸 (zombie)
且无法运行。如前所述，这使得系统能够在子进程终止后获取其信息。因此，清理进程之后和移除其进程描述符是分开的两个步骤。在父进程获取了已终止子进程的信息，或向内核表示不关心之后，子进程的
<code>task_struct</code> 才会被释放。</p>
<p><code>wait()</code> 函数族是通过一个单一（且复杂）的系统调用
<code>wait4()</code>
实现的。标准行为是<strong>挂起调用任务的执行</strong>，直到它的一个子进程退出，此时函数返回退出子进程的
PID。此外，还提供一个指针给该函数，该指针在返回时持有已终止子进程的退出码。</p>
<p>当最终要释放进程描述符时，会调用
<code>release_task()</code>。它执行以下操作： 1. 它调用
<code>__exit_signal()</code>，后者又调用
<code>__unhash_process()</code>，继而调用 <code>detach_pid()</code>
来将进程从 pidhash 中移除，并从任务列表中移除该进程。 2.
<code>__exit_signal()</code>
释放这个已死亡进程使用的任何剩余资源，并完成统计和簿记工作。 3.
如果该任务是线程组的最后一个成员，并且领导者 (leader) 是僵尸进程，那么
<code>release_task()</code> 会通知僵尸领导者的父进程。 4.
<code>release_task()</code> 调用 <code>put_task_struct()</code>
来释放包含进程内核栈和 <code>thread_info</code> 结构的内存页，并释放包含
<code>task_struct</code> 的 slab 缓存。</p>
<p>至此，进程描述符以及仅属于该进程的所有资源都已被释放。</p>
<h4
id="无父任务的困境-the-dilemma-of-the-parentless-task"><strong>无父任务的困境
(The Dilemma of the Parentless Task)</strong></h4>
<p>如果一个父进程在其子进程之前退出，必须存在某种机制来将任何子任务<strong>重新设定父进程
(reparent)</strong>
给一个新进程，否则，没有父进程的已终止进程将永远保持僵尸状态，浪费系统内存。解决方案是在退出时将一个任务的子进程重新设定父进程给当前线程组中的另一个进程，如果失败，则设定给
init 进程。<code>do_exit()</code> 调用
<code>exit_notify()</code>，后者调用
<code>forget_original_parent()</code>，该函数又调用
<code>find_new_reaper()</code> 来执行重新设定父进程的操作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_struct *<span class="title function_">find_new_reaper</span><span class="params">(<span class="keyword">struct</span> task_struct *father)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns</span> =</span> task_active_pid_ns(father);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    thread = father;</span><br><span class="line">    while_each_thread(father, thread) &#123;</span><br><span class="line">        <span class="keyword">if</span> (thread-&gt;flags &amp; PF_EXITING)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (unlikely(pid_ns-&gt;child_reaper == father))</span><br><span class="line">            pid_ns-&gt;child_reaper = thread;</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> pid_ns-&gt;child_reaper; <span class="comment">// 通常是 init 进程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（代码已简化，核心逻辑是查找同一线程组内未退出的线程，或最终返回 init
进程）</p>
<p>这段代码尝试在进程的线程组中查找并返回另一个任务。如果线程组中没有其他任务，它就查找并返回
init
进程。找到合适的新父进程后，需要找到每个子进程并将其重新设定父进程给这个新的“收割者”(reaper)：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">reaper = find_new_reaper(father);</span><br><span class="line">list_for_each_entry_safe(p, n, &amp;father-&gt;children, sibling) &#123;</span><br><span class="line">    p-&gt;real_parent = reaper;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;parent == father) &#123;</span><br><span class="line">        BUG_ON(p-&gt;ptrace);</span><br><span class="line">        p-&gt;parent = p-&gt;real_parent;</span><br><span class="line">    &#125;</span><br><span class="line">    reparent_thread(p, father);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用 <code>ptrace_exit_finish()</code>
做同样的事情，但是针对一个被 ptrace 跟踪 (ptraced) 的子进程列表。</p>
<p>同时拥有一个子进程列表 (child list) 和一个被跟踪子进程列表 (ptraced
list) 的基本原理很有趣；这是 2.6 内核的一个新特性。当一个任务被
<code>ptrace</code>
跟踪时，它被临时重新设定父进程给调试进程。然而，当该任务的原始父进程退出时，它必须与其兄弟姐妹一起被重新设定父进程。在之前的内核中，这会导致需要循环遍历系统中的每个进程来查找子进程。解决方案就是简单地维护一个进程被
<code>ptrace</code>
跟踪的子进程的独立列表——将查找子进程的范围从系统中的每个进程缩小到仅仅两个相对较小的列表。</p>
<p>随着进程成功被重新设定父进程，就不再存在 stray zombie processes（
stray zombie processes）的风险。init 进程会例行地对其子进程调用
<code>wait()</code>，清理分配给它的任何僵尸进程。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/20/oper_sys22%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/20/oper_sys22%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">操作系统基础 | 5.1 进程管理简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-21 00:55:36" itemprop="dateCreated datePublished" datetime="2025-08-21T00:55:36+08:00">2025-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-28 09:19:55" itemprop="dateModified" datetime="2025-08-28T09:19:55+08:00">2025-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="进程"><strong>进程</strong></h3>
<p>一个进程是一个正在执行中的程序（存储在某种介质上的目标代码）。然而，进程不仅仅只是执行的程序代码（在
Unix
中常称为文本段）。它们还包括一系列资源，例如打开的文件和待处理的信号、内核内部数据、处理器状态、包含一个或多个内存映射的内存地址空间、一个或多个执行线程，以及包含全局变量的数据段。实际上，进程是运行程序代码的动态产物。内核需要高效且透明地管理所有这些细节。</p>
<p>执行线程（通常简称为线程）是进程内部的活动对象。每个线程包含一个唯一的程序计数器、进程栈和一组处理器寄存器。内核调度的是单个线程，而不是进程。在传统的
Unix
系统中，每个进程由一个线程组成。然而，在现代系统中，由多个线程组成的多线程程序非常普遍。正如您后面将看到的，Linux
对线程的实现很独特：它并不区分线程和进程。对 Linux
而言，线程只是一种特殊的进程。</p>
<p>在现代操作系统上，进程提供了两种虚拟化：虚拟化处理器和虚拟内存。虚拟化处理器给进程一种假象，让它以为自己在独享系统，尽管处理器可能正与数百个其他进程共享。虚拟内存让进程可以分配和管理内存，就好像它独占了系统中的所有内存一样。</p>
<p>有趣的是，请注意线程共享虚拟内存抽象，而每个线程则拥有自己的虚拟化处理器。</p>
<p>程序本身并不是一个进程；进程是活动中的程序及其相关资源。实际上，可以存在两个或更多个执行同一程序的进程。事实上，也可以存在两个或更多共享各种资源（如打开的文件或地址空间）的进程。</p>
<p>毫不奇怪，进程在其创建时开始它的生命周期。在 Linux 中，这是通过
<code>fork()</code>
系统调用来完成的，该系统调用通过复制一个现有进程来创建一个新进程。调用
<code>fork()</code>
的进程是父进程，而新进程是子进程。父进程恢复执行，而子进程则在相同的地方开始执行：即从
<code>fork()</code> 调用返回的地方。<code>fork()</code>
系统调用从内核返回两次：一次在父进程中，一次在新生的子进程中。</p>
<p>通常，在 <code>fork()</code>
之后立即需要执行一个新的、不同的程序。<code>exec()</code>
系列函数调用会创建一个新的地址空间并将一个新的程序加载到其中。在当代的
Linux 内核中，<code>fork()</code> 实际上是通过 <code>clone()</code>
系统调用实现的，这将在后面讨论。</p>
<p>最后，程序通过 <code>exit()</code>
系统调用退出。此函数终止进程并释放其所有资源。父进程可以通过
<code>wait4()</code>¹
系统调用查询已终止子进程的状态，该系统调用使一个进程能够等待特定进程的终止。当一个进程退出时，它会被置于一种特殊的<strong>僵尸
(zombie)</strong> 状态，该状态表示已终止的进程，直到父进程调用
<code>wait()</code> 或 <code>waitpid()</code>。</p>
<blockquote>
<p>¹ 内核实现了 <code>wait4()</code> 系统调用。Linux 系统通过 C
库通常提供 <code>wait()</code>, <code>waitpid()</code>,
<code>wait3()</code>, 和 <code>wait4()</code>
函数。所有这些函数都返回关于已终止进程的状态信息，尽管语义略有不同。</p>
</blockquote>
<p><strong>注意</strong> 进程的另一个名称是<strong>任务
(task)</strong>。Linux
内核在内部将进程称为任务。在本书中，我会交替使用这两个术语，尽管当我说“任务”时，通常是从内核的角度来指代一个进程。</p>
<hr />
<h3
id="进程描述符和任务结构-task-structure"><strong>进程描述符和任务结构
(Task Structure)</strong></h3>
<p>内核在一个称为<strong>任务列表 (task list)</strong>²
的环形双向链表中存储进程列表。任务列表中的每个元素都是一个类型为
<code>struct task_struct</code> 的进程描述符，该结构定义在
<code>&lt;linux/sched.h&gt;</code>
中。进程描述符包含了一个特定进程的所有信息。</p>
<p><code>task_struct</code> 是一个相对较大的数据结构，在 32 位机器上约为
1.7
千字节。然而，考虑到该结构包含了内核所拥有和需要的关于一个进程的所有信息，这个大小已经相当小了。进程描述符包含了描述正在执行的程序的数据——打开的文件、进程的地址空间、待处理的信号、进程的状态等等。</p>
<blockquote>
<p>² 一些操作系统设计文献称此列表为任务数组 (task array)。由于 Linux
的实现是链表而非静态数组，因此在 Linux 中它被称为任务列表 (task
list)。</p>
</blockquote>
<hr />
<h3 id="分配进程描述符"><strong>分配进程描述符</strong></h3>
<p><code>task_struct</code> 结构通过 <strong>slab 分配器 (slab
allocator)</strong> 进行分配，以提供对象重用和缓存着色。在 2.6
系列内核之前，<code>struct task_struct</code>
存储在每个进程的内核栈的末端。这使得像 x86
这样寄存器数量较少的体系结构，可以通过栈指针计算进程描述符的位置，而无需使用额外的寄存器来存储该位置。由于现在进程描述符是通过
slab 分配器动态创建的，因此引入了一个新的结构
<code>struct thread_info</code>，该结构再次存在于栈的底部（对于向下增长的栈）或栈的顶部（对于向上增长的栈）³。参见图
3.2。</p>
<blockquote>
<p>³ 创建 <code>struct thread_info</code>
并不仅仅是因为寄存器受限的体系结构。新结构也使得在汇编代码中计算其值的偏移量变得相当容易。</p>
</blockquote>
<p><code>thread_info</code> 结构在 x86 上的
<code>&lt;asm/thread_info.h&gt;</code> 中定义如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>    *<span class="title">task</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>    *<span class="title">exec_domain</span>;</span></span><br><span class="line">    __u32                 flags;</span><br><span class="line">    __u32                 status;</span><br><span class="line">    __u32                 cpu;</span><br><span class="line">    <span class="type">int</span>                   preempt_count;</span><br><span class="line">    <span class="type">mm_segment_t</span>          addr_limit;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span>  <span class="title">restart_block</span>;</span></span><br><span class="line">    <span class="type">void</span>                  *sysenter_return;</span><br><span class="line">    <span class="type">int</span>                   uaccess_err;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><strong>(图 3.2 示意图说明)</strong> 进程内核栈<br />
栈起始处（向低地址方向增长）<br />
- 最高内存地址<br />
- 栈指针<br />
- <code>struct thread_struct</code> (进程的
<code>struct task_struct</code>)<br />
- 最低内存地址, <code>current_thread_info()</code><br />
<code>thread_info</code> 包含一个指向进程描述符的指针</p>
<blockquote>
<p>栈的增长方向：x86 体系的栈是向下（向低地址方向）增长的。 - 栈底
(Stack Base)：为了充分利用这块内存，栈被初始化为从这块分配区的最高地址
(0x10000)
开始。这个初始的栈指针位置就是栈底。它是栈的“起点”，但却是分配内存块的“末尾”。
- 栈顶 (Stack Top)：随着函数调用、压入参数等操作，%esp
寄存器的值会不断减小（向 0xE000 方向移动）。%esp
当前指向的位置称为栈顶。它是栈的“当前操作端”，向低地址方向延伸。</p>
</blockquote>
<p>每个任务的 <code>thread_info</code> 结构都分配在其栈的末端。该结构的
<code>task</code> 元素是一个指向任务实际 <code>task_struct</code>
的指针。</p>
<hr />
<h3 id="存储进程描述符"><strong>存储进程描述符</strong></h3>
<p>系统通过一个唯一的<strong>进程标识值 (process identification
value)</strong> 或 <strong>PID</strong> 来识别进程。PID
是一个由不透明类型⁴ <code>pid_t</code> 表示的数值，通常是一个
<code>int</code>。然而，为了与早期的 Unix 和 Linux
版本向后兼容，默认最大值仅为 32,768（一个 <code>short int</code>
的值），尽管可以选择将该值增加到高达 400 万（这由
<code>&lt;linux/threads.h&gt;</code> 控制）。内核在每个进程描述符的
<code>pid</code> 字段中存储此值。</p>
<blockquote>
<p>⁴ 不透明类型 (opaque
type)：指其内部细节被隐藏，只通过特定接口访问的数据类型。</p>
</blockquote>
<p>这个最大值很重要，因为它本质上是系统上可能同时存在的最大进程数。虽然
32,768
对于桌面系统可能足够，但大型服务器可能需要多得多的进程。此外，该值越低，数值回绕（wrap
around）就越快，这会破坏“数值大的进程比数值小的进程更晚运行”这一有用概念。如果系统愿意打破与旧应用程序的兼容性，管理员可以通过
<code>/proc/sys/kernel/pid_max</code> 来增加最大值。</p>
<p>在内核内部，通常直接通过指向其 <code>task_struct</code>
结构的指针来引用任务。事实上，大多数处理进程的内核代码都直接使用
<code>struct task_struct</code>。因此，能够快速查找当前正在执行的任务的进程描述符是非常有用的，这是通过
<code>current</code>
宏来完成的。这个宏必须由每个体系结构独立实现。一些体系结构将当前运行进程的
<code>task_struct</code>
结构的指针保存在一个寄存器中，以实现高效访问。其他体系结构，如
x86（几乎没有多余的寄存器可用），则利用 <code>struct thread_info</code>
存储在内核栈上这一条件，来计算 <code>thread_info</code> 的位置，进而找到
<code>task_struct</code>。</p>
<p>在 x86 上，<code>current</code> 是通过滤除栈指针的最低 13 位来获得
<code>thread_info</code> 结构计算的。这是由
<code>current_thread_info()</code> 函数完成的。汇编代码如下：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl $-8192, %eax</span><br><span class="line">andl %esp, %eax</span><br></pre></td></tr></table></figure> 这里假设栈大小是 8KB。当启用 4KB 栈时，使用 4096 代替
8192。</p>
<p>最后，<code>current</code> 解引用 <code>thread_info</code> 的
<code>task</code> 成员以返回 <code>task_struct</code>：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current_thread_info()-&gt;task;</span><br></pre></td></tr></table></figure></p>
<p>将此方法与 PowerPC（IBM 的现代基于 RISC
的微处理器）采用的方法对比，后者将当前的 <code>task_struct</code>
存储在一个寄存器中。因此，在 PPC 上 <code>current</code>
仅仅返回存储在寄存器 <code>r2</code> 中的值。PPC
可以采用这种方法是因为，与 x86
不同，它有大量的寄存器。由于访问进程描述符是一项常见且重要的工作，PPC
内核开发人员认为使用一个寄存器是值得的。</p>
<h3 id="进程状态-process-state"><strong>进程状态 (Process
State)</strong></h3>
<p>进程描述符中的 <code>state</code> 字段描述了进程的当前状况（参见图
3.3）。系统中的每个进程都确切地处于五种不同状态中的一种。该值由以下五个标志之一表示：</p>
<ul>
<li><strong>TASK_RUNNING
(运行)</strong>：进程是可运行的；它要么正在执行，要么在运行队列（runqueue）中等待运行（运行队列将在第
4
章讨论）。这是在用户空间执行的进程唯一可能的状态；它也应用于正在内核空间中主动运行的进程。</li>
<li><strong>TASK_INTERRUPTIBLE
(可中断睡眠)</strong>：进程正在睡眠（即被阻塞），等待某个条件的发生。当此条件满足时，内核会将进程的状态设置为
<code>TASK_RUNNING</code>。如果进程接收到信号，它也会被提前唤醒并变为可运行状态。</li>
<li><strong>TASK_UNINTERRUPTIBLE (不可中断睡眠)</strong>：此状态与
<code>TASK_INTERRUPTIBLE</code>
类似，区别在于即使接收到信号，它也不会被唤醒并变为可运行状态。此状态用于进程必须不受中断地等待，或者预期事件会很快发生的场合。由于处在此状态的任务不响应信号，因此
<code>TASK_UNINTERRUPTIBLE</code> 的使用频率低于
<code>TASK_INTERRUPTIBLE</code>⁵。</li>
<li>**__TASK_TRACED (被跟踪)**：进程正被另一个进程（例如调试器通过
<code>ptrace</code>）所跟踪。</li>
<li>**__TASK_STOPPED
(停止)**：进程执行已停止；任务既不在运行，也没有资格运行。如果任务收到
<code>SIGSTOP</code>、<code>SIGTSTP</code>、<code>SIGTTIN</code> 或
<code>SIGTTOU</code>
信号，或者在被调试时收到任何信号，就会发生这种状态。</li>
</ul>
<blockquote>
<p>⁵ 这就是为什么在 <code>ps(1)</code> 命令中会出现那些状态为 D (即
<code>TASK_UNINTERRUPTIBLE</code>)
的、令人头疼的无法杀死的进程。因为该任务不响应信号，你无法向它发送
<code>SIGKILL</code>
信号。此外，即使你能终止该任务，这样做通常也不明智，因为该任务可能正在进行一项重要操作（并可能持有信号量）。</p>
</blockquote>
<h3
id="操作当前进程状态-manipulating-the-current-process-state"><strong>操作当前进程状态
(Manipulating the Current Process State)</strong></h3>
<p>内核代码经常需要更改进程的状态。首选机制是使用： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_task_state(task, state);        <span class="comment">/* 将任务 &#x27;task&#x27; 的状态设置为 &#x27;state&#x27; */</span></span><br></pre></td></tr></table></figure>
此函数将给定的任务设置为给定的状态。在适用的情况下，它还提供一个<strong>内存屏障
(memory barrier)</strong> 以强制在其他处理器上的执行顺序（这仅在 SMP
系统上需要）。否则，它等价于： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task-&gt;state = state;</span><br></pre></td></tr></table></figure> 方法
<code>set_current_state(state)</code> 等同于
<code>set_task_state(current, state)</code>。请参阅
<code>&lt;linux/sched.h&gt;</code> 以了解这些及相关函数的实现。</p>
<hr />
<h3 id="进程上下文-process-context"><strong>进程上下文 (Process
Context)</strong></h3>
<p>进程最重要的部分之一是正在执行的程序代码。这些代码从可执行文件中读入，并在程序的地址空间内执行。正常的程序执行发生在<strong>用户空间
(user-space)</strong>。当程序执行系统调用或触发异常时，它就进入了<strong>内核空间
(kernel-space)</strong>。此时，内核被称为“代表进程执行”并处于<strong>进程上下文
(process context)</strong> 中。在进程上下文中，<code>current</code>
宏是有效的⁶。退出内核后，进程会在用户空间恢复执行，除非在此期间有更高优先级的进程变为可运行状态（这种情况下将调用调度器来选择更高优先级的进程）。</p>
<blockquote>
<p>⁶ 除了进程上下文，还有<strong>中断上下文 (interrupt
context)</strong>。在中断上下文中，系统并非代表某个进程运行，而是在执行一个中断处理程序。没有进程与中断处理程序相关联。</p>
</blockquote>
<p>系统调用和异常处理程序是进入内核的明确定义的接口。进程只能通过这些接口之一开始在内核空间中执行——所有对内核的访问都是通过这些接口进行的。</p>
<hr />
<h3 id="进程家族树-the-process-family-tree"><strong>进程家族树 (The
Process Family Tree)</strong></h3>
<p>在 Unix 系统（Linux
也不例外）的进程之间存在着一个清晰的层次结构。所有进程都是 <strong>init
进程</strong>（其 PID 为 1）的后代。内核在启动过程的最后步骤中启动
<code>init</code>。然后，<code>init</code>
进程读取系统初始化脚本并执行更多程序，最终完成启动过程。</p>
<p>系统中的每个进程都有且只有一个<strong>父进程
(parent)</strong>。同样，每个进程有零个或多个<strong>子进程
(children)</strong>。同一父进程的所有直接子进程称为<strong>兄弟进程
(siblings)</strong>。进程之间的关系存储在进程描述符中。每个
<code>task_struct</code> 都有一个指向父进程 <code>task_struct</code>
的指针（名为 <code>parent</code>），以及一个子进程的链表（名为
<code>children</code>）。</p>
<p>因此，给定当前进程，可以通过以下代码获取其父进程的描述符：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">my_parent</span> =</span> current-&gt;parent;</span><br></pre></td></tr></table></figure> 类似地，可以这样遍历一个进程的所有子进程：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each(<span class="built_in">list</span>, &amp;current-&gt;children) &#123;</span><br><span class="line">    task = list_entry(<span class="built_in">list</span>, <span class="keyword">struct</span> task_struct, sibling);</span><br><span class="line">    <span class="comment">/* task 现在指向 current 的某个子进程 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>init 任务的进程描述符是静态分配的，名为
<code>init_task</code>。所有进程间关系的一个很好例证是下面这段代码总能执行成功：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="keyword">for</span> (task = current; task != &amp;init_task; task = task-&gt;parent)</span><br><span class="line">    ;</span><br><span class="line"><span class="comment">/* 循环结束后，task 指向了 init */</span></span><br></pre></td></tr></table></figure>
实际上，你可以从系统中的任何一个进程出发，循着进程层次结构到达任何其他进程。</p>
<p>然而，通常我们更希望简单地遍历系统中的所有进程。这很容易，因为任务列表是一个<strong>循环双向链表
(circular doubly linked
list)</strong>。给定任何一个有效任务，要获取链表中的下一个任务，可以使用：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_entry(task-&gt;tasks.next, <span class="keyword">struct</span> task_struct, tasks)</span><br></pre></td></tr></table></figure> 获取上一个任务的方式相同： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_entry(task-&gt;tasks.prev, <span class="keyword">struct</span> task_struct, tasks)</span><br></pre></td></tr></table></figure>
这两个操作分别由宏 <code>next_task(task)</code> 和
<code>prev_task(task)</code> 提供。最后，提供了宏
<code>for_each_process(task)</code>
用于遍历整个任务列表。每次迭代时，<code>task</code>
指向列表中的下一个任务： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line">for_each_process(task) &#123;</span><br><span class="line">    <span class="comment">/* 这段代码无意义地打印每个任务的名称和 PID */</span></span><br><span class="line">    printk(<span class="string">&quot;%s[%d]\n&quot;</span>, task-&gt;comm, task-&gt;pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <strong>注意</strong>
在拥有大量进程的系统中，遍历每个任务的开销很大；代码在这样做之前应该有充分的理由（并且没有其他替代方案）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/19/oper_sys21%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%AE%9E%E9%AA%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/19/oper_sys21%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E5%AE%9E%E9%AA%8C/" class="post-title-link" itemprop="url">操作系统基础 | 4.7 内核模块实验</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-20 01:15:49" itemprop="dateCreated datePublished" datetime="2025-08-20T01:15:49+08:00">2025-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-21 00:31:13" itemprop="dateModified" datetime="2025-08-21T00:31:13+08:00">2025-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/lab/" itemprop="url" rel="index"><span itemprop="name">lab</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="可加载的内核模块">可加载的内核模块</h3>
<h4 id="练习-1">练习 1</h4>
<p>准备好实验报告</p>
<hr />
<h4 id="练习-2-编译内核模块">练习 2: 编译内核模块</h4>
<ol type="1">
<li><strong>步骤</strong>: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Linux Lab 集群上</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /project/scratch01/compile/your-username/modules</span><br><span class="line"><span class="built_in">cd</span> /project/scratch01/compile/your-username/modules</span><br><span class="line"><span class="comment"># 保存 simple_module.c 和 Makefile (内容: obj-m := simple_module.o)</span></span><br><span class="line">module add arm-rpi</span><br><span class="line"><span class="built_in">export</span> LINUX_SOURCE=/path/to/your/linux_source/linux <span class="comment"># 设置内核源码路径</span></span><br><span class="line">make -C <span class="variable">$LINUX_SOURCE</span> ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- M=<span class="variable">$PWD</span> modules</span><br></pre></td></tr></table></figure></li>
<li><strong>答案</strong>: 提交 <code>make</code> 命令的完整输出。</li>
</ol>
<hr />
<h4 id="练习-3-加载模块与系统日志">练习 3: 加载模块与系统日志</h4>
<ol type="1">
<li><strong>步骤</strong> (在树莓派上): <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/modules</span><br><span class="line"><span class="comment"># 使用 sftp 将 simple_module.ko 传输到此目录</span></span><br><span class="line">sudo dmesg --clear</span><br><span class="line">sudo insmod ~/modules/simple_module.ko</span><br><span class="line">dmesg <span class="comment"># 查看日志</span></span><br></pre></td></tr></table></figure></li>
<li><strong>答案</strong>: 提交 <code>dmesg</code>
中显示的模块加载信息。</li>
</ol>
<hr />
<h4 id="练习-4-验证模块列表与卸载">练习 4: 验证模块列表与卸载</h4>
<ol type="1">
<li><strong>步骤</strong>: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsmod <span class="comment"># 确认 simple_module 在列表中</span></span><br><span class="line">sudo rmmod simple_module</span><br><span class="line">lsmod <span class="comment"># 确认已移除</span></span><br><span class="line">dmesg <span class="comment"># 查看卸载信息</span></span><br></pre></td></tr></table></figure></li>
<li><strong>答案</strong>: 提交 <code>lsmod</code>
的输出（证明已卸载）和 <code>dmesg</code> 中显示的模块卸载信息。</li>
</ol>
<hr />
<h4 id="练习-5-访问内核变量-jiffies">练习 5: 访问内核变量 jiffies</h4>
<ol type="1">
<li><strong>步骤</strong>:
<ul>
<li>复制 <code>simple_module.c</code> 为
<code>jiffies_module.c</code>。</li>
<li>修改其 init 和 exit 函数，使用 <code>printk</code> 打印
<code>jiffies</code> 变量（类型
<code>extern unsigned long volatile jiffies;</code>）。</li>
<li>更新 Makefile: <code>obj-m += jiffies_module.o</code>。</li>
<li>重新编译并传输 <code>jiffies_module.ko</code> 到树莓派。</li>
<li>加载并卸载模块，观察 <code>dmesg</code>。</li>
</ul></li>
<li><strong>答案</strong>:
<ul>
<li>提交 <code>dmesg</code> 中显示加载和卸载时 <code>jiffies</code>
值的日志消息。</li>
<li>计算并说明两条消息之间发生的滴答数（tick count）。</li>
</ul></li>
</ol>
<hr />
<h3 id="需提交的内容">需提交的内容</h3>
<p>请提交一个包含以下内容的压缩包或文档： 1. <strong>答案文件</strong>:
包含上述所有练习的答案。 2. <strong>源代码文件</strong>: 你新创建的
<code>jiffies_module.c</code> 文件。</p>
<hr />
<h3 id="可选拓展练习">可选拓展练习</h3>
<h4 id="练习-6-模块初始化返回值实验">练习 6: 模块初始化返回值实验</h4>
<ul>
<li><strong>任务</strong>: 修改 init
函数，使其分别返回正数和负数（错误码，参见
<code>/include/uapi/asm-generic/errno-base.h</code>）。</li>
<li><strong>提示</strong>:
描述加载模块时发生的情况及其在系统日志中的表现。</li>
</ul>
<h4 id="练习-7-探查导出的内核符号">练习 7: 探查导出的内核符号</h4>
<ul>
<li><strong>任务</strong>: 查看 <code>/proc/kallsyms</code> 文件（例如
<code>cat /proc/kallsyms</code>），了解内核符号表。查找带有
<code>__kstrtab_</code> 和 <code>__ksymtab_</code>
前缀的符号（这些是可供模块使用的导出符号）。</li>
<li><strong>提示</strong>: 内核符号是 Linux
内核代码中定义的函数、变量、数据结构等的名称标签。它们代表了在内核地址空间中的一个特定内存地址。
可以将内核符号理解为内核的“公共接口”或“入口点”。主要有两种类型：</li>
<li>导出的符号：这些是内核明确声明为可以被外部模块使用的符号。例如，printk（内核的
printf）、kmalloc（内核的内存分配函数）等。模块通过使用 EXPORT_SYMBOL()
或 EXPORT_SYMBOL_GPL() 宏来导出它们的符号，以便其他模块可以使用。</li>
<li>非导出的符号：这些是内核内部的静态函数或变量，只在它们被定义的文件或内核的特定部分中使用。它们对于内核模块是不可见的，主要用于内核自身的组织</li>
<li>EXPORT_SYMBOL(printk) 在编译后创建了两个内部符号：__ksymtab_printk
和 __kstrtab_printk。
<ul>
<li>__ksymtab_printk 是一个结构体，包含了 printk 的地址和指向
__kstrtab_printk 的指针。</li>
<li>__kstrtab_printk 是一个字符串，存储着 printk 的名字。</li>
</ul></li>
<li>内核使用这个结构来高效地通过名字查找函数的地址</li>
</ul>
<h4 id="练习-8-实现用户态读取-cpu-周期计数器-ccnt-的模块">练习 8:
实现用户态读取 CPU 周期计数器 (CCNT) 的模块</h4>
<ul>
<li><strong>任务</strong> (如果之前在系统调用工作室未完成):
<ul>
<li>将提供的驱动文件放入你的内核源码树的
<code>arch/arm/include/asm</code> 目录。</li>
<li>下载 <code>enable_ccnt.c</code> 内核模块代码到你的模块目录。</li>
<li>编译、传输并加载此模块 (<code>insmod enable_ccnt.ko</code>)。</li>
<li>使用 <code>dmesg | tail</code> 验证加载成功。</li>
</ul></li>
<li><strong>任务</strong> (主要部分):
<ul>
<li>在树莓派上创建一个用户态程序。</li>
<li>该程序应 <code>#include</code> 你获取的驱动头文件。</li>
<li>调用 <code>unsigned long long pmccntr_get(void)</code>
函数两次。</li>
</ul></li>
<li><strong>答案</strong>:
<ul>
<li>说明运行一次 <code>pmccntr_get()</code> 函数大约需要多少 CPU
周期（计算两次调用的差值）。</li>
<li>如果你在系统调用工作室完成过类似的练习，请对比直接调用此函数与通过系统调用获取周期计数所需的周期数。</li>
</ul></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/19/oper_sys20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/19/oper_sys20/" class="post-title-link" itemprop="url">操作系统基础 | 4.6 内核API重构案例：IDR API</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-20 01:07:16 / 修改时间：01:11:57" itemprop="dateCreated datePublished" datetime="2025-08-20T01:07:16+08:00">2025-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>文章内容来自 LWN.net</p>
<h3 id="文章摘要-summary">文章摘要 (Summary)</h3>
<p>这篇发表于 2013 年 2 月的文章讨论了 Linux 内核中 <strong>IDR 子系统
API 的一次重大简化改革</strong>，由开发者 Tejun Heo 主导。IDR
机制用于高效分配和管理整数 ID（例如设备名、POSIX 定时器 ID 等），其旧
API 因其复杂性和潜在的竞争条件而闻名。</p>
<p><strong>核心问题：旧 API 的缺陷</strong> 1.
<strong>两步分配</strong>：需要先调用 <code>idr_pre_get()</code>
预分配内存（可休眠），再调用 <code>idr_get_new()</code> 获取
ID（可原子上下文）。 2.
<strong>必须重试循环</strong>：<code>idr_get_new()</code>
可能因预分配内存被其他 CPU 耗尽而失败（返回
<code>-EAGAIN</code>），要求调用者编写冗长且易错的循环重试代码。 3.
<strong>全局资源竞争</strong>：<code>idr_pre_get()</code>
预分配的内存是全局的，多个 CPU 竞争时，后执行的
<code>idr_get_new()</code>
可能因资源不足而失败，迫使代码退出原子上下文进行重试，这条路径往往缺乏测试。</p>
<p><strong>解决方案：新 API 的改进</strong> Tejun Heo
引入了三个新函数来简化流程： 1.
<code>idr_preload(gfp_t gfp_mask)</code>: 为<strong>当前 CPU</strong>
预分配内存，并<strong>禁用抢占</strong>以防止预分配的内存被偷。 2.
<code>idr_alloc(...)</code>: <strong>单次调用</strong>即可完成 ID
分配和关联。它接受 ID
范围参数，并仅在真正需要时（未预分配或预分配不足）才使用
<code>gfp_mask</code> 分配内存。它只会在内存分配彻底失败时报错，消除了对
<code>-EAGAIN</code> 的重试循环需求。 3. <code>idr_preload_end()</code>:
在 <code>idr_alloc</code> 后调用，<strong>重新启用抢占</strong>。</p>
<p><strong>关键优势：</strong> *
<strong>更简单</strong>：消除了遍布内核的百余处重复、易错的样板代码。 *
<strong>更可靠</strong>：通过每 CPU
预分配和禁用抢占，基本消除了在原子上下文中因资源竞争而失败的需要。 *
<strong>更灵活</strong>：<code>idr_alloc</code> 可以指定 ID
范围，并且如果能在进程上下文调用，甚至可以完全省略
<code>idr_preload</code>/<code>idr_preload_end</code>。</p>
<p><strong>社区反应：</strong> 尽管大部分开发者接受了这个改动（给出了
Acked-by），但 Eric Biederman 表达了强烈反对，认为新 API 的
<code>idr_preload</code>
像是一种难以理解的“魔法”。然而，文章作者（Jonathan
Corbet）预测，<strong>新 API
带来的巨大简化优势将使其最终被内核社区接受</strong>。</p>
<h3 id="新旧-api-对比总结">新旧 API 对比总结</h3>
<div class="line-block">特性 | 旧 API (2013 年前) | 新 API (Tejun Heo
提议) |<br />
：--- | :--- | :--- |<br />
<strong>核心函数</strong> | <code>idr_pre_get()</code>,
<code>idr_get_new()</code> | <code>idr_preload()</code>,
<code>idr_alloc()</code>, <code>idr_preload_end()</code> |<br />
<strong>调用模式</strong> |
<strong>两步过程</strong>，必须配合<strong>重试循环</strong> |
<strong>单次调用</strong>
(<code>idr_alloc</code>)，<strong>无需循环</strong> |<br />
<strong>预分配内存</strong> | <strong>全局共享</strong>，易被其他 CPU
消耗 | <strong>每 CPU
独享</strong>，配合<strong>禁用抢占</strong>，不会被偷 |<br />
<strong>错误处理</strong> | 可能返回
<code>-EAGAIN</code>，要求调用者重试 | 仅在所有内存分配都失败时才报错
|<br />
<strong>原子上下文</strong> | 支持，但重试时必须退出原子上下文 |
更好支持，通过 <code>preload</code>/<code>preload_end</code> 保障
|<br />
<strong>代码复杂度</strong> | 高，需要大量重复的样板代码 |
低，调用逻辑非常简洁 |</div>
<h3 id="结论">结论</h3>
<p>这篇文章记录了一个经典的内核优化案例：通过巧妙的设计（利用每 CPU
数据和禁用抢占）将一个复杂、易错、充满竞争条件的旧接口，重构为一个简洁、可靠、高效的新接口。尽管存在一些争议，但<strong>简化并提升广泛使用的底层
API
的价值是极其巨大的</strong>，这很可能是新方案最终被采纳的原因。这正是
Linux 内核持续演进的一个缩影。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/19/kamacode36/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/19/kamacode36/" class="post-title-link" itemprop="url">代码随想录 | 刷题-动态规划9</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-20 01:04:53 / 修改时间：01:06:09" itemprop="dateCreated datePublished" datetime="2025-08-20T01:04:53+08:00">2025-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="买卖股票的最佳时机iv">188.买卖股票的最佳时机IV</h3>
<h3 id="最佳买卖股票时机含冷冻期">309.最佳买卖股票时机含冷冻期</h3>
<h3 id="买卖股票的最佳时机含手续费">714.买卖股票的最佳时机含手续费</h3>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/12/oper_sys19/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/12/oper_sys19/" class="post-title-link" itemprop="url">操作系统基础 | 4.5 内核数据结构-内核模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-13 00:14:02" itemprop="dateCreated datePublished" datetime="2025-08-13T00:14:02+08:00">2025-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-16 06:49:37" itemprop="dateModified" datetime="2025-08-16T06:49:37+08:00">2025-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="linux-内核模块开发简介">Linux 内核模块开发简介</h3>
<h4 id="设备类型分类">设备类型分类</h4>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 9%" />
<col style="width: 26%" />
<col style="width: 26%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>缩写</strong></th>
<th><strong>访问方式</strong></th>
<th><strong>典型设备</strong></th>
<th><strong>特殊文件</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>块设备</strong></td>
<td>blkdevs</td>
<td>按块随机访问（支持寻址）</td>
<td>硬盘/SSD/光驱</td>
<td><code>/dev/sda1</code></td>
</tr>
<tr>
<td><strong>字符设备</strong></td>
<td>cdevs</td>
<td>字节流顺序访问</td>
<td>键盘/打印机/伪设备</td>
<td><code>/dev/ttyS0</code></td>
</tr>
<tr>
<td><strong>网络设备</strong></td>
<td>-</td>
<td>套接字API（破坏"一切皆文件"原则）</td>
<td>网卡/无线适配器</td>
<td>无设备节点</td>
</tr>
<tr>
<td><strong>混杂设备</strong></td>
<td>miscdevs</td>
<td>字符设备简化形式</td>
<td>简单专用设备</td>
<td><code>/dev/random</code> 等</td>
</tr>
</tbody>
</table>
<p><strong>伪设备示例</strong>： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/dev/random   <span class="comment"># 内核随机数生成器</span></span><br><span class="line">/dev/null     <span class="comment"># 空设备（丢弃所有写入）</span></span><br><span class="line">/dev/zero     <span class="comment"># 零设备（提供无限\0字节）</span></span><br><span class="line">/dev/full     <span class="comment"># 满设备（写入总返回ENOSPC错误）</span></span><br><span class="line">/dev/mem      <span class="comment"># 物理内存访问设备</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h3 id="内核模块开发">内核模块开发</h3>
<h4 id="hello-world-模块示例">Hello World 模块示例</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模块加载时执行 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;I bear a charmed life.\n&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 返回0表示成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模块卸载时执行 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Out, out, brief candle!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册入口/出口函数 */</span></span><br><span class="line">module_init(hello_init);  <span class="comment">// 不是函数调用，而是宏定义</span></span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模块元信息 */</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);                  <span class="comment">// 必须声明许可证</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Shakespeare&quot;</span>);           <span class="comment">// 作者信息</span></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Hello World Module&quot;</span>); <span class="comment">// 模块描述</span></span><br></pre></td></tr></table></figure>
<h4 id="关键机制解析">关键机制解析</h4>
<ol type="1">
<li><strong>入口函数</strong>：
<ul>
<li>形式：<code>int init_func(void)</code></li>
<li>职责：注册资源/初始化硬件/分配数据结构</li>
<li>返回值：0=成功，非0=失败</li>
</ul></li>
<li><strong>出口函数</strong>：
<ul>
<li>形式：<code>void exit_func(void)</code></li>
<li>职责：释放资源/复位硬件/清理状态</li>
</ul></li>
<li><strong>许可证声明</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);  <span class="comment">// 合法选项：GPL/MIT/BSD等</span></span><br></pre></td></tr></table></figure>
<ul>
<li>非GPL模块会导致内核标记为"tainted"</li>
<li>无法调用GPL-only符号</li>
</ul></li>
</ol>
<hr />
<h3 id="模块构建指南">模块构建指南</h3>
<h4 id="集成到内核源码树推荐">集成到内核源码树（推荐）</h4>
<ol type="1">
<li><strong>选择路径</strong>：
<ul>
<li>字符设备 → <code>drivers/char/</code></li>
<li>块设备 → <code>drivers/block/</code></li>
<li>USB设备 → <code>drivers/usb/</code></li>
</ul></li>
<li><strong>修改Makefile</strong>： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># drivers/char/Makefile 添加</span></span><br><span class="line">obj-<span class="variable">$(CONFIG_FISHING_POLE)</span> += fishing/</span><br><span class="line"></span><br><span class="line"><span class="comment"># drivers/char/fishing/Makefile 内容</span></span><br><span class="line">obj-<span class="variable">$(CONFIG_FISHING_POLE)</span> += fishing.o</span><br><span class="line">fishing-objs := main.o line.o  <span class="comment"># 多文件模块</span></span><br><span class="line">EXTRA_CFLAGS += -DTITANIUM_POLE  <span class="comment"># 自定义编译标志</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="外部独立构建">外部独立构建</h4>
<ol type="1">
<li><p><strong>Makefile示例</strong>： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj-m := fishing.o</span><br><span class="line">fishing-objs := fishing-main.o fishing-line.o</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C /path/to/kernel/source M=<span class="variable">$(PWD)</span> modules</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>构建命令</strong>： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在模块目录执行</span></span><br><span class="line">make -C /lib/modules/$(<span class="built_in">uname</span> -r)/build M=<span class="variable">$PWD</span> modules</span><br></pre></td></tr></table></figure> ### 模块管理</p></li>
</ol>
<h4 id="模块安装路径规范">模块安装路径规范</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标准安装路径模板</span></span><br><span class="line">/lib/modules/$(<span class="built_in">uname</span> -r)/kernel/&lt;源码树路径&gt;/&lt;模块名&gt;.ko</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：2.6.34内核的钓鱼竿模块</span></span><br><span class="line">/lib/modules/2.6.34/kernel/drivers/char/fishing.ko</span><br></pre></td></tr></table></figure>
<p><strong>安装命令</strong>： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make modules_install  <span class="comment"># 需root权限</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h3 id="模块依赖管理">模块依赖管理</h3>
<h4 id="依赖关系生成">1. 依赖关系生成</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成完整依赖关系</span></span><br><span class="line">sudo depmod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增量更新（仅处理新模块）</span></span><br><span class="line">sudo depmod -A</span><br></pre></td></tr></table></figure>
<h4 id="依赖存储位置">2. 依赖存储位置</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依赖关系文件路径</span></span><br><span class="line">/lib/modules/$(<span class="built_in">uname</span> -r)/modules.dep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件内容示例</span></span><br><span class="line">kernel/drivers/char/fishing.ko: kernel/drivers/net/bait.ko</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>智能加载原理</strong>：<br />
当加载 <code>chum.ko</code> 时，系统自动解析其依赖并先加载
<code>bait.ko</code></p>
</blockquote>
<hr />
<h3 id="模块加载与卸载">模块加载与卸载</h3>
<h4 id="基础工具不推荐">基础工具（不推荐）</h4>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 27%" />
<col style="width: 29%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>命令</strong></th>
<th><strong>缺陷</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>加载</td>
<td><code>insmod module.ko</code></td>
<td>无依赖解析</td>
<td><code>insmod fishing.ko</code></td>
</tr>
<tr>
<td>卸载</td>
<td><code>rmmod module_name</code></td>
<td>不检查依赖</td>
<td><code>rmmod fishing</code></td>
</tr>
</tbody>
</table>
<h4 id="高级工具推荐">高级工具（推荐）</h4>
<p><strong>1. 智能加载</strong>： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载模块（自动处理依赖）</span></span><br><span class="line">sudo modprobe fishing pole_length=300 material=titanium</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看加载的模块</span></span><br><span class="line">lsmod | grep fishing</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 安全卸载</strong>： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载模块（自动移除未用依赖）</span></span><br><span class="line">sudo modprobe -r fishing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制卸载（危险！）</span></span><br><span class="line">sudo modprobe -rf fishing  <span class="comment"># 可能破坏依赖树</span></span><br></pre></td></tr></table></figure></p>
<h3 id="内核配置与模块开发高级指南">内核配置与模块开发高级指南</h3>
<h4 id="配置选项管理-kconfig">配置选项管理 (Kconfig)</h4>
<p>linux使用kbuild系统，可以通过修改Kconfig文件便捷地管理配置选项
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># drivers/char/Kconfig 示例</span><br><span class="line">config FISHING_POLE</span><br><span class="line">    tristate &quot;Fish Master 3000 support&quot;  # 三态选项，表示模块在编译配置中可以内置编译到内核（Y），作为模块编译（M）或者不编译（N）</span><br><span class="line">    default n                            # 默认禁用</span><br><span class="line">    depends on FISH_TANK &amp;&amp; !NO_FISHING  # 依赖条件</span><br><span class="line">    select BAIT                          # 强制关联选项</span><br><span class="line">    help                                 # 帮助文档</span><br><span class="line">        Enable support for the Fish Master 3000 computer interface.</span><br><span class="line">        Choose Y to build into kernel, M for module (fishing.ko), or N to disable.</span><br></pre></td></tr></table></figure></p>
<p><strong>核心指令解析</strong>： | <strong>指令</strong> |
<strong>功能</strong> | <strong>示例</strong> |
|----------------|----------------------------------|-----------------------------------|
| <code>tristate</code> | 三态选项 (Y/M/N) | 驱动标准配置 | |
<code>bool</code> | 布尔选项 (Y/N) | 特性开关 | | <code>default</code> |
默认值 | <code>default y</code> 默认启用 | | <code>depends on</code> |
依赖关系 | <code>depends on NET</code> 需网络支持 | |
<code>select</code> | 强制启用其他选项 | <code>select CRC32</code>
自动启用CRC校验 | | <code>if</code> | 条件显示 |
<code>if EMBEDDED</code> 嵌入式场景可见 | | <code>help</code> | 帮助文档
| 用户配置时的说明文本 |</p>
<hr />
<h3 id="模块参数系统">模块参数系统</h3>
<h4 id="基础参数声明">1. 基础参数声明</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> pole_length = <span class="number">200</span>;  <span class="comment">// 默认值</span></span><br><span class="line">module_param(pole_length, <span class="type">int</span>, <span class="number">0644</span>);  <span class="comment">// 整型参数</span></span><br><span class="line">MODULE_PARM_DESC(pole_length, <span class="string">&quot;Pole length in cm&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="高级参数类型">2. 高级参数类型</h4>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 32%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>charp</code></td>
<td>字符串指针</td>
<td><code>module_param(name, charp, 0);</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td>布尔值</td>
<td><code>module_param(enable, bool, 0);</code></td>
</tr>
<tr>
<td><code>module_param_string</code></td>
<td>直接复制到数组</td>
<td><code>char target[32]; module_param_string(dest, target, sizeof(target), 0);</code></td>
</tr>
<tr>
<td><code>module_param_array</code></td>
<td>数组参数</td>
<td><code>int ids[5]; int count; module_param_array(ids, int, &amp;count, 0);</code></td>
</tr>
</tbody>
</table>
<h4 id="参数传递方式">3. 参数传递方式</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载时指定参数</span></span><br><span class="line">sudo modprobe fishing pole_length=300 material=carbon</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看参数信息</span></span><br><span class="line">modinfo fishing</span><br><span class="line">parm:           pole_length:Pole length <span class="keyword">in</span> cm (int)</span><br><span class="line">parm:           material:Construction material (charp)</span><br></pre></td></tr></table></figure>
<h4 id="sysfs集成">4. sysfs集成</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数自动暴露到sysfs</span></span><br><span class="line">/sys/module/fishing/parameters/pole_length  <span class="comment"># 权限0644=rwr--r--</span></span><br></pre></td></tr></table></figure>
<hr />
<h3 id="符号导出机制">符号导出机制</h3>
<h4 id="基础导出">1. 基础导出</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明可被模块调用的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_pole_strength</span><span class="params">(<span class="keyword">struct</span> pole *p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;load_capacity;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(get_pole_strength);  <span class="comment">// 全局导出</span></span><br></pre></td></tr></table></figure>
<h4 id="gpl受限导出">2. GPL受限导出</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPORT_SYMBOL_GPL(calculate_bait_ratio);  <span class="comment">// 仅GPL模块可用</span></span><br></pre></td></tr></table></figure>
<h4 id="导出规则">3. 导出规则</h4>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 35%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr>
<th><strong>导出类型</strong></th>
<th><strong>调用权限</strong></th>
<th><strong>典型场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EXPORT_SYMBOL</code></td>
<td>所有模块</td>
<td>通用内核API</td>
</tr>
<tr>
<td><code>EXPORT_SYMBOL_GPL</code></td>
<td>仅GPL许可证模块</td>
<td>核心子系统接口</td>
</tr>
<tr>
<td>未导出符号</td>
<td>仅内核内部使用</td>
<td>静态函数/私有实现</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="配置系统元选项">配置系统元选项</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">config EXPERIMENTAL</span><br><span class="line">    bool &quot;Enable experimental features&quot;  # 高风险功能开关</span><br><span class="line">    default n</span><br><span class="line"></span><br><span class="line">config DEBUG_KERNEL</span><br><span class="line">    bool &quot;Kernel debugging&quot;  # 调试选项总开关</span><br><span class="line">    default y if DEBUG</span><br></pre></td></tr></table></figure>
<p><strong>关键元选项</strong>： -
<code>CONFIG_EMBEDDED</code>：嵌入式系统优化选项 -
<code>CONFIG_BROKEN_ON_SMP</code>：标记非SMP安全驱动 -
<code>CONFIG_EXPERIMENTAL</code>：实验性功能入口</p>
<hr />
<h3 id="开发工作流示例">开发工作流示例</h3>
<h4 id="添加新驱动">1. 添加新驱动</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建Kconfig</span></span><br><span class="line"><span class="comment"># drivers/char/fishing/Kconfig</span></span><br><span class="line">config FISHING_PRO</span><br><span class="line">    tristate <span class="string">&quot;Professional Fishing Module&quot;</span></span><br><span class="line">    select FISHING_ADVANCED</span><br><span class="line">    <span class="built_in">help</span></span><br><span class="line">      Support <span class="keyword">for</span> professional-grade fishing equipment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改上级Kconfig</span></span><br><span class="line"><span class="comment"># drivers/char/Kconfig</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">&quot;drivers/char/fishing/Kconfig&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="实现参数化模块">2. 实现参数化模块</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> material[<span class="number">20</span>] = <span class="string">&quot;fiberglass&quot;</span>;</span><br><span class="line">module_param_string(material, material, <span class="keyword">sizeof</span>(material), <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lengths[] = &#123;<span class="number">180</span>, <span class="number">240</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> nr_lengths = <span class="number">2</span>;</span><br><span class="line">module_param_array(lengths, <span class="type">int</span>, &amp;nr_lengths, <span class="number">0444</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> enable_ai;</span><br><span class="line">module_param(enable_ai, <span class="type">bool</span>, <span class="number">0644</span>);</span><br></pre></td></tr></table></figure>
<h4 id="编译验证">3. 编译验证</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置内核</span></span><br><span class="line">make menuconfig</span><br><span class="line"><span class="comment"># -&gt; Device Drivers -&gt; Character devices -&gt; Professional Fishing Module (M)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">make -j$(<span class="built_in">nproc</span>) modules</span><br><span class="line">sudo make modules_install</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="生产环境最佳实践">生产环境最佳实践</h3>
<ol type="1">
<li><p><strong>参数安全</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> max_load = <span class="number">100</span>;</span><br><span class="line">module_param(max_load, <span class="type">int</span>, <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_func</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (max_load &gt; MAX_SAFE_LIMIT) &#123;</span><br><span class="line">        pr_warn(<span class="string">&quot;Dangerous load limit %d, capping at %d\n&quot;</span>, </span><br><span class="line">                max_load, MAX_SAFE_LIMIT);</span><br><span class="line">        max_load = MAX_SAFE_LIMIT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>版本兼容</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5,15,0)</span></span><br><span class="line"><span class="comment">// 新版内核API</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// 旧版兼容实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>错误处理</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> err = register_device();</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 彻底回滚初始化</span></span><br><span class="line">    unregister_previous();</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<blockquote>
<p><strong>性能提示</strong>：高频访问的模块参数应复制到局部变量，避免频繁查sysfs</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/12/oper_sys18/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/12/oper_sys18/" class="post-title-link" itemprop="url">操作系统基础 | 4.4 内核数据结构-二叉树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-12 22:25:51" itemprop="dateCreated datePublished" datetime="2025-08-12T22:25:51+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-13 00:13:25" itemprop="dateModified" datetime="2025-08-13T00:13:25+08:00">2025-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="二叉树">二叉树</h3>
<h4 id="二叉搜索树bst核心特性">1. 二叉搜索树（BST）核心特性</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">根节点左子树的所有节点值 &lt; 根节点值</span><br><span class="line">根节点右子树的所有节点值 &gt; 根节点值</span><br><span class="line">所有子树都是二叉搜索树</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>操作复杂度</strong>：
<ul>
<li>查找：O(log n)<br />
</li>
<li>有序遍历：O(n)</li>
</ul></li>
<li><strong>缺陷</strong>：不平衡树可能导致操作退化到O(n)</li>
</ul>
<h4 id="自平衡二叉搜索树">2. 自平衡二叉搜索树</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">叶子节点深度差 ≤ 1   →   树高度 = O(log n)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>平衡机制</strong>：在插入/删除时自动调整结构</li>
<li><strong>常见类型</strong>：
<ul>
<li>AVL树（严格平衡）</li>
<li><strong>红黑树</strong>（半平衡，Linux首选）</li>
</ul></li>
</ul>
<hr />
<h3 id="红黑树red-black-trees">红黑树（Red-Black Trees）</h3>
<h4 id="六大约束条件">六大约束条件</h4>
<ol type="1">
<li>节点非红即黑</li>
<li>叶子节点（NIL）为黑</li>
<li>叶子节点不存储数据</li>
<li>非叶子节点必有双子</li>
<li><strong>红节点的子节点必为黑</strong>（核心约束）</li>
<li>根到任意叶子的黑节点数相同</li>
</ol>
<h4 id="优势">优势</h4>
<ul>
<li>插入/删除只需O(1)次旋转（AVL需O(log n)）</li>
<li>查找效率稳定在O(log n)</li>
<li>内存开销小（仅1bit存储颜色）</li>
</ul>
<hr />
<h3 id="linux实现rbtree">Linux实现（rbtree）</h3>
<h4 id="初始化">初始化</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/rbtree.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">root</span> =</span> RB_ROOT;  <span class="comment">// 声明并初始化根节点</span></span><br></pre></td></tr></table></figure>
<h4 id="节点定义">节点定义</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span>  <span class="comment">// 嵌入红黑树节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="查找实现页缓存示例">查找实现（页缓存示例）</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">rb_search_page_cache</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">unsigned</span> <span class="type">long</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span> =</span> inode-&gt;i_rb_page_cache.rb_node;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> rb_entry(n, <span class="keyword">struct</span> page, rb_page_cache);</span><br><span class="line">        <span class="keyword">if</span> (offset &lt; page-&gt;offset)</span><br><span class="line">            n = n-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (offset &gt; page-&gt;offset)</span><br><span class="line">            n = n-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> page;  <span class="comment">// 命中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 未命中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入实现">插入实现</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">rb_insert_page_cache</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">unsigned</span> <span class="type">long</span> offset, </span></span><br><span class="line"><span class="params">                                  <span class="keyword">struct</span> rb_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> =</span> &amp;inode-&gt;i_rb_page_cache.rb_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 查找插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> rb_entry(parent, <span class="keyword">struct</span> page, rb_page_cache);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (offset &lt; page-&gt;offset)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (offset &gt; page-&gt;offset)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> page;  <span class="comment">// 已存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行插入</span></span><br><span class="line">    rb_link_node(node, parent, p);      <span class="comment">// 链接新节点</span></span><br><span class="line">    rb_insert_color(node, &amp;inode-&gt;i_rb_page_cache);  <span class="comment">// 重平衡</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 插入成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="xarray对比说明">XArray对比说明</h3>
<h4 id="适用场景差异">适用场景差异</h4>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 34%" />
<col style="width: 26%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr>
<th><strong>数据结构</strong></th>
<th><strong>最佳场景</strong></th>
<th><strong>内核应用实例</strong></th>
<th><strong>XArray替代性</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>红黑树</td>
<td>范围查询/有序遍历</td>
<td>进程调度CFS</td>
<td>❌ 不可替代</td>
</tr>
<tr>
<td>XArray</td>
<td>稀疏ID映射/快速点查</td>
<td>页缓存/文件描述符</td>
<td>✅ 专精领域</td>
</tr>
</tbody>
</table>
<h4 id="性能对比">性能对比</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">操作        红黑树        XArray</span><br><span class="line">---------------------------------</span><br><span class="line">插入        O(log n)      O(k)  // k=键长</span><br><span class="line">范围查询     O(log n + m)  O(m)  // m=结果数</span><br><span class="line">内存开销     40字节/节点   8字节/条目</span><br></pre></td></tr></table></figure>
<h4 id="xarray替代红黑树的条件">XArray替代红黑树的条件</h4>
<ol type="1">
<li><strong>键为整数类型</strong>（非复杂比较键）</li>
<li><strong>无需有序遍历</strong></li>
<li><strong>超高并发需求</strong>（XArray内置RCU） <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XArray实现类似功能</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">xa_store</span><span class="params">(<span class="keyword">struct</span> xarray *xa, <span class="type">unsigned</span> <span class="type">long</span> index, <span class="type">void</span> *entry)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">xa_load</span><span class="params">(<span class="keyword">struct</span> xarray *xa, <span class="type">unsigned</span> <span class="type">long</span> index)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr />
<h3 id="关键结论">关键结论</h3>
<ol type="1">
<li><strong>红黑树适用场景</strong>：
<ul>
<li>VFS目录树（<code>dentry</code>缓存）</li>
<li>进程调度器（CFS运行队列）</li>
<li>EPoll事件管理</li>
</ul></li>
<li><strong>XArray优先场景</strong>：
<ul>
<li>文件页缓存（<code>address_space</code>）</li>
<li>内存反向映射</li>
<li>UID到指针映射</li>
</ul></li>
</ol>
<blockquote>
<p><strong>迁移建议</strong>：新代码中整数键映射优先采用XArray；复杂键/范围查询仍需红黑树。<br />
<strong>性能数据</strong>：XArray在ext4文件系统中减少40%缓存操作耗时（内核5.15测试）</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/11/kamacode35/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/11/kamacode35/" class="post-title-link" itemprop="url">代码随想录 | 刷题-动态规划8</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-12 00:46:58" itemprop="dateCreated datePublished" datetime="2025-08-12T00:46:58+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-20 01:04:30" itemprop="dateModified" datetime="2025-08-20T01:04:30+08:00">2025-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="买卖股票的最佳时机">121. 买卖股票的最佳时机</h3>
<p>贪心方法：取最左最小值，取最右最大值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;prices.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((prices[j] - prices[i])&gt;profit)profit = prices[j] - prices[i];</span><br><span class="line">            <span class="keyword">if</span>(prices[j] &lt; prices[i])i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
动态规划方法：每天保存两个数值 - 当天持有股票的最大值 -
第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金
即：dp[i - 1][0] -
第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i] -
当天不持有股票的最大值 -
第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金
即：dp[i - 1][1] -
第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] +
dp[i - 1][0]</p>
<h3 id="买卖股票的最佳时机ii">122.买卖股票的最佳时机II</h3>
<p>尝试一下动态规划方法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printdp</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i: dp)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j: i)&#123;</span><br><span class="line">                cout&lt;&lt;j&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// printdp(dp);</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i], dp[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printdp(dp);</span></span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="买卖股票的最佳时机iii">123.买卖股票的最佳时机III</h3>
<p>为什么“选择两个最大的上升区间”这种解决方式不正确：
由于交易次数限制，并不是所有上升区间都需要被单独考虑。有时一笔交易可能覆盖多个上升区间</p>
<p>本题建议使用动态规划，推导四个状态： - 第一次持有股票 -
第一次不持有股票 - 第二次持有股票 - 第二次不持有股票 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i], dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i], dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i], dp[i<span class="number">-1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">3</span>]+prices[i], dp[i<span class="number">-1</span>][<span class="number">4</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/08/oper_sys17/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/08/oper_sys17/" class="post-title-link" itemprop="url">操作系统基础 | 4.3 内核数据结构-映射</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-09 02:01:45" itemprop="dateCreated datePublished" datetime="2025-08-09T02:01:45+08:00">2025-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-11 00:18:43" itemprop="dateModified" datetime="2025-08-11T00:18:43+08:00">2025-08-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="映射maps">映射（Maps）</h3>
<h4 id="基本概念">基本概念</h4>
<p>映射（又称关联数组）是由唯一键组成的集合，每个键关联一个特定值。键与值的关系称为<strong>映射关系</strong>，支持以下基本操作：<br />
- <strong>添加</strong>（Add）：插入键值对<br />
- <strong>移除</strong>（Remove）：删除指定键<br />
- <strong>查找</strong>（Lookup）：通过键获取值</p>
<p>尽管哈希表是一种映射实现，但并非所有映射都基于哈希。映射也可使用<strong>自平衡二叉搜索树</strong>存储数据：<br />
-
<strong>哈希表</strong>：平均时间复杂度更优（O(1)），但最坏情况为线性（O(n)）<br />
- <strong>二叉搜索树</strong>：最坏情况为对数复杂度（O(log
n)），且支持有序遍历，无需哈希函数（仅需定义比较操作符）</p>
<p>在Linux内核中，映射的特定实现称为<code>idr</code>（ID Radix
Tree-旧版实现，现为XArray），专用于将唯一ID（UID）映射到指针。</p>
<hr />
<h4 id="初始化idr">初始化idr</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/idr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">id_huh</span>;</span>       <span class="comment">// 静态定义  </span></span><br><span class="line">idr_init(&amp;id_huh);      <span class="comment">// 初始化  </span></span><br></pre></td></tr></table></figure>
<hr />
<h4 id="分配uid">分配UID</h4>
<h5 id="预分配资源">1. 预分配资源</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">idr_pre_get</span><span class="params">(<span class="keyword">struct</span> idr *idp, <span class="type">gfp_t</span> gfp_mask)</span>;  </span><br><span class="line">```  </span><br><span class="line">- **功能**：必要时调整底层树结构，准备分配新UID  </span><br><span class="line">- **参数**：  </span><br><span class="line">  - `idp`：目标idr结构  </span><br><span class="line">  - `gfp_mask`：内存分配标志（如`GFP_KERNEL`）  </span><br><span class="line">- **返回值**：成功返回<span class="number">1</span>，失败返回<span class="number">0</span>（与其他内核函数相反！）  </span><br><span class="line"></span><br><span class="line">##### <span class="number">2.</span> 分配UID并关联指针  </span><br><span class="line">```c</span><br><span class="line"><span class="type">int</span> <span class="title function_">idr_get_new</span><span class="params">(<span class="keyword">struct</span> idr *idp, <span class="type">void</span> *ptr, <span class="type">int</span> *id)</span>;  </span><br><span class="line">```  </span><br><span class="line">- **功能**：分配新UID，将其与`ptr`关联  </span><br><span class="line">- **返回值**：  </span><br><span class="line">  - 成功：返回<span class="number">0</span>，UID存储在`id`中  </span><br><span class="line">  - 失败：返回`-EAGAIN`（需重试`idr_pre_get`）或`-ENOSPC`（idr已满）  </span><br><span class="line"></span><br><span class="line">##### 示例：分配UID  </span><br><span class="line">```c</span><br><span class="line"><span class="type">int</span> id, ret;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!idr_pre_get(&amp;id_huh, GFP_KERNEL)) </span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">    ret = idr_get_new(&amp;id_huh, ptr, &amp;id); </span><br><span class="line">&#125; <span class="keyword">while</span> (ret == -EAGAIN);</span><br></pre></td></tr></table></figure>
<h5 id="分配指定最小uid">分配指定最小UID</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">idr_get_new_above</span><span class="params">(<span class="keyword">struct</span> idr *idp, <span class="type">void</span> *ptr, <span class="type">int</span> starting_id, <span class="type">int</span> *id)</span>;  </span><br><span class="line">```  </span><br><span class="line">- **功能**：分配不小于`starting_id`的UID，确保UID单调递增  </span><br><span class="line">```c</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> next_id = <span class="number">1</span>;  <span class="comment">// 全局计数器</span></span><br><span class="line"><span class="keyword">if</span> (!idr_get_new_above(&amp;id_huh, ptr, next_id, &amp;id))</span><br><span class="line">    next_id = id + <span class="number">1</span>;    <span class="comment">// 更新下一个起始ID  </span></span><br></pre></td></tr></table></figure>
<h5 id="xarray方式-linux-4.2以后">XArray方式 (Linux 4.2以后)</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 原子分配 (无需预分配) */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">xa_alloc</span><span class="params">(<span class="keyword">struct</span> xarray *xa, <span class="type">unsigned</span> <span class="type">int</span> *id, </span></span><br><span class="line"><span class="params">             <span class="type">void</span> *entry, <span class="keyword">struct</span> xa_limit limit, <span class="type">gfp_t</span> gfp)</span>;</span><br><span class="line"><span class="comment">/* 分配递增ID示例 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> next_id = <span class="number">1</span>;</span><br><span class="line">xa_alloc(&amp;xa_huh, &amp;next_id, ptr, XA_LIMIT(next_id, UINT_MAX), GFP_KERNEL);</span><br><span class="line"><span class="comment">// 成功后 next_id 自动递增</span></span><br></pre></td></tr></table></figure>
<hr />
<h4 id="查找与删除">查找与删除</h4>
<h5 id="查找uid">查找UID</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">idr_find</span><span class="params">(<span class="keyword">struct</span> idr *idp, <span class="type">int</span> id)</span>;  </span><br><span class="line">```  </span><br><span class="line">- **返回值**：成功返回关联指针，失败返回`<span class="literal">NULL</span>`  </span><br><span class="line">- **注意**：在分配UID时，禁止将`<span class="literal">NULL</span>`作为有效idr值映射，否则无法区分查找失败与有效`<span class="literal">NULL</span>`  </span><br><span class="line"></span><br><span class="line">##### 移除UID  </span><br><span class="line">```c</span><br><span class="line"><span class="type">void</span> <span class="title function_">idr_remove</span><span class="params">(<span class="keyword">struct</span> idr *idp, <span class="type">int</span> id)</span>;  </span><br><span class="line">```  </span><br><span class="line">- **注意**：无错误返回值，需调用者确保UID存在  </span><br><span class="line"></span><br><span class="line">##### XArray方式</span><br><span class="line">```c</span><br><span class="line"><span class="comment">/* 查找 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">xa_load</span><span class="params">(<span class="keyword">struct</span> xarray *xa, <span class="type">unsigned</span> <span class="type">long</span> index)</span>;</span><br><span class="line"><span class="comment">/* 删除并返回删除项 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">xa_erase</span><span class="params">(<span class="keyword">struct</span> xarray *xa, <span class="type">unsigned</span> <span class="type">long</span> index)</span>;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="销毁">销毁</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">idr_destroy</span><span class="params">(<span class="keyword">struct</span> idr *idp)</span>;                  <span class="comment">// 释放未使用内存  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">idr_remove_all</span><span class="params">(<span class="keyword">struct</span> idr *idp)</span>;               <span class="comment">// 强制移除所有UID  </span></span><br><span class="line">```  </span><br><span class="line">**典型流程**：  </span><br><span class="line">```c</span><br><span class="line"><span class="title function_">idr_remove_all</span><span class="params">(&amp;id_huh)</span>;  <span class="comment">// 先清空所有映射  </span></span><br><span class="line">idr_destroy(&amp;id_huh);     <span class="comment">// 再释放内存，确保所有idr内存被释放  </span></span><br><span class="line">kfree(user_data_ptr);  <span class="comment">// 释放实际业务数据</span></span><br></pre></td></tr></table></figure>
<h5 id="xarray方式">XArray方式</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 销毁并释放所有资源 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">xa_destroy</span><span class="params">(<span class="keyword">struct</span> xarray *xa)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 安全销毁流程示例 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="type">void</span> *entry;</span><br><span class="line">    <span class="comment">// 遍历释放关联资源</span></span><br><span class="line">    xa_for_each(&amp;xa_huh, id, entry) &#123;</span><br><span class="line">        xa_erase(&amp;xa_huh, id);</span><br><span class="line">        kfree(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    xa_destroy(&amp;xa_huh); <span class="comment">// 释放XArray管理内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="关键注意事项">关键注意事项</h4>
<ol type="1">
<li><strong>并发控制</strong>：
<ul>
<li><code>idr_pre_get</code>无需加锁<br />
</li>
<li><code>idr_get_new</code>等操作需自旋锁保护（参见第9/10章）</li>
</ul></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/zh-CN/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/zh-CN/page/10/">10</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/zh-CN/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
  <div class="languages">
    <label class="lang-select-label">
      <i class="fa fa-language"></i>
      <span>简体中文</span>
      <i class="fa fa-angle-up" aria-hidden="true"></i>
    </label>
    <select class="lang-select" data-canonical="" aria-label="选择语言">
      
        <option value="zh-CN" data-href="/index.html" selected="">
          简体中文
        </option>
      
        <option value="en" data-href="/en/index.html" selected="">
          English
        </option>
      
    </select>
  </div>

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Mackz-Maxw</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
