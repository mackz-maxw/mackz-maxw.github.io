<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mackz-maxw.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="乘上燃犀船，还未曾去过倒悬山。">
<meta property="og:type" content="website">
<meta property="og:title" content="Maxw的小站">
<meta property="og:url" content="https://mackz-maxw.github.io/zh-CN/page/3/index.html">
<meta property="og:site_name" content="Maxw的小站">
<meta property="og:description" content="乘上燃犀船，还未曾去过倒悬山。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mackz-Maxw">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://mackz-maxw.github.io/zh-CN/page/3/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"zh-CN/page/3/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Maxw的小站</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Maxw的小站" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Maxw的小站</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Maxw学习记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Mackz-Maxw</p>
  <div class="site-description" itemprop="description">乘上燃犀船，还未曾去过倒悬山。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">109</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/mackz-maxw" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mackz-maxw" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/19/oper_sys21lab_kMod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/19/oper_sys21lab_kMod/" class="post-title-link" itemprop="url">操作系统基础 | 4.7 内核模块实验</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-20 01:15:49" itemprop="dateCreated datePublished" datetime="2025-08-20T01:15:49+08:00">2025-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-21 00:31:13" itemprop="dateModified" datetime="2025-08-21T00:31:13+08:00">2025-08-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/lab/" itemprop="url" rel="index"><span itemprop="name">lab</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="可加载的内核模块">可加载的内核模块</h3>
<h4 id="练习-1">练习 1</h4>
<p>准备好实验报告</p>
<hr />
<h4 id="练习-2-编译内核模块">练习 2: 编译内核模块</h4>
<ol type="1">
<li><strong>步骤</strong>: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在 Linux Lab 集群上</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /project/scratch01/compile/your-username/modules</span><br><span class="line"><span class="built_in">cd</span> /project/scratch01/compile/your-username/modules</span><br><span class="line"><span class="comment"># 保存 simple_module.c 和 Makefile (内容: obj-m := simple_module.o)</span></span><br><span class="line">module add arm-rpi</span><br><span class="line"><span class="built_in">export</span> LINUX_SOURCE=/path/to/your/linux_source/linux <span class="comment"># 设置内核源码路径</span></span><br><span class="line">make -C <span class="variable">$LINUX_SOURCE</span> ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- M=<span class="variable">$PWD</span> modules</span><br></pre></td></tr></table></figure></li>
<li><strong>答案</strong>: 提交 <code>make</code> 命令的完整输出。</li>
</ol>
<hr />
<h4 id="练习-3-加载模块与系统日志">练习 3: 加载模块与系统日志</h4>
<ol type="1">
<li><strong>步骤</strong> (在树莓派上): <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/modules</span><br><span class="line"><span class="comment"># 使用 sftp 将 simple_module.ko 传输到此目录</span></span><br><span class="line">sudo dmesg --clear</span><br><span class="line">sudo insmod ~/modules/simple_module.ko</span><br><span class="line">dmesg <span class="comment"># 查看日志</span></span><br></pre></td></tr></table></figure></li>
<li><strong>答案</strong>: 提交 <code>dmesg</code>
中显示的模块加载信息。</li>
</ol>
<hr />
<h4 id="练习-4-验证模块列表与卸载">练习 4: 验证模块列表与卸载</h4>
<ol type="1">
<li><strong>步骤</strong>: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsmod <span class="comment"># 确认 simple_module 在列表中</span></span><br><span class="line">sudo rmmod simple_module</span><br><span class="line">lsmod <span class="comment"># 确认已移除</span></span><br><span class="line">dmesg <span class="comment"># 查看卸载信息</span></span><br></pre></td></tr></table></figure></li>
<li><strong>答案</strong>: 提交 <code>lsmod</code>
的输出（证明已卸载）和 <code>dmesg</code> 中显示的模块卸载信息。</li>
</ol>
<hr />
<h4 id="练习-5-访问内核变量-jiffies">练习 5: 访问内核变量 jiffies</h4>
<ol type="1">
<li><strong>步骤</strong>:
<ul>
<li>复制 <code>simple_module.c</code> 为
<code>jiffies_module.c</code>。</li>
<li>修改其 init 和 exit 函数，使用 <code>printk</code> 打印
<code>jiffies</code> 变量（类型
<code>extern unsigned long volatile jiffies;</code>）。</li>
<li>更新 Makefile: <code>obj-m += jiffies_module.o</code>。</li>
<li>重新编译并传输 <code>jiffies_module.ko</code> 到树莓派。</li>
<li>加载并卸载模块，观察 <code>dmesg</code>。</li>
</ul></li>
<li><strong>答案</strong>:
<ul>
<li>提交 <code>dmesg</code> 中显示加载和卸载时 <code>jiffies</code>
值的日志消息。</li>
<li>计算并说明两条消息之间发生的滴答数（tick count）。</li>
</ul></li>
</ol>
<hr />
<h3 id="需提交的内容">需提交的内容</h3>
<p>请提交一个包含以下内容的压缩包或文档： 1. <strong>答案文件</strong>:
包含上述所有练习的答案。 2. <strong>源代码文件</strong>: 你新创建的
<code>jiffies_module.c</code> 文件。</p>
<hr />
<h3 id="可选拓展练习">可选拓展练习</h3>
<h4 id="练习-6-模块初始化返回值实验">练习 6: 模块初始化返回值实验</h4>
<ul>
<li><strong>任务</strong>: 修改 init
函数，使其分别返回正数和负数（错误码，参见
<code>/include/uapi/asm-generic/errno-base.h</code>）。</li>
<li><strong>提示</strong>:
描述加载模块时发生的情况及其在系统日志中的表现。</li>
</ul>
<h4 id="练习-7-探查导出的内核符号">练习 7: 探查导出的内核符号</h4>
<ul>
<li><strong>任务</strong>: 查看 <code>/proc/kallsyms</code> 文件（例如
<code>cat /proc/kallsyms</code>），了解内核符号表。查找带有
<code>__kstrtab_</code> 和 <code>__ksymtab_</code>
前缀的符号（这些是可供模块使用的导出符号）。</li>
<li><strong>提示</strong>: 内核符号是 Linux
内核代码中定义的函数、变量、数据结构等的名称标签。它们代表了在内核地址空间中的一个特定内存地址。
可以将内核符号理解为内核的“公共接口”或“入口点”。主要有两种类型：</li>
<li>导出的符号：这些是内核明确声明为可以被外部模块使用的符号。例如，printk（内核的
printf）、kmalloc（内核的内存分配函数）等。模块通过使用 EXPORT_SYMBOL()
或 EXPORT_SYMBOL_GPL() 宏来导出它们的符号，以便其他模块可以使用。</li>
<li>非导出的符号：这些是内核内部的静态函数或变量，只在它们被定义的文件或内核的特定部分中使用。它们对于内核模块是不可见的，主要用于内核自身的组织</li>
<li>EXPORT_SYMBOL(printk) 在编译后创建了两个内部符号：__ksymtab_printk
和 __kstrtab_printk。
<ul>
<li>__ksymtab_printk 是一个结构体，包含了 printk 的地址和指向
__kstrtab_printk 的指针。</li>
<li>__kstrtab_printk 是一个字符串，存储着 printk 的名字。</li>
</ul></li>
<li>内核使用这个结构来高效地通过名字查找函数的地址</li>
</ul>
<h4 id="练习-8-实现用户态读取-cpu-周期计数器-ccnt-的模块">练习 8:
实现用户态读取 CPU 周期计数器 (CCNT) 的模块</h4>
<ul>
<li><strong>任务</strong> (如果之前在系统调用工作室未完成):
<ul>
<li>将提供的驱动文件放入你的内核源码树的
<code>arch/arm/include/asm</code> 目录。</li>
<li>下载 <code>enable_ccnt.c</code> 内核模块代码到你的模块目录。</li>
<li>编译、传输并加载此模块 (<code>insmod enable_ccnt.ko</code>)。</li>
<li>使用 <code>dmesg | tail</code> 验证加载成功。</li>
</ul></li>
<li><strong>任务</strong> (主要部分):
<ul>
<li>在树莓派上创建一个用户态程序。</li>
<li>该程序应 <code>#include</code> 你获取的驱动头文件。</li>
<li>调用 <code>unsigned long long pmccntr_get(void)</code>
函数两次。</li>
</ul></li>
<li><strong>答案</strong>:
<ul>
<li>说明运行一次 <code>pmccntr_get()</code> 函数大约需要多少 CPU
周期（计算两次调用的差值）。</li>
<li>如果你在系统调用工作室完成过类似的练习，请对比直接调用此函数与通过系统调用获取周期计数所需的周期数。</li>
</ul></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/19/oper_sys20rebuildIDRApi/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/19/oper_sys20rebuildIDRApi/" class="post-title-link" itemprop="url">操作系统基础 | 4.6 内核API重构案例：IDR API</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-20 01:07:16 / 修改时间：01:11:57" itemprop="dateCreated datePublished" datetime="2025-08-20T01:07:16+08:00">2025-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>文章内容来自 LWN.net</p>
<h3 id="文章摘要-summary">文章摘要 (Summary)</h3>
<p>这篇发表于 2013 年 2 月的文章讨论了 Linux 内核中 <strong>IDR 子系统
API 的一次重大简化改革</strong>，由开发者 Tejun Heo 主导。IDR
机制用于高效分配和管理整数 ID（例如设备名、POSIX 定时器 ID 等），其旧
API 因其复杂性和潜在的竞争条件而闻名。</p>
<p><strong>核心问题：旧 API 的缺陷</strong> 1.
<strong>两步分配</strong>：需要先调用 <code>idr_pre_get()</code>
预分配内存（可休眠），再调用 <code>idr_get_new()</code> 获取
ID（可原子上下文）。 2.
<strong>必须重试循环</strong>：<code>idr_get_new()</code>
可能因预分配内存被其他 CPU 耗尽而失败（返回
<code>-EAGAIN</code>），要求调用者编写冗长且易错的循环重试代码。 3.
<strong>全局资源竞争</strong>：<code>idr_pre_get()</code>
预分配的内存是全局的，多个 CPU 竞争时，后执行的
<code>idr_get_new()</code>
可能因资源不足而失败，迫使代码退出原子上下文进行重试，这条路径往往缺乏测试。</p>
<p><strong>解决方案：新 API 的改进</strong> Tejun Heo
引入了三个新函数来简化流程： 1.
<code>idr_preload(gfp_t gfp_mask)</code>: 为<strong>当前 CPU</strong>
预分配内存，并<strong>禁用抢占</strong>以防止预分配的内存被偷。 2.
<code>idr_alloc(...)</code>: <strong>单次调用</strong>即可完成 ID
分配和关联。它接受 ID
范围参数，并仅在真正需要时（未预分配或预分配不足）才使用
<code>gfp_mask</code> 分配内存。它只会在内存分配彻底失败时报错，消除了对
<code>-EAGAIN</code> 的重试循环需求。 3. <code>idr_preload_end()</code>:
在 <code>idr_alloc</code> 后调用，<strong>重新启用抢占</strong>。</p>
<p><strong>关键优势：</strong> *
<strong>更简单</strong>：消除了遍布内核的百余处重复、易错的样板代码。 *
<strong>更可靠</strong>：通过每 CPU
预分配和禁用抢占，基本消除了在原子上下文中因资源竞争而失败的需要。 *
<strong>更灵活</strong>：<code>idr_alloc</code> 可以指定 ID
范围，并且如果能在进程上下文调用，甚至可以完全省略
<code>idr_preload</code>/<code>idr_preload_end</code>。</p>
<p><strong>社区反应：</strong> 尽管大部分开发者接受了这个改动（给出了
Acked-by），但 Eric Biederman 表达了强烈反对，认为新 API 的
<code>idr_preload</code>
像是一种难以理解的“魔法”。然而，文章作者（Jonathan
Corbet）预测，<strong>新 API
带来的巨大简化优势将使其最终被内核社区接受</strong>。</p>
<h3 id="新旧-api-对比总结">新旧 API 对比总结</h3>
<div class="line-block">特性 | 旧 API (2013 年前) | 新 API (Tejun Heo
提议) |<br />
：--- | :--- | :--- |<br />
<strong>核心函数</strong> | <code>idr_pre_get()</code>,
<code>idr_get_new()</code> | <code>idr_preload()</code>,
<code>idr_alloc()</code>, <code>idr_preload_end()</code> |<br />
<strong>调用模式</strong> |
<strong>两步过程</strong>，必须配合<strong>重试循环</strong> |
<strong>单次调用</strong>
(<code>idr_alloc</code>)，<strong>无需循环</strong> |<br />
<strong>预分配内存</strong> | <strong>全局共享</strong>，易被其他 CPU
消耗 | <strong>每 CPU
独享</strong>，配合<strong>禁用抢占</strong>，不会被偷 |<br />
<strong>错误处理</strong> | 可能返回
<code>-EAGAIN</code>，要求调用者重试 | 仅在所有内存分配都失败时才报错
|<br />
<strong>原子上下文</strong> | 支持，但重试时必须退出原子上下文 |
更好支持，通过 <code>preload</code>/<code>preload_end</code> 保障
|<br />
<strong>代码复杂度</strong> | 高，需要大量重复的样板代码 |
低，调用逻辑非常简洁 |</div>
<h3 id="结论">结论</h3>
<p>这篇文章记录了一个经典的内核优化案例：通过巧妙的设计（利用每 CPU
数据和禁用抢占）将一个复杂、易错、充满竞争条件的旧接口，重构为一个简洁、可靠、高效的新接口。尽管存在一些争议，但<strong>简化并提升广泛使用的底层
API
的价值是极其巨大的</strong>，这很可能是新方案最终被采纳的原因。这正是
Linux 内核持续演进的一个缩影。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/19/kamacode36stock2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/19/kamacode36stock2/" class="post-title-link" itemprop="url">代码随想录 | 刷题-动态规划9</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-20 01:04:53" itemprop="dateCreated datePublished" datetime="2025-08-20T01:04:53+08:00">2025-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-10 01:03:01" itemprop="dateModified" datetime="2025-09-10T01:03:01+08:00">2025-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="买卖股票的最佳时机iv">188.买卖股票的最佳时机IV</h3>
<p>买卖股票三的扩展版，从最多两次交易扩充到k次交易。注意买入和卖出某个数量的股票都要单列一列dp，并采用不同的状态转移方式。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>*k+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;=<span class="number">2</span>*k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">1</span>)dp[<span class="number">0</span>][i] -= prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;=<span class="number">2</span>*k; j+=<span class="number">2</span>)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>] - prices[i], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j&lt;=<span class="number">2</span>*k; j+=<span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// printf(&quot;index of prices: %d, sold out stock id: %d\n&quot;, i, j);</span></span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + prices[i], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">2</span>*k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="最佳买卖股票时机含冷冻期">309.最佳买卖股票时机含冷冻期</h3>
<p>我这道题还是写复杂了。其实不规定买入次数，就不需要每次买卖都开一个状态了，每天都计算持有/非持有状态即可，还可以省空间复杂度
我采用的思路延续了每次买入都有两个不同状态的方案，当计算卖出的时候往前比较两天，就是需要注意第二天持有股票状态的递推公式的特殊情况（选择第二天买入还是第一天买入）。其实采用仅四个状态也可以：
状态一：持有股票状态（今天买入股票，或者是之前就买入了股票然后没有操作，一直持有）
不持有股票状态，这里就有两种卖出股票状态 -
状态二：保持卖出股票的状态（两天前就卖出了股票，度过一天冷冻期。或者是前一天就是卖出股票状态，一直没操作）
- 状态三：今天卖出股票
状态四：今天为冷冻期状态，但冷冻期状态不可持续，只有一天！
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> status = prices.<span class="built_in">size</span>()*<span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(status+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= status; i += <span class="number">2</span>)&#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] -= prices[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= status; j += <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">// printf(&quot;prices: %d, hold stock cnt: %d\n&quot;, i, j);</span></span><br><span class="line">                <span class="keyword">if</span>(i &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-2</span>][j<span class="number">-1</span>] - prices[i], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(-prices[i], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">2</span>; j &lt;= status; j += <span class="number">2</span>)&#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + prices[i], dp[i<span class="number">-1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(auto l: dp)&#123;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;&quot;prices line &quot;;</span></span><br><span class="line">        <span class="comment">//     for(auto i: l)&#123;</span></span><br><span class="line">        <span class="comment">//         cout&lt;&lt;i&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][status];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="买卖股票的最佳时机含手续费">714.买卖股票的最佳时机含手续费</h3>
<p>这题延续 <em>122.买卖股票的最佳时机II</em> 的思路即可
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices, <span class="type">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> status = prices.<span class="built_in">size</span>()*<span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt; prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i]-fee, dp[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i], dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(int i = 0; i&lt;dp.size(); i++)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int j = 0; j&lt;dp[0].size(); j++)&#123;</span></span><br><span class="line">        <span class="comment">//         cout&lt;&lt;dp[i][j]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/12/oper_sys19kernelMod/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/12/oper_sys19kernelMod/" class="post-title-link" itemprop="url">操作系统基础 | 4.5 内核数据结构-内核模块</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-13 00:14:02" itemprop="dateCreated datePublished" datetime="2025-08-13T00:14:02+08:00">2025-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-16 06:49:37" itemprop="dateModified" datetime="2025-08-16T06:49:37+08:00">2025-08-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="linux-内核模块开发简介">Linux 内核模块开发简介</h3>
<h4 id="设备类型分类">设备类型分类</h4>
<table>
<colgroup>
<col style="width: 15%" />
<col style="width: 9%" />
<col style="width: 26%" />
<col style="width: 26%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>缩写</strong></th>
<th><strong>访问方式</strong></th>
<th><strong>典型设备</strong></th>
<th><strong>特殊文件</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>块设备</strong></td>
<td>blkdevs</td>
<td>按块随机访问（支持寻址）</td>
<td>硬盘/SSD/光驱</td>
<td><code>/dev/sda1</code></td>
</tr>
<tr>
<td><strong>字符设备</strong></td>
<td>cdevs</td>
<td>字节流顺序访问</td>
<td>键盘/打印机/伪设备</td>
<td><code>/dev/ttyS0</code></td>
</tr>
<tr>
<td><strong>网络设备</strong></td>
<td>-</td>
<td>套接字API（破坏"一切皆文件"原则）</td>
<td>网卡/无线适配器</td>
<td>无设备节点</td>
</tr>
<tr>
<td><strong>混杂设备</strong></td>
<td>miscdevs</td>
<td>字符设备简化形式</td>
<td>简单专用设备</td>
<td><code>/dev/random</code> 等</td>
</tr>
</tbody>
</table>
<p><strong>伪设备示例</strong>： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/dev/random   <span class="comment"># 内核随机数生成器</span></span><br><span class="line">/dev/null     <span class="comment"># 空设备（丢弃所有写入）</span></span><br><span class="line">/dev/zero     <span class="comment"># 零设备（提供无限\0字节）</span></span><br><span class="line">/dev/full     <span class="comment"># 满设备（写入总返回ENOSPC错误）</span></span><br><span class="line">/dev/mem      <span class="comment"># 物理内存访问设备</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h3 id="内核模块开发">内核模块开发</h3>
<h4 id="hello-world-模块示例">Hello World 模块示例</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模块加载时执行 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;I bear a charmed life.\n&quot;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 返回0表示成功</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模块卸载时执行 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span> </span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;Out, out, brief candle!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册入口/出口函数 */</span></span><br><span class="line">module_init(hello_init);  <span class="comment">// 不是函数调用，而是宏定义</span></span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 模块元信息 */</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);                  <span class="comment">// 必须声明许可证</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Shakespeare&quot;</span>);           <span class="comment">// 作者信息</span></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;Hello World Module&quot;</span>); <span class="comment">// 模块描述</span></span><br></pre></td></tr></table></figure>
<h4 id="关键机制解析">关键机制解析</h4>
<ol type="1">
<li><strong>入口函数</strong>：
<ul>
<li>形式：<code>int init_func(void)</code></li>
<li>职责：注册资源/初始化硬件/分配数据结构</li>
<li>返回值：0=成功，非0=失败</li>
</ul></li>
<li><strong>出口函数</strong>：
<ul>
<li>形式：<code>void exit_func(void)</code></li>
<li>职责：释放资源/复位硬件/清理状态</li>
</ul></li>
<li><strong>许可证声明</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);  <span class="comment">// 合法选项：GPL/MIT/BSD等</span></span><br></pre></td></tr></table></figure>
<ul>
<li>非GPL模块会导致内核标记为"tainted"</li>
<li>无法调用GPL-only符号</li>
</ul></li>
</ol>
<hr />
<h3 id="模块构建指南">模块构建指南</h3>
<h4 id="集成到内核源码树推荐">集成到内核源码树（推荐）</h4>
<ol type="1">
<li><strong>选择路径</strong>：
<ul>
<li>字符设备 → <code>drivers/char/</code></li>
<li>块设备 → <code>drivers/block/</code></li>
<li>USB设备 → <code>drivers/usb/</code></li>
</ul></li>
<li><strong>修改Makefile</strong>： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># drivers/char/Makefile 添加</span></span><br><span class="line">obj-<span class="variable">$(CONFIG_FISHING_POLE)</span> += fishing/</span><br><span class="line"></span><br><span class="line"><span class="comment"># drivers/char/fishing/Makefile 内容</span></span><br><span class="line">obj-<span class="variable">$(CONFIG_FISHING_POLE)</span> += fishing.o</span><br><span class="line">fishing-objs := main.o line.o  <span class="comment"># 多文件模块</span></span><br><span class="line">EXTRA_CFLAGS += -DTITANIUM_POLE  <span class="comment"># 自定义编译标志</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="外部独立构建">外部独立构建</h4>
<ol type="1">
<li><p><strong>Makefile示例</strong>： <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj-m := fishing.o</span><br><span class="line">fishing-objs := fishing-main.o fishing-line.o</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    make -C /path/to/kernel/source M=<span class="variable">$(PWD)</span> modules</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>构建命令</strong>： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在模块目录执行</span></span><br><span class="line">make -C /lib/modules/$(<span class="built_in">uname</span> -r)/build M=<span class="variable">$PWD</span> modules</span><br></pre></td></tr></table></figure> ### 模块管理</p></li>
</ol>
<h4 id="模块安装路径规范">模块安装路径规范</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 标准安装路径模板</span></span><br><span class="line">/lib/modules/$(<span class="built_in">uname</span> -r)/kernel/&lt;源码树路径&gt;/&lt;模块名&gt;.ko</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例：2.6.34内核的钓鱼竿模块</span></span><br><span class="line">/lib/modules/2.6.34/kernel/drivers/char/fishing.ko</span><br></pre></td></tr></table></figure>
<p><strong>安装命令</strong>： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo make modules_install  <span class="comment"># 需root权限</span></span><br></pre></td></tr></table></figure></p>
<hr />
<h3 id="模块依赖管理">模块依赖管理</h3>
<h4 id="依赖关系生成">1. 依赖关系生成</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成完整依赖关系</span></span><br><span class="line">sudo depmod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增量更新（仅处理新模块）</span></span><br><span class="line">sudo depmod -A</span><br></pre></td></tr></table></figure>
<h4 id="依赖存储位置">2. 依赖存储位置</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依赖关系文件路径</span></span><br><span class="line">/lib/modules/$(<span class="built_in">uname</span> -r)/modules.dep</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件内容示例</span></span><br><span class="line">kernel/drivers/char/fishing.ko: kernel/drivers/net/bait.ko</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>智能加载原理</strong>：<br />
当加载 <code>chum.ko</code> 时，系统自动解析其依赖并先加载
<code>bait.ko</code></p>
</blockquote>
<hr />
<h3 id="模块加载与卸载">模块加载与卸载</h3>
<h4 id="基础工具不推荐">基础工具（不推荐）</h4>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 27%" />
<col style="width: 29%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>命令</strong></th>
<th><strong>缺陷</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>加载</td>
<td><code>insmod module.ko</code></td>
<td>无依赖解析</td>
<td><code>insmod fishing.ko</code></td>
</tr>
<tr>
<td>卸载</td>
<td><code>rmmod module_name</code></td>
<td>不检查依赖</td>
<td><code>rmmod fishing</code></td>
</tr>
</tbody>
</table>
<h4 id="高级工具推荐">高级工具（推荐）</h4>
<p><strong>1. 智能加载</strong>： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载模块（自动处理依赖）</span></span><br><span class="line">sudo modprobe fishing pole_length=300 material=titanium</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看加载的模块</span></span><br><span class="line">lsmod | grep fishing</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 安全卸载</strong>： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 卸载模块（自动移除未用依赖）</span></span><br><span class="line">sudo modprobe -r fishing</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制卸载（危险！）</span></span><br><span class="line">sudo modprobe -rf fishing  <span class="comment"># 可能破坏依赖树</span></span><br></pre></td></tr></table></figure></p>
<h3 id="内核配置与模块开发高级指南">内核配置与模块开发高级指南</h3>
<h4 id="配置选项管理-kconfig">配置选项管理 (Kconfig)</h4>
<p>linux使用kbuild系统，可以通过修改Kconfig文件便捷地管理配置选项
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># drivers/char/Kconfig 示例</span><br><span class="line">config FISHING_POLE</span><br><span class="line">    tristate &quot;Fish Master 3000 support&quot;  # 三态选项，表示模块在编译配置中可以内置编译到内核（Y），作为模块编译（M）或者不编译（N）</span><br><span class="line">    default n                            # 默认禁用</span><br><span class="line">    depends on FISH_TANK &amp;&amp; !NO_FISHING  # 依赖条件</span><br><span class="line">    select BAIT                          # 强制关联选项</span><br><span class="line">    help                                 # 帮助文档</span><br><span class="line">        Enable support for the Fish Master 3000 computer interface.</span><br><span class="line">        Choose Y to build into kernel, M for module (fishing.ko), or N to disable.</span><br></pre></td></tr></table></figure></p>
<p><strong>核心指令解析</strong>： | <strong>指令</strong> |
<strong>功能</strong> | <strong>示例</strong> |
|----------------|----------------------------------|-----------------------------------|
| <code>tristate</code> | 三态选项 (Y/M/N) | 驱动标准配置 | |
<code>bool</code> | 布尔选项 (Y/N) | 特性开关 | | <code>default</code> |
默认值 | <code>default y</code> 默认启用 | | <code>depends on</code> |
依赖关系 | <code>depends on NET</code> 需网络支持 | |
<code>select</code> | 强制启用其他选项 | <code>select CRC32</code>
自动启用CRC校验 | | <code>if</code> | 条件显示 |
<code>if EMBEDDED</code> 嵌入式场景可见 | | <code>help</code> | 帮助文档
| 用户配置时的说明文本 |</p>
<hr />
<h3 id="模块参数系统">模块参数系统</h3>
<h4 id="基础参数声明">1. 基础参数声明</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> pole_length = <span class="number">200</span>;  <span class="comment">// 默认值</span></span><br><span class="line">module_param(pole_length, <span class="type">int</span>, <span class="number">0644</span>);  <span class="comment">// 整型参数</span></span><br><span class="line">MODULE_PARM_DESC(pole_length, <span class="string">&quot;Pole length in cm&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="高级参数类型">2. 高级参数类型</h4>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 32%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>charp</code></td>
<td>字符串指针</td>
<td><code>module_param(name, charp, 0);</code></td>
</tr>
<tr>
<td><code>bool</code></td>
<td>布尔值</td>
<td><code>module_param(enable, bool, 0);</code></td>
</tr>
<tr>
<td><code>module_param_string</code></td>
<td>直接复制到数组</td>
<td><code>char target[32]; module_param_string(dest, target, sizeof(target), 0);</code></td>
</tr>
<tr>
<td><code>module_param_array</code></td>
<td>数组参数</td>
<td><code>int ids[5]; int count; module_param_array(ids, int, &amp;count, 0);</code></td>
</tr>
</tbody>
</table>
<h4 id="参数传递方式">3. 参数传递方式</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载时指定参数</span></span><br><span class="line">sudo modprobe fishing pole_length=300 material=carbon</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看参数信息</span></span><br><span class="line">modinfo fishing</span><br><span class="line">parm:           pole_length:Pole length <span class="keyword">in</span> cm (int)</span><br><span class="line">parm:           material:Construction material (charp)</span><br></pre></td></tr></table></figure>
<h4 id="sysfs集成">4. sysfs集成</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数自动暴露到sysfs</span></span><br><span class="line">/sys/module/fishing/parameters/pole_length  <span class="comment"># 权限0644=rwr--r--</span></span><br></pre></td></tr></table></figure>
<hr />
<h3 id="符号导出机制">符号导出机制</h3>
<h4 id="基础导出">1. 基础导出</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明可被模块调用的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_pole_strength</span><span class="params">(<span class="keyword">struct</span> pole *p)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> p-&gt;load_capacity;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(get_pole_strength);  <span class="comment">// 全局导出</span></span><br></pre></td></tr></table></figure>
<h4 id="gpl受限导出">2. GPL受限导出</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPORT_SYMBOL_GPL(calculate_bait_ratio);  <span class="comment">// 仅GPL模块可用</span></span><br></pre></td></tr></table></figure>
<h4 id="导出规则">3. 导出规则</h4>
<table>
<colgroup>
<col style="width: 29%" />
<col style="width: 35%" />
<col style="width: 35%" />
</colgroup>
<thead>
<tr>
<th><strong>导出类型</strong></th>
<th><strong>调用权限</strong></th>
<th><strong>典型场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EXPORT_SYMBOL</code></td>
<td>所有模块</td>
<td>通用内核API</td>
</tr>
<tr>
<td><code>EXPORT_SYMBOL_GPL</code></td>
<td>仅GPL许可证模块</td>
<td>核心子系统接口</td>
</tr>
<tr>
<td>未导出符号</td>
<td>仅内核内部使用</td>
<td>静态函数/私有实现</td>
</tr>
</tbody>
</table>
<hr />
<h3 id="配置系统元选项">配置系统元选项</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">config EXPERIMENTAL</span><br><span class="line">    bool &quot;Enable experimental features&quot;  # 高风险功能开关</span><br><span class="line">    default n</span><br><span class="line"></span><br><span class="line">config DEBUG_KERNEL</span><br><span class="line">    bool &quot;Kernel debugging&quot;  # 调试选项总开关</span><br><span class="line">    default y if DEBUG</span><br></pre></td></tr></table></figure>
<p><strong>关键元选项</strong>： -
<code>CONFIG_EMBEDDED</code>：嵌入式系统优化选项 -
<code>CONFIG_BROKEN_ON_SMP</code>：标记非SMP安全驱动 -
<code>CONFIG_EXPERIMENTAL</code>：实验性功能入口</p>
<hr />
<h3 id="开发工作流示例">开发工作流示例</h3>
<h4 id="添加新驱动">1. 添加新驱动</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建Kconfig</span></span><br><span class="line"><span class="comment"># drivers/char/fishing/Kconfig</span></span><br><span class="line">config FISHING_PRO</span><br><span class="line">    tristate <span class="string">&quot;Professional Fishing Module&quot;</span></span><br><span class="line">    select FISHING_ADVANCED</span><br><span class="line">    <span class="built_in">help</span></span><br><span class="line">      Support <span class="keyword">for</span> professional-grade fishing equipment</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改上级Kconfig</span></span><br><span class="line"><span class="comment"># drivers/char/Kconfig</span></span><br><span class="line"><span class="built_in">source</span> <span class="string">&quot;drivers/char/fishing/Kconfig&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="实现参数化模块">2. 实现参数化模块</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/moduleparam.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> material[<span class="number">20</span>] = <span class="string">&quot;fiberglass&quot;</span>;</span><br><span class="line">module_param_string(material, material, <span class="keyword">sizeof</span>(material), <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> lengths[] = &#123;<span class="number">180</span>, <span class="number">240</span>&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> nr_lengths = <span class="number">2</span>;</span><br><span class="line">module_param_array(lengths, <span class="type">int</span>, &amp;nr_lengths, <span class="number">0444</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bool</span> enable_ai;</span><br><span class="line">module_param(enable_ai, <span class="type">bool</span>, <span class="number">0644</span>);</span><br></pre></td></tr></table></figure>
<h4 id="编译验证">3. 编译验证</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置内核</span></span><br><span class="line">make menuconfig</span><br><span class="line"><span class="comment"># -&gt; Device Drivers -&gt; Character devices -&gt; Professional Fishing Module (M)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装</span></span><br><span class="line">make -j$(<span class="built_in">nproc</span>) modules</span><br><span class="line">sudo make modules_install</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="生产环境最佳实践">生产环境最佳实践</h3>
<ol type="1">
<li><p><strong>参数安全</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> max_load = <span class="number">100</span>;</span><br><span class="line">module_param(max_load, <span class="type">int</span>, <span class="number">0644</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">init_func</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (max_load &gt; MAX_SAFE_LIMIT) &#123;</span><br><span class="line">        pr_warn(<span class="string">&quot;Dangerous load limit %d, capping at %d\n&quot;</span>, </span><br><span class="line">                max_load, MAX_SAFE_LIMIT);</span><br><span class="line">        max_load = MAX_SAFE_LIMIT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>版本兼容</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/version.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> LINUX_VERSION_CODE &gt;= KERNEL_VERSION(5,15,0)</span></span><br><span class="line"><span class="comment">// 新版内核API</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="comment">// 旧版兼容实现</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>错误处理</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> err = register_device();</span><br><span class="line"><span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// 彻底回滚初始化</span></span><br><span class="line">    unregister_previous();</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ol>
<blockquote>
<p><strong>性能提示</strong>：高频访问的模块参数应复制到局部变量，避免频繁查sysfs</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/12/oper_sys18btree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/12/oper_sys18btree/" class="post-title-link" itemprop="url">操作系统基础 | 4.4 内核数据结构-二叉树</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-12 22:25:51" itemprop="dateCreated datePublished" datetime="2025-08-12T22:25:51+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-13 00:13:25" itemprop="dateModified" datetime="2025-08-13T00:13:25+08:00">2025-08-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="二叉树">二叉树</h3>
<h4 id="二叉搜索树bst核心特性">1. 二叉搜索树（BST）核心特性</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">根节点左子树的所有节点值 &lt; 根节点值</span><br><span class="line">根节点右子树的所有节点值 &gt; 根节点值</span><br><span class="line">所有子树都是二叉搜索树</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>操作复杂度</strong>：
<ul>
<li>查找：O(log n)<br />
</li>
<li>有序遍历：O(n)</li>
</ul></li>
<li><strong>缺陷</strong>：不平衡树可能导致操作退化到O(n)</li>
</ul>
<h4 id="自平衡二叉搜索树">2. 自平衡二叉搜索树</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">叶子节点深度差 ≤ 1   →   树高度 = O(log n)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>平衡机制</strong>：在插入/删除时自动调整结构</li>
<li><strong>常见类型</strong>：
<ul>
<li>AVL树（严格平衡）</li>
<li><strong>红黑树</strong>（半平衡，Linux首选）</li>
</ul></li>
</ul>
<hr />
<h3 id="红黑树red-black-trees">红黑树（Red-Black Trees）</h3>
<h4 id="六大约束条件">六大约束条件</h4>
<ol type="1">
<li>节点非红即黑</li>
<li>叶子节点（NIL）为黑</li>
<li>叶子节点不存储数据</li>
<li>非叶子节点必有双子</li>
<li><strong>红节点的子节点必为黑</strong>（核心约束）</li>
<li>根到任意叶子的黑节点数相同</li>
</ol>
<h4 id="优势">优势</h4>
<ul>
<li>插入/删除只需O(1)次旋转（AVL需O(log n)）</li>
<li>查找效率稳定在O(log n)</li>
<li>内存开销小（仅1bit存储颜色）</li>
</ul>
<hr />
<h3 id="linux实现rbtree">Linux实现（rbtree）</h3>
<h4 id="初始化">初始化</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/rbtree.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">root</span> =</span> RB_ROOT;  <span class="comment">// 声明并初始化根节点</span></span><br></pre></td></tr></table></figure>
<h4 id="节点定义">节点定义</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">my_node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span>  <span class="comment">// 嵌入红黑树节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="查找实现页缓存示例">查找实现（页缓存示例）</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">rb_search_page_cache</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">unsigned</span> <span class="type">long</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span> =</span> inode-&gt;i_rb_page_cache.rb_node;</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> rb_entry(n, <span class="keyword">struct</span> page, rb_page_cache);</span><br><span class="line">        <span class="keyword">if</span> (offset &lt; page-&gt;offset)</span><br><span class="line">            n = n-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (offset &gt; page-&gt;offset)</span><br><span class="line">            n = n-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> page;  <span class="comment">// 命中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 未命中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入实现">插入实现</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">rb_insert_page_cache</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="type">unsigned</span> <span class="type">long</span> offset, </span></span><br><span class="line"><span class="params">                                  <span class="keyword">struct</span> rb_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> =</span> &amp;inode-&gt;i_rb_page_cache.rb_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 查找插入位置</span></span><br><span class="line">    <span class="keyword">while</span> (*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> rb_entry(parent, <span class="keyword">struct</span> page, rb_page_cache);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (offset &lt; page-&gt;offset)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (offset &gt; page-&gt;offset)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> page;  <span class="comment">// 已存在</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行插入</span></span><br><span class="line">    rb_link_node(node, parent, p);      <span class="comment">// 链接新节点</span></span><br><span class="line">    rb_insert_color(node, &amp;inode-&gt;i_rb_page_cache);  <span class="comment">// 重平衡</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 插入成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h3 id="xarray对比说明">XArray对比说明</h3>
<h4 id="适用场景差异">适用场景差异</h4>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 34%" />
<col style="width: 26%" />
<col style="width: 21%" />
</colgroup>
<thead>
<tr>
<th><strong>数据结构</strong></th>
<th><strong>最佳场景</strong></th>
<th><strong>内核应用实例</strong></th>
<th><strong>XArray替代性</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>红黑树</td>
<td>范围查询/有序遍历</td>
<td>进程调度CFS</td>
<td>❌ 不可替代</td>
</tr>
<tr>
<td>XArray</td>
<td>稀疏ID映射/快速点查</td>
<td>页缓存/文件描述符</td>
<td>✅ 专精领域</td>
</tr>
</tbody>
</table>
<h4 id="性能对比">性能对比</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">操作        红黑树        XArray</span><br><span class="line">---------------------------------</span><br><span class="line">插入        O(log n)      O(k)  // k=键长</span><br><span class="line">范围查询     O(log n + m)  O(m)  // m=结果数</span><br><span class="line">内存开销     40字节/节点   8字节/条目</span><br></pre></td></tr></table></figure>
<h4 id="xarray替代红黑树的条件">XArray替代红黑树的条件</h4>
<ol type="1">
<li><strong>键为整数类型</strong>（非复杂比较键）</li>
<li><strong>无需有序遍历</strong></li>
<li><strong>超高并发需求</strong>（XArray内置RCU） <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XArray实现类似功能</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">xa_store</span><span class="params">(<span class="keyword">struct</span> xarray *xa, <span class="type">unsigned</span> <span class="type">long</span> index, <span class="type">void</span> *entry)</span>;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">xa_load</span><span class="params">(<span class="keyword">struct</span> xarray *xa, <span class="type">unsigned</span> <span class="type">long</span> index)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr />
<h3 id="关键结论">关键结论</h3>
<ol type="1">
<li><strong>红黑树适用场景</strong>：
<ul>
<li>VFS目录树（<code>dentry</code>缓存）</li>
<li>进程调度器（CFS运行队列）</li>
<li>EPoll事件管理</li>
</ul></li>
<li><strong>XArray优先场景</strong>：
<ul>
<li>文件页缓存（<code>address_space</code>）</li>
<li>内存反向映射</li>
<li>UID到指针映射</li>
</ul></li>
</ol>
<blockquote>
<p><strong>迁移建议</strong>：新代码中整数键映射优先采用XArray；复杂键/范围查询仍需红黑树。<br />
<strong>性能数据</strong>：XArray在ext4文件系统中减少40%缓存操作耗时（内核5.15测试）</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/11/kamacode35stock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/11/kamacode35stock/" class="post-title-link" itemprop="url">代码随想录 | 刷题-动态规划8</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-12 00:46:58" itemprop="dateCreated datePublished" datetime="2025-08-12T00:46:58+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-20 01:04:30" itemprop="dateModified" datetime="2025-08-20T01:04:30+08:00">2025-08-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="买卖股票的最佳时机">121. 买卖股票的最佳时机</h3>
<p>贪心方法：取最左最小值，取最右最大值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j&lt;prices.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((prices[j] - prices[i])&gt;profit)profit = prices[j] - prices[i];</span><br><span class="line">            <span class="keyword">if</span>(prices[j] &lt; prices[i])i = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
动态规划方法：每天保存两个数值 - 当天持有股票的最大值 -
第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金
即：dp[i - 1][0] -
第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i] -
当天不持有股票的最大值 -
第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金
即：dp[i - 1][1] -
第i天卖出股票，所得现金就是按照今天股票价格卖出后所得现金即：prices[i] +
dp[i - 1][0]</p>
<h3 id="买卖股票的最佳时机ii">122.买卖股票的最佳时机II</h3>
<p>尝试一下动态规划方法 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printdp</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i: dp)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> j: i)&#123;</span><br><span class="line">                cout&lt;&lt;j&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// printdp(dp);</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i], dp[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// printdp(dp);</span></span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="买卖股票的最佳时机iii">123.买卖股票的最佳时机III</h3>
<p>为什么“选择两个最大的上升区间”这种解决方式不正确：
由于交易次数限制，并不是所有上升区间都需要被单独考虑。有时一笔交易可能覆盖多个上升区间</p>
<p>本题建议使用动态规划，推导四个状态： - 第一次持有股票 -
第一次不持有股票 - 第二次持有股票 - 第二次不持有股票 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(prices.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">5</span>, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">3</span>] -= prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;prices.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>]-prices[i], dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>]+prices[i], dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>]-prices[i], dp[i<span class="number">-1</span>][<span class="number">3</span>]);</span><br><span class="line">            dp[i][<span class="number">4</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">3</span>]+prices[i], dp[i<span class="number">-1</span>][<span class="number">4</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[prices.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">4</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/08/oper_sys17%E6%98%A0%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/08/oper_sys17%E6%98%A0%E5%B0%84/" class="post-title-link" itemprop="url">操作系统基础 | 4.3 内核数据结构-映射</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-09 02:01:45" itemprop="dateCreated datePublished" datetime="2025-08-09T02:01:45+08:00">2025-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-11 00:18:43" itemprop="dateModified" datetime="2025-08-11T00:18:43+08:00">2025-08-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="映射maps">映射（Maps）</h3>
<h4 id="基本概念">基本概念</h4>
<p>映射（又称关联数组）是由唯一键组成的集合，每个键关联一个特定值。键与值的关系称为<strong>映射关系</strong>，支持以下基本操作：<br />
- <strong>添加</strong>（Add）：插入键值对<br />
- <strong>移除</strong>（Remove）：删除指定键<br />
- <strong>查找</strong>（Lookup）：通过键获取值</p>
<p>尽管哈希表是一种映射实现，但并非所有映射都基于哈希。映射也可使用<strong>自平衡二叉搜索树</strong>存储数据：<br />
-
<strong>哈希表</strong>：平均时间复杂度更优（O(1)），但最坏情况为线性（O(n)）<br />
- <strong>二叉搜索树</strong>：最坏情况为对数复杂度（O(log
n)），且支持有序遍历，无需哈希函数（仅需定义比较操作符）</p>
<p>在Linux内核中，映射的特定实现称为<code>idr</code>（ID Radix
Tree-旧版实现，现为XArray），专用于将唯一ID（UID）映射到指针。</p>
<hr />
<h4 id="初始化idr">初始化idr</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/idr.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">id_huh</span>;</span>       <span class="comment">// 静态定义  </span></span><br><span class="line">idr_init(&amp;id_huh);      <span class="comment">// 初始化  </span></span><br></pre></td></tr></table></figure>
<hr />
<h4 id="分配uid">分配UID</h4>
<h5 id="预分配资源">1. 预分配资源</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">idr_pre_get</span><span class="params">(<span class="keyword">struct</span> idr *idp, <span class="type">gfp_t</span> gfp_mask)</span>;  </span><br><span class="line">```  </span><br><span class="line">- **功能**：必要时调整底层树结构，准备分配新UID  </span><br><span class="line">- **参数**：  </span><br><span class="line">  - `idp`：目标idr结构  </span><br><span class="line">  - `gfp_mask`：内存分配标志（如`GFP_KERNEL`）  </span><br><span class="line">- **返回值**：成功返回<span class="number">1</span>，失败返回<span class="number">0</span>（与其他内核函数相反！）  </span><br><span class="line"></span><br><span class="line">##### <span class="number">2.</span> 分配UID并关联指针  </span><br><span class="line">```c</span><br><span class="line"><span class="type">int</span> <span class="title function_">idr_get_new</span><span class="params">(<span class="keyword">struct</span> idr *idp, <span class="type">void</span> *ptr, <span class="type">int</span> *id)</span>;  </span><br><span class="line">```  </span><br><span class="line">- **功能**：分配新UID，将其与`ptr`关联  </span><br><span class="line">- **返回值**：  </span><br><span class="line">  - 成功：返回<span class="number">0</span>，UID存储在`id`中  </span><br><span class="line">  - 失败：返回`-EAGAIN`（需重试`idr_pre_get`）或`-ENOSPC`（idr已满）  </span><br><span class="line"></span><br><span class="line">##### 示例：分配UID  </span><br><span class="line">```c</span><br><span class="line"><span class="type">int</span> id, ret;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!idr_pre_get(&amp;id_huh, GFP_KERNEL)) </span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">    ret = idr_get_new(&amp;id_huh, ptr, &amp;id); </span><br><span class="line">&#125; <span class="keyword">while</span> (ret == -EAGAIN);</span><br></pre></td></tr></table></figure>
<h5 id="分配指定最小uid">分配指定最小UID</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">idr_get_new_above</span><span class="params">(<span class="keyword">struct</span> idr *idp, <span class="type">void</span> *ptr, <span class="type">int</span> starting_id, <span class="type">int</span> *id)</span>;  </span><br><span class="line">```  </span><br><span class="line">- **功能**：分配不小于`starting_id`的UID，确保UID单调递增  </span><br><span class="line">```c</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> next_id = <span class="number">1</span>;  <span class="comment">// 全局计数器</span></span><br><span class="line"><span class="keyword">if</span> (!idr_get_new_above(&amp;id_huh, ptr, next_id, &amp;id))</span><br><span class="line">    next_id = id + <span class="number">1</span>;    <span class="comment">// 更新下一个起始ID  </span></span><br></pre></td></tr></table></figure>
<h5 id="xarray方式-linux-4.2以后">XArray方式 (Linux 4.2以后)</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 原子分配 (无需预分配) */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">xa_alloc</span><span class="params">(<span class="keyword">struct</span> xarray *xa, <span class="type">unsigned</span> <span class="type">int</span> *id, </span></span><br><span class="line"><span class="params">             <span class="type">void</span> *entry, <span class="keyword">struct</span> xa_limit limit, <span class="type">gfp_t</span> gfp)</span>;</span><br><span class="line"><span class="comment">/* 分配递增ID示例 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> next_id = <span class="number">1</span>;</span><br><span class="line">xa_alloc(&amp;xa_huh, &amp;next_id, ptr, XA_LIMIT(next_id, UINT_MAX), GFP_KERNEL);</span><br><span class="line"><span class="comment">// 成功后 next_id 自动递增</span></span><br></pre></td></tr></table></figure>
<hr />
<h4 id="查找与删除">查找与删除</h4>
<h5 id="查找uid">查找UID</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">idr_find</span><span class="params">(<span class="keyword">struct</span> idr *idp, <span class="type">int</span> id)</span>;  </span><br><span class="line">```  </span><br><span class="line">- **返回值**：成功返回关联指针，失败返回`<span class="literal">NULL</span>`  </span><br><span class="line">- **注意**：在分配UID时，禁止将`<span class="literal">NULL</span>`作为有效idr值映射，否则无法区分查找失败与有效`<span class="literal">NULL</span>`  </span><br><span class="line"></span><br><span class="line">##### 移除UID  </span><br><span class="line">```c</span><br><span class="line"><span class="type">void</span> <span class="title function_">idr_remove</span><span class="params">(<span class="keyword">struct</span> idr *idp, <span class="type">int</span> id)</span>;  </span><br><span class="line">```  </span><br><span class="line">- **注意**：无错误返回值，需调用者确保UID存在  </span><br><span class="line"></span><br><span class="line">##### XArray方式</span><br><span class="line">```c</span><br><span class="line"><span class="comment">/* 查找 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">xa_load</span><span class="params">(<span class="keyword">struct</span> xarray *xa, <span class="type">unsigned</span> <span class="type">long</span> index)</span>;</span><br><span class="line"><span class="comment">/* 删除并返回删除项 */</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">xa_erase</span><span class="params">(<span class="keyword">struct</span> xarray *xa, <span class="type">unsigned</span> <span class="type">long</span> index)</span>;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="销毁">销毁</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">idr_destroy</span><span class="params">(<span class="keyword">struct</span> idr *idp)</span>;                  <span class="comment">// 释放未使用内存  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">idr_remove_all</span><span class="params">(<span class="keyword">struct</span> idr *idp)</span>;               <span class="comment">// 强制移除所有UID  </span></span><br><span class="line">```  </span><br><span class="line">**典型流程**：  </span><br><span class="line">```c</span><br><span class="line"><span class="title function_">idr_remove_all</span><span class="params">(&amp;id_huh)</span>;  <span class="comment">// 先清空所有映射  </span></span><br><span class="line">idr_destroy(&amp;id_huh);     <span class="comment">// 再释放内存，确保所有idr内存被释放  </span></span><br><span class="line">kfree(user_data_ptr);  <span class="comment">// 释放实际业务数据</span></span><br></pre></td></tr></table></figure>
<h5 id="xarray方式">XArray方式</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 销毁并释放所有资源 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">xa_destroy</span><span class="params">(<span class="keyword">struct</span> xarray *xa)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 安全销毁流程示例 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">module_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> id;</span><br><span class="line">    <span class="type">void</span> *entry;</span><br><span class="line">    <span class="comment">// 遍历释放关联资源</span></span><br><span class="line">    xa_for_each(&amp;xa_huh, id, entry) &#123;</span><br><span class="line">        xa_erase(&amp;xa_huh, id);</span><br><span class="line">        kfree(entry);</span><br><span class="line">    &#125;</span><br><span class="line">    xa_destroy(&amp;xa_huh); <span class="comment">// 释放XArray管理内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h4 id="关键注意事项">关键注意事项</h4>
<ol type="1">
<li><strong>并发控制</strong>：
<ul>
<li><code>idr_pre_get</code>无需加锁<br />
</li>
<li><code>idr_get_new</code>等操作需自旋锁保护（参见第9/10章）</li>
</ul></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/07/oper_sys16%E9%98%9F%E5%88%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/07/oper_sys16%E9%98%9F%E5%88%97/" class="post-title-link" itemprop="url">操作系统基础 | 4.2 内核数据结构-队列</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-08 00:28:10" itemprop="dateCreated datePublished" datetime="2025-08-08T00:28:10+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-09 00:28:09" itemprop="dateModified" datetime="2025-08-09T00:28:09+08:00">2025-08-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="队列">队列</h3>
<p>任何操作系统内核中常见的编程模式是<strong>生产者与消费者</strong>。实现此模式的最简单方式通常是使用队列，即<strong>先进先出</strong>（FIFO）。</p>
<p>Linux内核的通用队列实现称为<code>kfifo</code>，代码位于<code>kernel/kfifo.c</code>，头文件为<code>&lt;linux/kfifo.h&gt;</code>。本节讨论2.6.33版本更新后的API（早期版本用法略有不同，编写代码前请确认头文件）。</p>
<hr />
<h4 id="kfifo">kfifo</h4>
<p>Linux的<code>kfifo</code>与其他队列抽象类似，提供两个核心操作：<br />
- <strong>入队</strong>（<code>in</code>）：将数据写入队列<br />
- <strong>出队</strong>（<code>out</code>）：从队列中读取数据</p>
<p><code>kfifo</code>对象维护两个偏移量：<br />
- <strong>in偏移量</strong>：下一次入队的起始位置<br />
- <strong>out偏移量</strong>：下一次出队的起始位置</p>
<p><strong>规则</strong>：<br />
1.
<code>out</code>偏移量始终≤<code>in</code>偏移量（否则会读取未入队的数据）。<br />
2. 当<code>out == in</code>时，队列为空（无法出队）。<br />
3. 当<code>in</code>到达队列末尾时，需重置队列才能继续入队。</p>
<hr />
<h4 id="创建队列">创建队列</h4>
<h5 id="动态初始化常用">动态初始化（常用）</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kfifo_alloc</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo, <span class="type">unsigned</span> <span class="type">int</span> size, <span class="type">gfp_t</span> gfp_mask)</span>;</span><br><span class="line">```  </span><br><span class="line">- **功能**：分配大小为`size`字节的队列（`size`必须为<span class="number">2</span>的幂次），内存分配标志为`gfp_mask`（参见第<span class="number">12</span>章“内存管理”）。  </span><br><span class="line">- **返回值**：成功返回`<span class="number">0</span>`，失败返回错误码。  </span><br><span class="line">- **示例**：  </span><br><span class="line">  ```c</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> <span class="title">fifo</span>;</span></span><br><span class="line">  <span class="type">int</span> ret = kfifo_alloc(&amp;fifo, PAGE_SIZE, GFP_KERNEL);</span><br><span class="line">  <span class="keyword">if</span> (ret)</span><br><span class="line">      <span class="keyword">return</span> ret; <span class="comment">// 初始化失败</span></span><br></pre></td></tr></table></figure>
<h5 id="自定义缓冲区">自定义缓冲区</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfifo_init</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo, <span class="type">void</span> *buffer, <span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br><span class="line">```  </span><br><span class="line">- **功能**：使用用户提供的`buffer`初始化队列，`size`必须为<span class="number">2</span>的幂次。  </span><br><span class="line"></span><br><span class="line">##### 静态声明（较少用）  </span><br><span class="line">```c</span><br><span class="line"><span class="title function_">DECLARE_KFIFO</span><span class="params">(name, size)</span>;  <span class="comment">// 声明队列</span></span><br><span class="line">INIT_KFIFO(name);           <span class="comment">// 初始化队列</span></span><br><span class="line">```  </span><br><span class="line">- **要求**：`size`必须为<span class="number">2</span>的幂次。  </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 数据入队  </span><br><span class="line">```c</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_in</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo, <span class="type">const</span> <span class="type">void</span> *from, <span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br><span class="line">```  </span><br><span class="line">- **功能**：从`from`复制`len`字节到队列`fifo`。  </span><br><span class="line">- **返回值**：实际入队的字节数（若空间不足，可能小于`len`）。  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 数据出队  </span><br><span class="line">##### 标准出队  </span><br><span class="line">```c</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_out</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo, <span class="type">void</span> *to, <span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br><span class="line">```  </span><br><span class="line">- **功能**：从队列`fifo`复制最多`len`字节到`to`缓冲区。  </span><br><span class="line">- **返回值**：实际出队的字节数。  </span><br><span class="line">- **注意**：出队后数据不再保留在队列中。  </span><br><span class="line"></span><br><span class="line">##### 查看数据（不删除）  </span><br><span class="line">```c</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_out_peek</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo, <span class="type">void</span> *to, <span class="type">unsigned</span> <span class="type">int</span> len, <span class="type">unsigned</span> offset)</span>;</span><br><span class="line">```  </span><br><span class="line">- **功能**：与`kfifo_out`类似，但**不移动out偏移量**，数据仍可后续读取。  </span><br><span class="line">- **参数**：`offset`指定队列中的起始位置（<span class="number">0</span>表示队头）。  </span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">#### 获取队列信息</span><br><span class="line"><span class="number">1.</span> **获取队列总容量**</span><br><span class="line">```c</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_size</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回队列底层缓冲区的总字节数</li>
</ul>
<ol start="2" type="1">
<li><strong>获取已入队数据量</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_len</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>返回当前队列中已存储的字节数</li>
<li>（注：内核命名存在不一致性，需特别注意）</li>
</ul>
<ol start="3" type="1">
<li><strong>获取剩余空间</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_avail</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>返回可继续写入的剩余字节数</li>
</ul>
<ol start="4" type="1">
<li><strong>队列状态检查</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">kfifo_is_empty</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">kfifo_is_full</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>返回非零值表示队列为空/满</li>
<li>返回零表示非空/非满</li>
</ul>
<h4 id="重置与销毁队列">重置与销毁队列</h4>
<ol type="1">
<li><strong>重置队列</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">kfifo_reset</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>清空队列所有内容（不释放内存）</li>
</ul>
<ol start="2" type="1">
<li><strong>销毁动态分配的队列</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfifo_free</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>释放通过<code>kfifo_alloc()</code>创建的队列</li>
<li>注意：使用<code>kfifo_init()</code>创建的队列需手动释放关联缓冲区</li>
</ul>
<h4 id="实际应用示例">实际应用示例</h4>
<p>创建8KB大小的kfifo队列： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kfifo.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> <span class="title">my_fifo</span>;</span>  <span class="comment">// 声明 kfifo 结构体</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"><span class="comment">// 分配 8KB 队列</span></span><br><span class="line">ret = kfifo_alloc(&amp;my_fifo, <span class="number">8192</span>, GFP_KERNEL);  <span class="comment">// 8192 = 8 * 1024</span></span><br><span class="line"><span class="keyword">if</span> (ret) &#123;</span><br><span class="line">    pr_err(<span class="string">&quot;Failed to allocate kfifo: error %d\n&quot;</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 验证大小</span></span><br><span class="line">pr_info(<span class="string">&quot;Created FIFO size: %u bytes\n&quot;</span>, kfifo_size(&amp;my_fifo));  <span class="comment">// 输出 8192</span></span><br></pre></td></tr></table></figure> &gt; 队列总容量 = 8 KB = 8 ×
1024 字节 = 8192 字节（环形缓冲区无需减一） &gt;
<code>unsigned int</code>大小 = 4
字节（也可能是8字节，可以通过<code>sizeof(unsigned int)</code>获取）
&gt; 这样一个队列最多可以容纳8192 字节 / 4 字节 = 2048
个<code>unsigned int</code></p>
<p><strong>入队操作</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 入队0-31的整数 */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    kfifo_in(fifo, &amp;i, <span class="keyword">sizeof</span>(i));</span><br></pre></td></tr></table></figure></p>
<p><strong>查看队首元素（不移除）</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line"><span class="type">int</span> ret = kfifo_out_peek(fifo, &amp;val, <span class="keyword">sizeof</span>(val), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="keyword">sizeof</span>(val))</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;</span><br><span class="line">printk(KERN_INFO <span class="string">&quot;%u\n&quot;</span>, val); <span class="comment">/* 输出: 0 */</span></span><br></pre></td></tr></table></figure></p>
<p><strong>完整出队操作</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (kfifo_avail(fifo)) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> ret = kfifo_out(fifo, &amp;val, <span class="keyword">sizeof</span>(val));</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="keyword">sizeof</span>(val))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    printk(KERN_INFO <span class="string">&quot;%u\n&quot;</span>, val); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出: 0 1 2 ... 31 (严格保持FIFO顺序) */</span></span><br></pre></td></tr></table></figure> -
输出顺序为0→31证明是标准的FIFO队列 - 若输出为31→0则变为栈结构（LIFO） -
所有操作均保持原子性，适合生产者-消费者场景
（注：实际开发中通常入队复杂结构体而非基础类型）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/06/oper_sys15%E9%93%BE%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/06/oper_sys15%E9%93%BE%E8%A1%A8/" class="post-title-link" itemprop="url">操作系统基础 | 4.1 内核数据结构-链表</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-07 00:30:09" itemprop="dateCreated datePublished" datetime="2025-08-07T00:30:09+08:00">2025-08-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-08 00:27:55" itemprop="dateModified" datetime="2025-08-08T00:27:55+08:00">2025-08-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="链表linked-lists">链表（Linked Lists）</h3>
<h4 id="单链表与双链表">单链表与双链表</h4>
<ul>
<li><strong>单链表</strong>：每个节点只包含指向下一个节点的指针。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *data;                   <span class="comment">// 数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> *<span class="title">next</span>;</span>    <span class="comment">// 指向下一个节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>双链表</strong>：每个节点包含指向前一个和后一个节点的指针。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *data;                   <span class="comment">// 数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> *<span class="title">next</span>;</span>    <span class="comment">// 指向下一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> *<span class="title">prev</span>;</span>    <span class="comment">// 指向前一个节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="循环链表circular-linked-lists">循环链表（Circular Linked
Lists）</h4>
<ul>
<li>普通链表的最后一个节点的 next 指针通常指向 NULL，表示结束。</li>
<li>循环链表的最后一个节点的 next
指针指向第一个节点，形成环状结构。循环链表可以是单向或双向的。</li>
<li>Linux 内核的链表实现本质上是循环双链表，灵活性最高。</li>
</ul>
<h4 id="链表的遍历">链表的遍历</h4>
<ul>
<li>链表的遍历是线性的：从头节点开始，依次通过 next
指针访问每个节点。</li>
<li>非循环链表的最后一个节点 next 为 NULL；循环链表的最后一个节点 next
指向头节点。</li>
<li>双链表可以支持从尾节点向前遍历。</li>
<li>链表适合需要频繁插入、删除和遍历全部元素的场景，不适合随机访问。</li>
</ul>
<h3 id="linux-内核链表实现方式">Linux 内核链表实现方式</h3>
<h4 id="与传统链表的区别">1. 与传统链表的区别</h4>
<ul>
<li>传统链表通常是在数据结构里直接加 <code>next</code> 和
<code>prev</code> 指针，把结构本身变成链表节点。</li>
<li>Linux
内核采用<strong>嵌入链表节点</strong>的方式：在自定义结构体里嵌入一个
<code>struct list_head</code> 成员，而不是直接用
<code>next</code>/<code>prev</code> 指针。</li>
</ul>
<h4 id="内核链表节点结构">2. 内核链表节点结构</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>只包含指向前后节点的指针，不存储数据。</li>
</ul>
<h4 id="如何使用">3. 如何使用</h4>
<ul>
<li>在你的结构体里嵌入 <code>struct list_head</code> 成员，例如：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fox</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> tail_length;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> weight;</span><br><span class="line">    <span class="type">bool</span> is_fantastic;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span> <span class="comment">// 链表节点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这样，<code>fox.list.next</code> 指向下一个
fox，<code>fox.list.prev</code> 指向上一个 fox。</li>
</ul>
<h4 id="链表操作">4. 链表操作</h4>
<ul>
<li>内核提供了丰富的链表操作函数（如
<code>list_add()</code>），这些函数只操作
<code>list_head</code>，不关心具体数据类型。</li>
<li>通过 <code>container_of</code> 宏，可以从 <code>list_head</code>
指针反查到包含它的结构体： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    ((type *)((char *)(ptr) - offsetof(type, member)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> list_entry(ptr, type, member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr, type, member)</span></span><br></pre></td></tr></table></figure></li>
<li>用 <code>list_entry()</code>
可以从链表节点指针获取到完整的结构体数据。</li>
</ul>
<h4 id="链表初始化">5. 链表初始化</h4>
<ul>
<li>动态分配结构体后，用 <code>INIT_LIST_HEAD(&amp;obj-&gt;list)</code>
在运行时初始化链表节点。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fox</span> *red_fox; </span><br><span class="line">red_fox = <span class="built_in">kmalloc</span>(<span class="built_in">sizeof</span>(*red_fox), GFP_KERNEL); </span><br><span class="line">red_fox-&gt;tail_length = <span class="number">40</span>; </span><br><span class="line">red_fox-&gt;weight = <span class="number">6</span>; </span><br><span class="line">red_fox-&gt;is_fantastic = <span class="literal">false</span>; </span><br><span class="line"><span class="built_in">INIT_LIST_HEAD</span>(&amp;red_fox-&gt;list);</span><br></pre></td></tr></table></figure></li>
<li>静态定义时可用 <code>LIST_HEAD_INIT()</code> 宏在编译时初始化。
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">fox</span> red_fox = &#123; </span><br><span class="line">   .tail_length = <span class="number">40</span>, </span><br><span class="line">   .weight = <span class="number">6</span>, </span><br><span class="line">   .list  = <span class="built_in">LIST_HEAD_INIT</span>(red_fox.list),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="链表头">6. 链表头</h4>
<ul>
<li>通常会定义一个专门的 <code>list_head</code>
变量作为链表头，用于管理整个链表： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(fox_list)</span>;</span><br></pre></td></tr></table></figure></li>
<li>这个链表头本质上也是一个 <code>list_head</code>
节点，但不存储实际数据，只作为入口。</li>
</ul>
<h3 id="linux-内核链表的操作方法">Linux 内核链表的操作方法</h3>
<ol type="1">
<li><p><strong>所有链表操作函数都只操作 <code>struct list_head</code>
指针，和具体数据类型无关。</strong></p>
<ul>
<li>这些函数都定义在
<code>&lt;linux/list.h&gt;</code>，实现为内联函数，效率高。</li>
<li>所有操作都是 O(1)
常数时间，无论链表长度如何，插入、删除等操作速度都一样。</li>
</ul></li>
<li><p><strong>常用操作函数：</strong></p>
<ul>
<li><strong>添加节点</strong>（底层的循环链表特性，每一个节点都可以填入head）
<ul>
<li><code>list_add(new, head)</code>：把新节点插入到 head
节点之后（将最后一个节点填入head，实现栈）。</li>
<li><code>list_add_tail(new, head)</code>：把新节点插入到 head
节点之前（将第一个节点填入head，实现队列）。</li>
</ul></li>
<li><strong>删除节点</strong>
<ul>
<li><code>list_del(entry)</code>：把 entry
节点从链表中移除，但不释放内存。</li>
<li><code>list_del_init(entry)</code>：移除节点并重新初始化它，方便后续复用。</li>
</ul></li>
<li><strong>移动节点</strong>
<ul>
<li><code>list_move(list, head)</code>：把节点 list 移到 head
节点之后。</li>
<li><code>list_move_tail(list, head)</code>：把节点 list 移到 head
节点之前。</li>
</ul></li>
<li><strong>拼接链表</strong>
<ul>
<li><code>list_splice(list, head)</code>：把 list 指向的链表拼接到 head
节点之后。</li>
<li><code>list_splice_init(list, head)</code>：拼接后把原链表重新初始化。</li>
</ul></li>
<li><strong>判断链表是否为空</strong>
<ul>
<li><code>list_empty(head)</code>：判断链表是否为空，返回非零表示空。</li>
</ul></li>
</ul></li>
<li><p><strong>内部函数优化</strong></p>
<ul>
<li>如果你已经有了节点的 next 和 prev 指针，可以直接调用内部函数（如
<code>__list_del(prev, next)</code>），省去多余的指针解引用。</li>
<li>这些内部函数一般以双下划线 <code>__</code>
开头，只有在你已经拿到指针时才建议用。</li>
</ul></li>
</ol>
<h3 id="linux-内核链表的遍历">Linux 内核链表的遍历</h3>
<p>完整遍历包含n个节点的链表是O(n)时间复杂度操作。</p>
<h4 id="基础遍历方法">基础遍历方法</h4>
<p>最基础的遍历宏是<code>list_for_each()</code>，接收两个<code>list_head</code>参数：
-
<strong>第一个参数</strong>：指向当前项的指针（需调用者提供的临时变量）
- <strong>第二个参数</strong>：要遍历的链表头节点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line">list_for_each(p, fox_list) &#123;</span><br><span class="line">    <span class="comment">/* p指向链表中的某个节点 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但仅获取<code>list_head</code>指针通常无用，我们需要的是包含该链表节点的结构体（前文已讨论）指针。此时应使用<code>list_entry()</code>宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fox</span> *<span class="title">f</span>;</span></span><br><span class="line">list_for_each(p, &amp;fox_list) &#123;</span><br><span class="line">    f = list_entry(p, <span class="keyword">struct</span> fox, <span class="built_in">list</span>); <span class="comment">// 获取包含list_head的fox结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实用遍历方法">实用遍历方法</h4>
<p>上述方法不够直观，因此内核主要使用<code>list_for_each_entry()</code>宏，该宏自动完成<code>list_entry()</code>转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry(pos, head, member)</span><br></pre></td></tr></table></figure>
<p>参数说明： -
<code>pos</code>：包含<code>list_head</code>的结构体指针（相当于<code>list_entry()</code>返回值）
- <code>head</code>：链表头节点指针（如<code>fox_list</code>） -
<code>member</code>：<code>list_head</code>在结构体中的成员名（如<code>list</code>）</p>
<p>示例： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fox</span> *<span class="title">f</span>;</span></span><br><span class="line">list_for_each_entry(f, &amp;fox_list, <span class="built_in">list</span>) &#123;</span><br><span class="line">    <span class="comment">/* 每次迭代f指向下一个fox结构体 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>实际案例</strong>（来自内核文件系统通知系统inotify）：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inotify_watch *<span class="title function_">inode_find_handle</span><span class="params">(<span class="keyword">struct</span> inode *inode, </span></span><br><span class="line"><span class="params">                                              <span class="keyword">struct</span> inotify_handle *ih)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inotify_watch</span> *<span class="title">watch</span>;</span></span><br><span class="line">    list_for_each_entry(watch, &amp;inode-&gt;inotify_watches, i_list) &#123;</span><br><span class="line">        <span class="keyword">if</span> (watch-&gt;ih == ih)</span><br><span class="line">            <span class="keyword">return</span> watch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
此函数遍历<code>inode-&gt;inotify_watches</code>链表，查找匹配<code>inotify_handle</code>的节点。</p>
<h4 id="反向遍历">反向遍历</h4>
<p><code>list_for_each_entry_reverse()</code>功能与正向遍历相同，但沿<code>prev</code>指针逆向移动：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry_reverse(pos, head, member)</span><br></pre></td></tr></table></figure> 适用场景： 1. 性能优化：当目标节点更靠近链表尾部时 2.
顺序要求：如实现LIFO栈操作 若无特殊需求，建议使用正向遍历。</p>
<h4 id="安全删除遍历">安全删除遍历</h4>
<p>标准遍历方法在迭代过程中删除节点会导致问题（后续迭代无法获取正确的next/prev指针）。内核提供安全版本：
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry_safe(pos, next, head, member)</span><br></pre></td></tr></table></figure>
参数<code>next</code>用于临时存储下一节点指针，确保当前节点可安全删除。</p>
<p><strong>inotify示例</strong>： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inotify_inode_is_dead</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inotify_watch</span> *<span class="title">watch</span>, *<span class="title">next</span>;</span></span><br><span class="line">    mutex_lock(&amp;inode-&gt;inotify_mutex);</span><br><span class="line">    list_for_each_entry_safe(watch, next, &amp;inode-&gt;inotify_watches, i_list) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inotify_handle</span> *<span class="title">ih</span> =</span> watch-&gt;ih;</span><br><span class="line">        mutex_lock(&amp;ih-&gt;mutex);</span><br><span class="line">        inotify_remove_watch_locked(ih, watch); <span class="comment">// 删除watch节点</span></span><br><span class="line">        mutex_unlock(&amp;ih-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;inode-&gt;inotify_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逆向安全遍历版本： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list_for_each_entry_safe_reverse(pos, n, head, member)</span><br></pre></td></tr></table></figure></p>
<h4 id="注意事项">注意事项</h4>
<ol type="1">
<li>"safe"宏仅防护循环体内的删除操作，若存在并发操作仍需加锁</li>
<li>更多链表操作方法详见<code>&lt;linux/list.h&gt;</code></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/05/kamacode34/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/05/kamacode34/" class="post-title-link" itemprop="url">代码随想录 | 刷题-动态规划7</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-08-06 04:52:02" itemprop="dateCreated datePublished" datetime="2025-08-06T04:52:02+08:00">2025-08-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-08-12 00:45:01" itemprop="dateModified" datetime="2025-08-12T00:45:01+08:00">2025-08-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="打家劫舍">198.打家劫舍</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size()+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-2</span>]+nums[i<span class="number">-1</span>], dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="打家劫舍ii">213.打家劫舍II</h3>
<p>三种情况的动态规划： - 不考虑头尾元素 - 考虑头元素，不考虑尾元素 -
考虑尾元素，不考虑头元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>)<span class="keyword">return</span> nums[nums.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> res_front = <span class="built_in">rob_range</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-2</span>);</span><br><span class="line">        <span class="type">int</span> res_back = <span class="built_in">rob_range</span>(nums, <span class="number">1</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">max</span>(res_front, res_back);</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() &gt;= <span class="number">3</span>)res = <span class="built_in">max</span>(res,<span class="built_in">rob_range</span>(nums, <span class="number">1</span>, nums.<span class="built_in">size</span>()<span class="number">-2</span>));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob_range</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> start, <span class="type">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size()+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(start == end)<span class="keyword">return</span> nums[start];</span><br><span class="line">        dp[start] = nums[start];</span><br><span class="line">        dp[start+<span class="number">1</span>] = <span class="built_in">max</span>(nums[start], nums[start+<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span>((start+<span class="number">1</span>) == end)<span class="keyword">return</span> dp[start+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start+<span class="number">2</span>; i&lt;=end; i++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-2</span>]+nums[i], dp[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[end];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="打家劫舍iii">337.打家劫舍III</h3>
<p>直接使用递归，计算抢当前节点还是不抢当前节点时，对相同的子树进行了多次独立的递归调用。会超时，推荐记忆化：
利用递归，每层返回一个保存当前节点偷还是不偷的数组 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// struct TreeNode&#123;</span></span><br><span class="line"><span class="comment">//     int val;</span></span><br><span class="line"><span class="comment">//     TreeNode* left;</span></span><br><span class="line"><span class="comment">//     TreeNode* right;</span></span><br><span class="line"><span class="comment">//     TreeNode(int v) : val(v), left(nullptr), right(nullptr)&#123;&#125;</span></span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rob_tree</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)<span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; left = <span class="built_in">rob_tree</span>(root-&gt;left);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; right = <span class="built_in">rob_tree</span>(root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ↓不抢当前节点时，既可以选择抢子节点，也可选择不抢，可能会有跳过两个节点抢更优的情况</span></span><br><span class="line">        <span class="type">int</span> next_h = <span class="built_in">max</span>(left[<span class="number">0</span>], left[<span class="number">1</span>])+<span class="built_in">max</span>(right[<span class="number">0</span>], right[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> this_h = root-&gt;val+left[<span class="number">0</span>]+right[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;next_h, this_h&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res = <span class="built_in">rob_tree</span>(root);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(res[<span class="number">0</span>], res[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/zh-CN/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/zh-CN/">1</a><a class="page-number" href="/zh-CN/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/zh-CN/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/zh-CN/page/11/">11</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/zh-CN/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
  <div class="languages">
    <label class="lang-select-label">
      <i class="fa fa-language"></i>
      <span>简体中文</span>
      <i class="fa fa-angle-up" aria-hidden="true"></i>
    </label>
    <select class="lang-select" data-canonical="" aria-label="选择语言">
      
        <option value="zh-CN" data-href="/page/3/index.html" selected="">
          简体中文
        </option>
      
        <option value="en" data-href="/en/page/3/index.html" selected="">
          English
        </option>
      
    </select>
  </div>

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Mackz-Maxw</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
