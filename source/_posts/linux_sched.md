---
title: Linux调度算法相关
---

# 实时调度策略及算法概述

Linux 提供了两种实时调度策略，`SCHED_FIFO` 和 `SCHED_RR`。非实时的普通调度策略是 `SCHED_NORMAL`。

通过调度类框架，这些实时调度策略并非由完全公平调度器（CFS）管理，而是由一个特殊的实时调度器管理，该调度器定义在 `kernel/sched_rt.c` 文件中。

## 1. SCHED_FIFO 策略
`SCHED_FIFO` 实现了一种简单的先进先出（FIFO）调度算法，**没有时间片限制**，可以无限期运行。
- 一个可运行的 `SCHED_FIFO` 任务始终优先于任何 `SCHED_NORMAL` 任务。
- 当 `SCHED_FIFO` 任务变为可运行状态时，它会一直运行，直到阻塞或显式放弃处理器。
- **抢占规则**：只有更高优先级的 `SCHED_FIFO` 或 `SCHED_RR` 任务可以抢占当前的 `SCHED_FIFO` 任务。
- 如果多个 `SCHED_FIFO` 任务具有相同优先级，它们以轮转的方式运行。

## 2. SCHED_RR 策略
`SCHED_RR` 与 `SCHED_FIFO` 类似，但有时间片限制。
- 每个任务运行到时间片耗尽时，会被切换到同一优先级队列中的下一个任务。
- 只有更高优先级的任务可以抢占当前任务，即使 `SCHED_RR` 任务的时间片耗尽，低优先级的进程也无法抢占它的执行。
- **时间片的作用**：仅用于同优先级进程之间的调度。

## 3. 静态优先级
- 两种实时调度策略都实现了**静态优先级**。
- 内核不会为实时任务计算动态优先级。
- 给定优先级的实时任务总是会抢占低优先级的任务。

## 4. 软实时与硬实时
- Linux 的实时调度策略提供的是**软实时**行为：内核会尽力在时限内调度应用程序，但不保证一定达成。
- 硬实时系统则保证严格的时限要求，而 Linux 并不原生支持。

---

# 实时优先级范围

- 实时优先级范围为 `0` 到 `MAX_RT_PRIO - 1`，默认情况下 `MAX_RT_PRIO` 为 `100`。99为最高实时优先级。
- 普通任务（`SCHED_NORMAL`）与实时任务共享优先级空间：
  - `-20` 到 `+19` 的 nice 值映射到优先级范围 `100` 到 `139`。这是用户空间的进程评级，-20为最高优先级。

---

# 与调度器相关的系统调用

以下是管理调度参数的系统调用列表：

| **系统调用**              | **描述**                                |
|--------------------------|----------------------------------------|
| `nice()`                | 设置进程的 nice 值                      |
| `sched_setscheduler()`  | 设置进程的调度策略                       |
| `sched_getscheduler()`  | 获取进程的调度策略                       |
| `sched_setparam()`      | 设置进程的实时优先级                     |
| `sched_getparam()`      | 获取进程的实时优先级                     |
| `sched_get_priority_max()` | 获取实时调度的最大优先级               |
| `sched_get_priority_min()` | 获取实时调度的最小优先级               |
| `sched_rr_get_interval()`  | 获取进程的时间片值                     |
| `sched_setaffinity()`      | 设置进程的处理器亲和性                 |
| `sched_getaffinity()`      | 获取进程的处理器亲和性                 |
| `sched_yield()`            | 临时将处理器让给其他任务               |
