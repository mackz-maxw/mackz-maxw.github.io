<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.1">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"mackz-maxw.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"always","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="乘上燃犀船，还未曾去过倒悬山。">
<meta property="og:type" content="website">
<meta property="og:title" content="Maxw的小站">
<meta property="og:url" content="https://mackz-maxw.github.io/index.html">
<meta property="og:site_name" content="Maxw的小站">
<meta property="og:description" content="乘上燃犀船，还未曾去过倒悬山。">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Mackz-Maxw">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://mackz-maxw.github.io/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Maxw的小站</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="Maxw的小站" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Maxw的小站</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Maxw学习记录</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Mackz-Maxw</p>
  <div class="site-description" itemprop="description">乘上燃犀船，还未曾去过倒悬山。</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/mackz-maxw" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;mackz-maxw" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/10/02/kamacode38seq2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/02/kamacode38seq2/" class="post-title-link" itemprop="url">代码随想录 | 刷题-动态规划11</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-10-03 05:48:44" itemprop="dateCreated datePublished" datetime="2025-10-03T05:48:44+08:00">2025-10-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-11 23:30:22" itemprop="dateModified" datetime="2025-10-11T23:30:22+08:00">2025-10-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="最长公共子序列">1143.最长公共子序列</h3>
<p>按照动态规划，每次比较成功就加一，取所有值最大的思路是错的，这种会把乱序但是相同的字符也算进去。
于是我想了半天怎么先循环以i,j为右下角的正方形，本来想的是记忆化将i,j赋值为比较后相等的值，看了题解发现得在递推公式上作更改
因为字符中间可能会插入别的字符，所以ac,ace的比较结果和ac,aced的比较结果是一样的
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(text1.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (text2.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= text1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= text2.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[text1.<span class="built_in">size</span>()][text2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="不相交的线">1035.不相交的线</h3>
<p>既然一个数只能连一根线，那么其实和上一题是一个意思了
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxUncrossedLines</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums1.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; (nums2.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= nums1.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= nums2.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i<span class="number">-1</span>] == nums2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums1.<span class="built_in">size</span>()][nums2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="最大子序和">53. 最大子序和</h3>
<p>我想的是，<code>dp[i]</code>由<code>dp[i-1]</code>,<code>dp[i-1]+nums[i]</code>,<code>nums[i]</code>中的最大值决定，但是这样解会算出不连续的最大值</p>
<p>题解的推算法是这样的： <code>dp[i]</code>只有两个方向可以推出来： -
<code>dp[i-1] + nums[i]</code>，即：<code>nums[i]</code>加入当前连续子序列和
- <code>nums[i]</code>，即：从头开始计算当前连续子序列和
再找每个的<code>dp[i]</code>最大值 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> res = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>]+nums[i], nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; res)res = dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="判断子序列">392.判断子序列</h3>
<p>常规做的话双指针法即可，按照动态规划来做是和第一题是差不多的思路
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSubsequence</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= t.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.<span class="built_in">size</span>()][t.<span class="built_in">size</span>()] == s.<span class="built_in">size</span>() ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/10/02/kamabagu7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/10/02/kamabagu7/" class="post-title-link" itemprop="url">代码随想录 | 八股-TCP连接</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-10-03 05:29:05 / 修改时间：05:48:16" itemprop="dateCreated datePublished" datetime="2025-10-03T05:29:05+08:00">2025-10-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/comp-basic/" itemprop="url" rel="index"><span itemprop="name">comp basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3
id="tcp连接三次握手的过程为什么是三次可以是两次或者更多吗">TCP连接三次握手的过程，为什么是三次，可以是两次或者更多吗？</h3>
<ol type="1">
<li>三次握手的过程</li>
</ol>
<p>第一次握手：客户端向服务器发送一个SYN
（同步序列编号）报文，请求建立连接，客户端进入SYN_SENT 状态。
第二次握手：服务器收到SYN 报文后，如果同意建立连接，则会发送一个SYN-ACK
（同步确认）报文作为响应，同时进入SYN_RCVD 状态。
第三次握手：客户端收到服务器的SYN-ACK 报文后，会发送一个ACK
（确认）报文作为最终响应，之后客户端和服务器都进入ESTABLISHED
状态，连接建立成功。</p>
<p>(2)为什么需要三次握手
因为TCP需要简历双向的数据连接。通过三次握手，客户端和服务器都能够确认对方的接收和发送能力。第一次握手确认了客户端到服务器的通道是开放的；第二次握手确认了服务器到客户端的通道是开放的；第三次握手则确认了客户端接收到服务器的确认，从而确保了双方的通道都是可用的。</p>
<p>而如果仅使用两次握手，服务器可能无法确定客户端的接收能力是否正常，比如客户端可能已经关闭了连接，但之前发送的连接请求报文在网络上延迟到达了服务器，服务器就会主动去建立一个连接，但是客户端接收不到，导致资源的浪费。而四次握手可以优化为三次。</p>
<h3
id="tcp连接四次挥手的过程为什么是四次">TCP连接四次挥手的过程，为什么是四次？</h3>
<p>（1）四次挥手的过程</p>
<p>第一次挥手：客户端发送一个FIN报文给服务端，表示自己要断开数据传送，报文中会指定一个序列号
(seq=x)。然后,客户端进入FIN-WAIT-1 状态。
第二次挥手：服务端收到FIN报文后，回复ACK报文给客户端，且把客户端的序列号值+1，作为ACK报文的序列号(seq=x+1)。然后，服务端进入CLOSE-WAIT(seq=x+1)状态，客户端进入FIN-WAIT-2状态。
第三次挥手：服务端也要断开连接时，发送FIN报文给客户端，且指定一个序列号(seq=y+1)，随后服务端进入LAST-ACK状态。
第四次挥手：客户端收到FIN报文后，发出ACK报文进行应答，并把服务端的序列号值+1作为ACK报文序列号(seq=y+2)。此时客户端进入TIME-WAIT状态。服务端在收到客户端的ACK
报文后进入CLOSE 状态。如果客户端等待2MSL没有收到回复，才关闭连接。</p>
<p>（2）为什么需要四次挥手</p>
<p>TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。
当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后才会完全关闭
TCP
连接。因此两次挥手可以释放一端到另一端的TCP连接，完全释放连接一共需要四次挥手。</p>
<p>只有通过四次挥手，才可以确保双方都能接收到对方的最后一个数据段的确认，主动关闭方在发送完最后一个ACK后进入TIME-WAIT
状态，这是为了确保被动关闭方接收到最终的ACK
，如果被动关闭方没有接收到，它可以重发FIN
报文，主动关闭方可以再次发送ACK 。</p>
<p>而如果使用三次挥手，被动关闭方可能在发送最后一个数据段后立即关闭连接，而主动关闭方可能还没有接收到这个数据段的确认。</p>
<h3
id="http的keep-alive是什么tcp-的-keepalive-和-http-的-keep-alive-是一个东西吗">HTTP的Keep-Alive是什么？TCP
的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？</h3>
<p>HTTP 的 Keep-Alive，是由应用层实现的，称为 HTTP 长连接
每次请求都要经历这样的过程：建立 TCP连接 -&gt; HTTP请求资源 -&gt;
响应资源 -&gt;
释放连接，这就是HTTP短连接，但是这样每次建立连接都只能请求一次资源，所以HTTP
的 Keep-Alive实现了使用同一个 TCP 连接来发送和接收多个 HTTP
请求/应答，避免了连接建立和释放的开销，就就是 HTTP
长连接。通过设置HTTP头Connection: keep-alive来实现。</p>
<p>TCP 的 Keepalive，是由TCP 层（内核态）实现的，称为 TCP
保活机制，是一种用于在 TCP 连接上检测空闲连接状态的机制
当TCP连接建立后，如果一段时间内没有任何数据传输，TCP
Keepalive会发送探测包来检查连接是否仍然有效。</p>
<p>补充说明：</p>
<p>其实这里tcp的keepalive，不只是支持http，还可以支持ftp和smtp的，他是一个能力，类似于gc。</p>
<p>http的这个keepalive感觉更是一种策略吧，比如你有一个http用了keepalive，然后过了一会，你不传输数据了，这个时候没有通知对方close，这个时候tcp的keepalive就会起到用处去关闭这次链接。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/09/26/oper_sys28lab_process/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/26/oper_sys28lab_process/" class="post-title-link" itemprop="url">操作系统基础 | 5.8 进程实验</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-09-27 09:27:32" itemprop="dateCreated datePublished" datetime="2025-09-27T09:27:32+08:00">2025-09-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-10-01 00:27:46" itemprop="dateModified" datetime="2025-10-01T00:27:46+08:00">2025-10-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/lab/" itemprop="url" rel="index"><span itemprop="name">lab</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="进程家族树-process-family-tree"><strong>进程家族树 (Process
Family Tree)</strong></h3>
<ol type="1">
<li><p><strong>实验报告</strong>：准备好实验报告</p></li>
<li><p><strong>simple_fork.c</strong>：编写一个名为
<code>simple_fork.c</code> 的简短程序，使用 <code>fork()</code>
函数从父进程生成一个子进程。父进程应在 <code>fork</code>
之前打印一条语句，并在 <code>fork</code> 之后打印出子进程的
PID。子进程应在被生成后打印一条语句，使用 <code>getpid()</code> 和
<code>getppid()</code> 函数打印出其自身的 PID 及其父进程的
PID。在您的树莓派上编译并运行您的程序，并将程序的输出作为此问题的答案。
提示：gcc编译<code>gcc [source] -o [destination]</code></p></li>
<li><p><strong>tree_fork.c</strong>：编写第二个名为
<code>tree_fork.c</code>
的程序，该程序将一个整数作为命令行参数，并在最多 10
代的固定限制内，生成一个具有指定代数的“二进制家族树”进程。这将创建
<code>2^n - 1</code> 个进程，其中 <code>n</code> 是代数。对于
n=1，程序将创建 1 个进程；对于 n=5，将创建 31 个进程；对于 n=10，将创建
1023 个进程，依此类推。我们将代数限制为最多
10，因为更大的数字会运行很长时间，甚至可能冻结您的树莓派！</p>
<ul>
<li>如果未提供命令行参数，程序应输出有用的用法消息并退出。</li>
<li>否则，它应将命令行参数转换为整数并存储在 <code>generations</code>
变量中。</li>
<li>如果 <code>generations</code> 变量小于 1 或大于
10，程序应输出有用的用法消息并退出。</li>
<li>否则，它（以及它生成的任何子进程）应执行以下操作（原始程序为第一代）：
<ul>
<li>打印一行，说明它属于哪一代及其自身的 PID；</li>
<li>增加当前代数计数器；</li>
<li>如果已达到最后一代（根据 <code>generations</code> 变量），则直接返回
0；否则，生成两个子进程；</li>
<li>使用 <code>wait(0)</code> 等待任何成功生成的子进程完成；</li>
<li>如果两个子进程都成功生成，则返回
0；如果任一生成（或两者都）失败，则返回 -1。</li>
</ul></li>
<li><strong>提示</strong>：仔细检查每次调用
<code>fork()</code>（或您用于生成每个子进程的任何调用）返回的
<code>pid_t</code> 值非常重要，因为 (1)
这些调用可能失败（由负返回值指示），(2) <code>0</code>
表示子进程正在运行，(3) 正数表示父进程正在运行。</li>
<li><strong>提示</strong>：基于此，使用递归，或使用带有几个
<code>pid_t</code> 变量（每个子进程一个）的 <code>while</code>
循环并明智地在子进程中运行的代码分支使用 <code>continue</code>
语句，可以很直接地实现本练习的逻辑。</li>
<li>作为此练习的答案，请展示您的程序在运行 4
代时（如果正确实现，应总共生成 15 个进程）的输出。</li>
</ul></li>
<li><p><strong>修改 kobject
示例模块</strong>：现在我们将回到使用这些思想进行内核模块设计。首先，从您的
linux 源码目录中，找到并将文件
<code>samples/kobject/kobject-example.c</code>
复制到您保存内核模块代码的目录中。这是一个使用称为 <code>kobjects</code>
的功能的内核模块，它提供了一个在内核和用户空间之间交换数据的接口。每个数据项称为一个属性（attribute），对于每个属性，您需要提供一个
<code>show</code> 和 <code>store</code>
函数，分别在用户空间读取和写入这些值时被调用。</p>
<ul>
<li>该特定模块提供三个属性：<code>foo</code>、<code>baz</code> 和
<code>bar</code>。加载后，您可以在 sysfs 文件系统中的
<code>/sys/kernel/kobject_example/</code> 目录下找到它们。</li>
<li>修改此文件，以便（通过使用 <code>printk</code>）在更新
<code>foo</code>、<code>baz</code> 或 <code>bar</code>
中的任何一个时打印一条系统日志消息，并在消息中显示被更新变量的旧值和新值。</li>
<li>现在我们可以像以前一样构建您修改后的模块。首先，更新您的
<code>Makefile</code>，使其包含新模块的相应 <code>.o</code>
文件目标，然后为您的模块生成 <code>.ko</code> 文件，如下所示：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module add arm-rpi</span><br><span class="line">LINUX_SOURCE=您的Linux内核源代码路径</span><br><span class="line">make -C <span class="variable">$LINUX_SOURCE</span> ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- M=<span class="variable">$PWD</span> modules</span><br></pre></td></tr></table></figure></li>
<li>然后，使用 <code>sftp</code> 将生成的 <code>.ko</code>
文件复制到您的树莓派上，并使用 <code>sudo insmod</code>
加载该模块。</li>
<li>在具有 root 权限的终端中，您可以使用 <code>cat</code>
命令读取这些属性的值，并使用 <code>echo</code>
命令将值写入这些属性，例如： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo bash</span><br><span class="line"><span class="built_in">cd</span> /sys/kernel/kobject_example/</span><br><span class="line"><span class="built_in">cat</span> foo          <span class="comment"># 显示 foo 属性的当前（原始）值</span></span><br><span class="line"><span class="built_in">echo</span> 42 &gt; foo    <span class="comment"># 将值 42 写入属性 foo</span></span><br><span class="line"><span class="built_in">cat</span> foo          <span class="comment"># 显示属性 foo 的新值</span></span><br></pre></td></tr></table></figure> <em>注意：您必须有一个 root
终端（<code>sudo bash</code> 可以给您）才能写入这些命令（即
<code>sudo echo</code> 不起作用）。</em></li>
<li>作为此练习的答案，请展示使用这些命令成功更改
<code>foo</code>、<code>bar</code> 和 <code>baz</code>
值的输出演示。</li>
</ul></li>
<li><p><strong>family_reader.c
模块</strong>：现在我们将编写一个内核模块，通过 sysfs 接口读取一个
PID，并在系统日志中打印该进程的祖先谱系。</p>
<ul>
<li>创建一个基于您修改后的 <code>kobject-example.c</code>
文件的新内核模块文件
<code>family_reader.c</code>（即，首先请复制它）。该模块应在
<code>/sys/kernel/fam_reader/</code>
下创建单个系统属性（像上一个练习一样是整数值）。当您向此属性写入一个整数时，您的模块应尝试打印出该
PID
的祖先谱系（即，它的父进程，然后是父进程的父进程，依此类推，一直追溯到
<code>init</code> 任务）。涉及几个步骤：
<ul>
<li><strong>旁注</strong>：现代 Linux
内核为了便于在不同虚拟主机之间迁移进程，区分了“真实”PID
和“虚拟”PID。虚拟 PID 是进程从用户空间看到的 PID。</li>
<li>您需要将整数输入转换为合适的内核 PID。使用函数
<code>find_vpid()</code>（请参阅 <code>include/linux/pid.h</code> 和
<code>kernel/pid.c</code>），它返回一个
<code>struct pid *</code>。此函数可能失败，因此在解引用指针之前务必检查其返回值。</li>
<li>接下来，您可以通过将 <code>struct pid *</code> 和标志
<code>PIDTYPE_PID</code> 传递给函数 <code>get_pid_task()</code>（请参阅
<code>include/linux/pid.h</code> 和
<code>kernel/pid.c</code>）来将其转换为
<code>struct task_struct *</code>。此函数可能失败，因此在解引用指针之前务必检查其返回值。</li>
<li>一旦您有了
<code>struct task_struct *</code>，就可以访问它存储的任何数据。特别是，<code>real_parent</code>
字段存储了生成它的进程的 <code>struct task_struct *</code>
指针，<code>comm</code> 字段是给出命令名称的字符串。
<ul>
<li><strong>注意</strong>：有一个单独的字段叫做
<code>parent</code>，这不是我们本练习想要的。<code>parent</code>
是共享进程组信号并允许父子进程之间等待的逻辑父进程。</li>
</ul></li>
<li>回溯家族树，打印出每个任务的 PID 和命令名称，一直回溯到 PID 为 1 的
<code>init</code> 任务。</li>
</ul></li>
<li>像上一个模块一样编译您的新内核模块，然后使用 <code>sftp</code>
将生成的 <code>.ko</code>
文件复制到您的树莓派上。在您的树莓派上，安装该模块，然后使用
<code>sudo bash</code> 为您的终端会话提供 root
访问权限。在该模块的目录下（将在 <code>/sys/kernel/</code> 下），使用
<code>cat</code> 和 <code>echo</code> 读取和写入该模块属性的值，然后使用
<code>dmesg</code> 确认系统日志显示您的模块工作正常。</li>
<li>使用 <code>ps</code> 命令查找在您当前终端窗口中运行的
<code>sudo</code> 进程的 PID，使用 <code>echo</code>
将您的模块属性设置为该 PID，然后使用 <code>dmesg</code>
查看该进程的祖先谱系。作为此练习的答案，请展示显示 <code>sudo</code>
进程祖先谱系的系统日志消息。</li>
</ul></li>
</ol>
<hr />
<h3 id="可选拓展练习-optional-enrichment-exercises"><strong>可选拓展练习
(Optional Enrichment Exercises)</strong></h3>
<ol start="6" type="1">
<li><strong>探索 task_struct</strong>：<code>task_struct</code>
包含许多有趣的进程数据和进程记账信息。尝试将其他字段打印到系统日志中，并作为此练习的答案，请简要描述您打印了哪些内容，并展示执行此操作后的一些系统日志消息。</li>
<li><strong>探索调度程序功能</strong>：<code>kernel/sched</code> 和
<code>include/linux/sched</code>
中的文件包含许多用于处理任务的功能，包括修改特定任务或迭代系统中每个任务的能力。例如，<code>include/linux/sched/signal.h</code>
定义了诸如 <code>for_each_process()</code>
之类的宏。尝试使用其中一些功能，并作为此练习的答案，请简要描述您做了什么以及观察到了什么。</li>
</ol>
<hr />

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/09/26/kamacode37subseq/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/26/kamacode37subseq/" class="post-title-link" itemprop="url">代码随想录 | 刷题-动态规划10</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-09-27 09:25:21 / 修改时间：06:47:29" itemprop="dateCreated datePublished" datetime="2025-09-27T09:25:21+08:00">2025-09-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/leetcode/" itemprop="url" rel="index"><span itemprop="name">leetcode</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="最长递增子序列">300.最长递增子序列</h3>
<p>这题我一开始想使用回溯找最长子序列，但是我发现需要记录的状态太多，回溯没办法解决；同时对于序列中的相同数字，如何记住遍历前后的状态也是个问题。
题解中这题使用的是动态规划，对于每一个索引求它所在的最长递增子序列，再求所有子序列中最长的那个。</p>
<ul>
<li>外层循环：遍历序列中每一个索引<code>i</code></li>
<li>内层循环：求从开头到<code>i</code>之前的数字<code>j</code>中最长的子序列，如果<code>nums[i] &gt; nums[j]</code>，则开头到<code>i</code>所在处最长子序列为<code>j</code>所在处+1</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> mx = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j&lt;i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;dp[i]&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">            &#125;</span><br><span class="line">            mx = <span class="built_in">max</span>(mx, dp[i]);</span><br><span class="line">            <span class="comment">// cout&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="最长连续递增序列">674. 最长连续递增序列</h3>
<p>这题不要想得太复杂了就行 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLengthOfLCIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lng = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> max_l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])&#123;</span><br><span class="line">                lng++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                lng = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            max_l = <span class="built_in">max</span>(max_l, lng);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="最长重复子数组">718. 最长重复子数组</h3>
<p>这题我想可不可以分别求两个数组的最长相等前后缀表，再找重复子数组。看了动规解法我发现，一个两数组比较表能解决的事情，用前后缀表似乎有点浪费？</p>
<p>动规解法中，<code>dp[i][j]</code>表示两个数组下标i-1，j-1个数进行比较，这样0行和0列默认初始化为0即可。如果表示下标i，j个数，则需要再初始化一下0行和0列
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findLength</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums1.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums2.<span class="built_in">size</span>()+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; (nums1.<span class="built_in">size</span>()+<span class="number">1</span>); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; (nums2.<span class="built_in">size</span>()+<span class="number">1</span>); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums1[i<span class="number">-1</span>] == nums2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j] &gt; len)len = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// for(auto line:dp)&#123;</span></span><br><span class="line">        <span class="comment">//     for(int l:line)&#123;</span></span><br><span class="line">        <span class="comment">//         cout&lt;&lt;l&lt;&lt;&#x27; &#x27;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/09/26/intv_tyy/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/26/intv_tyy/" class="post-title-link" itemprop="url">算法笔试 | 某厂测开复盘</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-09-27 09:24:28 / 修改时间：09:24:16" itemprop="dateCreated datePublished" datetime="2025-09-27T09:24:28+08:00">2025-09-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">interview</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>今天笔试某厂测开岗，选择还行，算法全寄，遂复盘之</p>
<h3 id="操作系统八股-内存的分页和分段">操作系统八股
内存的分页和分段</h3>
<h4 id="分页">分页</h4>
<p>分页是一种内存管理方案，它<strong>将程序的虚拟地址空间和物理内存都划分成固定大小的块</strong>。虚拟内存的块称为“页”，物理内存的块称为“页框”或“帧”。页和页框的大小通常相同（例如
4KB）。</p>
<p>虚拟地址 = 页号 + 页内偏移量 物理地址 = 页框号 + 页内偏移量</p>
<h4 id="分段">分段</h4>
<p>分段是一种更符合程序员视角的内存管理方案。<strong>一个程序被划分为若干个逻辑段</strong>，例如：代码段、数据段、堆段、栈段等。每个段都有其特定的用途（如代码段可读可执行但不可写）。</p>
<p>操作系统为每个进程维护一张<strong>段表</strong>，该表记录了每个段的<strong>基地址</strong>（在物理内存中的起始地址）和<strong>段长</strong>（段的界限）。</p>
<table>
<colgroup>
<col style="width: 33%" />
<col style="width: 33%" />
<col style="width: 33%" />
</colgroup>
<thead>
<tr>
<th style="text-align: left;">特性</th>
<th style="text-align: left;"><strong>分页（一维）</strong></th>
<th style="text-align: left;"><strong>分段（二维）</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>地址空间视图</strong></td>
<td style="text-align: left;"><strong>一个</strong>连续的线性空间</td>
<td
style="text-align: left;"><strong>多个</strong>独立的逻辑空间（段）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>“号”的含义</strong></td>
<td
style="text-align: left;">系统管理的<strong>索引号</strong>（第几页）</td>
<td
style="text-align: left;">程序定义的<strong>逻辑标识</strong>（哪个段）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>对程序员可见</strong></td>
<td
style="text-align: left;"><strong>透明</strong>（由硬件和OS管理）</td>
<td
style="text-align: left;"><strong>可见</strong>（通常由编译器管理，但理念上符合程序员思维）</td>
</tr>
<tr>
<td style="text-align: left;"><strong>类比</strong></td>
<td
style="text-align: left;"><strong>一本书</strong>：只需要一个页码和行号</td>
<td
style="text-align: left;"><strong>文件柜</strong>：需要先选抽屉，再选文件</td>
</tr>
</tbody>
</table>
<h3 id="操作系统八股-银行家算法bankers-algorithm">操作系统八股
银行家算法（Banker's Algorithm）。</h3>
<p>银行家算法用于检查系统是否处于安全状态，即是否存在一个安全序列，每个进程按顺序执行，执行完后释放所有资源，使得所有进程都能完成而不导致死锁。</p>
<h3 id="算法题-分零食">算法题 分零食</h3>
<p>题目：小明和弟弟分零食，分零食的次数为c，每次会给到零食的数量n和最便宜的零食价格m,在价目表中，每个零食的价格是前一个零食的m倍（第一个零食价格为m）,小明想给弟弟总和比自己贵的零食，但为了弟弟的自尊心他想自己和弟弟的零食价格差尽量小，每次请输出小明的零食数和小明每个零食的单价</p>
<h4 id="为什么贪心算法是最优的">为什么贪心算法是最优的？</h4>
<ol type="1">
<li><strong>几何序列的超级递增性质</strong>：当 (m &gt; 1)
时，零食价格序列是超级递增的，即每个后续零食的价格都大于之前所有零食价格之和。例如，对于
(m=2)，序列为 (2, 4, 8, 16, )，其中 (4 &gt; 2), (8 &gt; 2+4), (16 &gt;
2+4+8)，等等。这种性质意味着贪心算法从大到小选择零食可以确保得到最接近总价一半的子集和，从而最小化价格差。</li>
<li><strong>对于 (m = 1) 的情况</strong>：所有零食价格均为
1。小明最多能拿的零食数为 (k = (n-1)/2 )，这样弟弟拿 (n-k)
个零食，总价差为 1（最小可能值）。贪心算法在这里本质上是直接计算最大 (k)
使得 (k &lt; n/2)。</li>
</ol>
<p>因此，贪心算法在两种情况下都能保证找到最优解，使价格差最小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line">    cin &gt;&gt; c;</span><br><span class="line">    <span class="keyword">while</span> (c--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 所有零食价格均为1：小明拿k个，使得k &lt; n/2，且k尽可能大</span></span><br><span class="line">            <span class="type">int</span> k = (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            cout &lt;&lt; k &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 计算零食价格序列和总价S</span></span><br><span class="line">            vector&lt;ll&gt; <span class="built_in">prices</span>(n);</span><br><span class="line">            ll total_sum = <span class="number">0</span>;</span><br><span class="line">            ll current = m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                prices[i] = current;</span><br><span class="line">                total_sum += current;</span><br><span class="line">                current *= m;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            ll小明_sum = <span class="number">0</span>;</span><br><span class="line">            vector&lt;ll&gt; xiaoming_prices;</span><br><span class="line">            <span class="comment">// 从最贵的零食（序列末尾）开始贪心选择</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">2</span> * (小明_sum + prices[i]) &lt;= total_sum) &#123;</span><br><span class="line">                    小明_sum += prices[i];</span><br><span class="line">                    xiaoming_prices.<span class="built_in">push_back</span>(prices[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 输出小明的零食数量和每个零食的单价（价格从大到小）</span></span><br><span class="line">            cout &lt;&lt; xiaoming_prices.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = xiaoming_prices.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                cout &lt;&lt; xiaoming_prices[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/09/14/oper_sys27orphan_err/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/14/oper_sys27orphan_err/" class="post-title-link" itemprop="url">操作系统基础 | 5.7 孤儿进程；错误检查</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-09-14 23:32:32 / 修改时间：23:32:41" itemprop="dateCreated datePublished" datetime="2025-09-14T23:32:32+08:00">2025-09-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="孤儿进程与僵尸进程-orphans-and-zombies"><strong>26.2
孤儿进程与僵尸进程 (Orphans and Zombies)</strong></h3>
<p>父进程和子进程的生命周期通常并不相同——要么父进程比子进程存活时间长，要么相反。这就引出了两个问题：</p>
<p><strong>1. 孤儿进程由谁接管？</strong>
当一个进程的父进程终止后，该进程就变成了“孤儿进程”。这个孤儿进程会被
<code>init</code> 进程（所有进程的祖先，其进程 ID 为
1）收养。换句话说，在子进程的父进程终止后，调用 <code>getppid()</code>
将返回值
1。这可以作为一种判断子进程的真正父进程是否仍存活的方法（前提是该子进程并非由
<code>init</code> 进程创建）。 使用 Linux 特有的 <code>prctl()</code>
系统调用的 <code>PR_SET_PDEATHSIG</code>
操作，可以设置一个进程在成为孤儿时接收到一个特定的信号。</p>
<p><strong>2. 父进程还未执行 wait()
子进程就已终止，会发生什么？</strong>
关键在于，尽管子进程已经完成了它的工作，但仍应允许父进程在之后的某个时间点执行
<code>wait()</code>
来获取子进程的终止状态。内核通过将子进程转变为“僵尸进程”（Zombie）来处理这种情况。这意味着子进程持有的大部分资源会被释放回系统，供其他进程重用。进程唯一保留的部分是内核进程表中的一个条目，该条目记录了子进程的进程
ID、终止状态以及资源使用统计信息（参见 36.1 节）等信息。</p>
<p>关于僵尸进程，UNIX
系统模仿了电影中的设定——僵尸进程无法被信号杀死，即使是（银弹）<code>SIGKILL</code>
信号也不行。这确保了父进程最终总是能够执行 <code>wait()</code>。</p>
<p>当父进程执行了 <code>wait()</code>
后，内核会清除该僵尸进程，因为关于该子进程的最后剩余信息不再需要。另一方面，如果父进程未执行
<code>wait()</code> 就终止了，那么 <code>init</code>
进程会收养该子进程，并自动执行
<code>wait()</code>，从而将僵尸进程从系统中移除。</p>
<p>如果一个父进程创建了子进程，但未能执行
<code>wait()</code>，那么内核进程表中将无限期地保留该僵尸子进程的条目。如果创建了大量这样的僵尸子进程，它们最终会填满内核进程表，从而阻止新进程的创建。由于僵尸进程无法用信号杀死，将它们从系统中移除的唯一方法是杀死它们的父进程（或等待其退出），届时
<code>init</code> 进程会收养这些僵尸进程并对它们执行
<code>wait()</code>，从而将它们从系统中清除。</p>
<p>这些语义对于需要创建大量子进程的长生命周期父进程（如网络服务器和
Shell）的设计具有重要意义。换句话说，在此类应用程序中，父进程应执行
<code>wait()</code>
调用，以确保已终止的子进程总是能从系统中被移除，而不是变成长期存在的僵尸进程。如
26.3.1 节所述，父进程可以同步执行这些 <code>wait()</code>
调用，也可以异步地（例如响应 <code>SIGCHLD</code> 信号的递送）执行。</p>
<p>以下程序演示了僵尸进程的创建以及僵尸进程无法被 <code>SIGKILL</code>
杀死的情况。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libgen.h&gt;</span>             <span class="comment">/* For basename() declaration */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_SIZE 200</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="type">char</span> cmd[CMD_SIZE];</span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line"></span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);       <span class="comment">/* Disable buffering of stdout */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent PID=%ld\n&quot;</span>, (<span class="type">long</span>) getpid());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (childPid = fork()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:     <span class="comment">/* Child: immediately exits to become zombie */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child (PID=%ld) exiting\n&quot;</span>, (<span class="type">long</span>) getpid());</span><br><span class="line">        _exit(EXIT_SUCCESS);</span><br><span class="line">    <span class="keyword">default</span>:    <span class="comment">/* Parent */</span></span><br><span class="line">        sleep(<span class="number">3</span>);               <span class="comment">/* Give child a chance to start and exit */</span></span><br><span class="line">        <span class="built_in">snprintf</span>(cmd, CMD_SIZE, <span class="string">&quot;ps | grep %s&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">        cmd[CMD_SIZE - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;    <span class="comment">/* Ensure string is null-terminated */</span></span><br><span class="line">        system(cmd);            <span class="comment">/* View zombie child */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Now send the &quot;sure kill&quot; signal to the zombie */</span></span><br><span class="line">        <span class="keyword">if</span> (kill(childPid, SIGKILL) == <span class="number">-1</span>)</span><br><span class="line">            errMsg(<span class="string">&quot;kill&quot;</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);               <span class="comment">/* Give child a chance to react to signal */</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After sending SIGKILL to zombie (PID=%ld):\n&quot;</span>, (<span class="type">long</span>) childPid);</span><br><span class="line">        system(cmd);            <span class="comment">/* View zombie child again */</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 当我们运行此程序时，会看到以下输出：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./make_zombie</span><br><span class="line">Parent PID=1013</span><br><span class="line">Child (PID=1014) exiting</span><br><span class="line"> 1013 pts/4   00:00:00 make_zombie</span><br><span class="line"> 1014 pts/4   00:00:00 make_zombie &lt;defunct&gt;       (ps命令的输出)</span><br><span class="line">After sending SIGKILL to zombie (PID=1014):</span><br><span class="line"> 1013 pts/4   00:00:00 make_zombie</span><br><span class="line"> 1014 pts/4   00:00:00 make_zombie &lt;defunct&gt;       (ps命令的输出)</span><br></pre></td></tr></table></figure> 在上面的输出中，我们看到 <code>ps(1)</code> 命令显示字符串
<code>&lt;defunct&gt;</code> 来表示一个处于僵尸状态的进程。 示例程序使用
<code>system()</code> 函数来执行其字符串参数中给出的 Shell
命令。我们将在 27.6 节详细描述 <code>system()</code>。</p>
<h3 id="linux-进程源代码指引"><strong>Linux 进程源代码指引</strong></h3>
<p>进程和线程是操作系统中的基本抽象概念。为支持进程和线程，操作系统使用了两个关键数据结构：<code>task_struct</code>
和
<code>thread_info</code>；以及大量用于管理系统中进程和线程的辅助函数。</p>
<ul>
<li><strong><code>arch/arm/include/asm/thread_info.h</code></strong>
文件声明了 <code>thread_info</code> 结构体。</li>
<li><strong><code>include/linux/sched.h</code></strong> 文件声明了
<code>task_struct</code> 结构体以及许多进程管理函数。</li>
<li><strong><code>arch/arm/include/asm/switch_to.h</code></strong>
文件为 <code>switch_to</code> 进程切换例程定义了一个特定于 ARM
架构的宏，而 <strong><code>arch/arm/kernel/entry-armv.S</code></strong>
文件实现了该宏所使用的汇编级进程切换例程 <code>__switch_to</code>。</li>
</ul>
<h3 id="linux-内核代码错误检查"><strong>Linux
内核代码错误检查</strong></h3>
<p>在 Linux 用户空间编程中，函数通常返回整数，并约定返回值
<code>0</code>
表示函数调用成功，而不同的（通常为负的）非零值用于指示不同的错误。然而，在内核编程中，许多函数可能返回指针而非整数，这使问题变得复杂，因为指针可能使用非零值来编码作为函数成功调用结果而返回的有效内存地址。</p>
<p>Linux 通过利用以下事实来解决这一挑战： 1.
有效（虚拟）地址范围的上半部分未被使用。 2.
使用负值表示错误会使得其高位比特位非零，无论它们是作为指针还是整数返回。
3. 在 <strong><code>include/linux/err.h</code></strong>
文件中提供有用的宏和内联函数，这些函数可以以跨不同硬件架构的可移植方式处理指针、整数和布尔类型的不同组合：</p>
<ul>
<li><strong><code>IS_ERR_VALUE</code>
宏</strong>：检查一个（指针或整数）值的高位范围是否非空（即，包含错误值）。</li>
<li><strong><code>ERR_PTR</code>
函数</strong>：将一个（<code>long</code>
类型）整数值转换为（<code>void *</code> 类型）指针值。</li>
<li><strong><code>PTR_ERR</code>
函数</strong>：将一个（<code>const void *</code>
类型）指针值转换为（<code>long</code> 类型）整数值。</li>
<li><strong><code>IS_ERR</code>
函数</strong>：将一个（<code>const void *</code>
类型）指针值转换为（<code>unsigned long</code> 类型）整数值，使用
<code>IS_ERR_VALUE</code>
宏检查该值的高位范围是否非空（即，包含错误值），并相应地返回一个
<code>bool</code> 值。</li>
<li><strong><code>IS_ERR_OR_NULL</code> 函数</strong>：返回一个
<code>bool</code> 值，如果 (1) 传入的（<code>const void *</code>
类型）指针值为 <code>0</code> <strong>或</strong> (2)
将其转换为（<code>unsigned long</code> 类型）整数值后使用
<code>IS_ERR_VALUE</code>
宏检查表明该值的高位范围非空（即，包含错误值），则该函数返回
<code>true</code>。</li>
<li><strong><code>ERR_CAST</code>
函数</strong>：将（<code>const void *</code>
类型）指针转换为（<code>void *</code> 类型）指针（去除
<code>const</code> 属性）。</li>
<li><strong><code>PTR_ERR_OR_ZERO</code> 函数</strong>：使用
<code>IS_ERR</code> 函数检查传入的（<code>const void *</code>
类型）指针值是否包含错误，并返回一个（<code>int</code>
类型）整数值：如果不包含错误则返回
<code>0</code>，如果包含错误则返回通过调用 <code>PTR_ERR</code>
函数获取的错误值。</li>
</ul>
<h3 id="err_ptr-和-ptr_err-宏"><strong><code>ERR_PTR</code> 和
<code>PTR_ERR</code> 宏</strong></h3>
<p>关于返回值的讨论，你现在明白了内核模块的 <code>init</code>
例程必须返回一个整数。但如果你希望返回一个指针呢？
<strong><code>ERR_PTR()</code></strong>
内联函数为我们提供了解决方案，它允许我们通过将指针类型转换为
<code>void *</code>
来返回一个伪装成整数的指针。实际上还有更好的方法：你可以使用
<strong><code>IS_ERR()</code></strong>
内联函数检查错误（该函数实质上判断值是否在 <code>[-1, -4095]</code>
范围内），通过 <strong><code>ERR_PTR()</code></strong>
内联函数将负的错误值编码到指针中，并使用对应的例程
<strong><code>PTR_ERR()</code></strong> 从指针中检索出这个错误值。</p>
<p>一个简单的例子，参见下面给出的被调用方代码。这次，我们让（示例）函数
<code>myfunc()</code> 返回一个（指向名为 <code>mystruct</code>
的结构体的）指针，而不是整数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> mystruct * <span class="title function_">myfunc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mystruct</span> *<span class="title">mys</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    mys = kzalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> mystruct), GFP_KERNEL);</span><br><span class="line">    <span class="keyword">if</span> (!mys)</span><br><span class="line">        <span class="keyword">return</span> ERR_PTR(-ENOMEM); <span class="comment">/* 示例：返回编码为指针的错误码 */</span></span><br><span class="line">    <span class="comment">/* ... 其他操作 ... */</span></span><br><span class="line">    <span class="keyword">return</span> mys; <span class="comment">/* 返回有效的指针 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="如何使用-is_err-和-ptr_err它们是什么意思"><strong>如何使用
IS_ERR 和 PTR_ERR？它们是什么意思？</strong></h3>
<p>根据内核定义，有三个宏： * <strong><code>IS_ERR</code></strong> -
用于检查。如果 <code>ptr</code> 是一个错误指针则返回非 <code>0</code>
值。否则，如果不是错误则返回 <code>0</code>。 *
<strong><code>PTR_ERR</code></strong> -
用于打印。获取指针中当前（编码的错误）值。 *
<strong><code>IS_ERR_VALUE</code></strong> - 在此有更详细的解释
(here1)。</p>
<p>我发现这些宏对于内核空间编程非常有用。用法如下 - 如果
<code>ptr</code> 是你要检查的指针，则按如下方式使用： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IS_ERR(ptr))</span><br><span class="line">     printk(<span class="string">&quot;Error here: %ld&quot;</span>, PTR_ERR(ptr)); <span class="comment">/* 打印出错误码 */</span></span><br></pre></td></tr></table></figure>
它们在内核中的代码定义如下： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IS_ERR_VALUE(x) unlikely((x) &gt;= (unsigned long)-MAX_ERRNO)</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> * __must_check <span class="title function_">ERR_PTR</span><span class="params">(<span class="type">long</span> error)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *) error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> __must_check <span class="title function_">PTR_ERR</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">long</span>) ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> __must_check <span class="title function_">IS_ERR</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IS_ERR_VALUE((<span class="type">unsigned</span> <span class="type">long</span>)ptr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">long</span> __must_check <span class="title function_">IS_ERR_OR_NULL</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !ptr || IS_ERR_VALUE((<span class="type">unsigned</span> <span class="type">long</span>)ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/09/09/oper_sys26wait/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/09/oper_sys26wait/" class="post-title-link" itemprop="url">操作系统基础 | 5.6 等待子进程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-09-10 01:03:53 / 修改时间：01:04:04" itemprop="dateCreated datePublished" datetime="2025-09-10T01:03:53+08:00">2025-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="等待子进程-waiting-on-a-child-process"><strong>等待子进程
(Waiting on a Child Process)</strong></h3>
<p>在许多由父进程创建子进程的应用程序中，父进程能够监视子进程以了解它们于何时以及如何终止是非常有用的。<code>wait()</code>
系统调用及一系列相关的系统调用提供了这个功能。</p>
<h3 id="wait-系统调用-the-wait-system-call"><strong><code>wait()</code>
系统调用 (The wait() System Call)</strong></h3>
<p><code>wait()</code> 系统调用等待调用进程的任一子进程终止，并在
<code>status</code> 参数所指向的缓冲区中返回该子进程的终止状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *status)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>返回值：</strong> 成功则返回终止子进程的进程ID
(PID)，出错则返回 -1。</p>
<p><code>wait()</code> 系统调用执行以下操作：</p>
<ol type="1">
<li>如果调用进程的（先前未被等待的）子进程中尚无一个终止，则该调用会<strong>阻塞</strong>，直到某个子进程终止为止。如果在调用时已有子进程终止，<code>wait()</code>
则立即返回。</li>
<li>如果 <code>status</code> 参数不是
<code>NULL</code>，则关于子进程如何终止的信息会通过 <code>status</code>
指针所指向的整数返回。我们将在第 26.1.3 节描述 <code>status</code>
返回的信息。</li>
<li>内核会将此子进程的 CPU 时间（第 10.7 节）和资源使用统计信息（第 36.1
节）添加到其父进程所有子进程的运行总计时长中。</li>
<li>作为其函数结果，<code>wait()</code> 返回已终止子进程的进程 ID。</li>
</ol>
<p>出错时，<code>wait()</code> 返回
-1。一个可能的错误是调用进程没有（先前未被等待的）子进程，这由
<code>errno</code> 值 <code>ECHILD</code>
指示。这意味着我们可以使用以下循环来等待调用进程的所有子进程终止：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> ((childPid = wait(<span class="literal">NULL</span>)) != <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (errno != ECHILD)    <span class="comment">/* 发生意外错误... */</span></span><br><span class="line">    errExit(<span class="string">&quot;wait&quot;</span>);  </span><br></pre></td></tr></table></figure>
<p>以下代码演示了 <code>wait()</code>
的用法。该程序创建多个子进程，每个命令行整数参数对应一个子进程。每个子进程休眠其对应命令行参数所指定的秒数，然后退出。与此同时，在创建完所有子进程后，父进程反复调用
<code>wait()</code> 来监视其子进程的终止。此循环持续直到
<code>wait()</code> 返回
-1。（这不是唯一的方法：我们也可以选择当终止的子进程数量
<code>numDead</code> 匹配创建的子进程数量时退出循环。）</p>
<p><strong>创建并等待多个子进程</strong>
<code>––––––––––––––––––––––––––––––––––––––––––––––––––––– procexec/multi_wait.c</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;curr_time.h&quot;</span>              <span class="comment">/* Declaration of currTime() */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="type">int</span> numDead;       <span class="comment">/* 目前已等待的子进程数量 */</span></span><br><span class="line">    <span class="type">pid_t</span> childPid;    <span class="comment">/* 被等待的子进程的PID */</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt; <span class="number">2</span> || <span class="built_in">strcmp</span>(argv[<span class="number">1</span>], <span class="string">&quot;--help&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        usageErr(<span class="string">&quot;%s sleep-time...\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);           <span class="comment">/* 禁用 stdout 的缓冲 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; argc; j++) &#123;    <span class="comment">/* 为每个参数创建一个子进程 */</span></span><br><span class="line">        <span class="keyword">switch</span> (fork()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">            errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:                     <span class="comment">/* 子进程：休眠一段时间后退出 */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;[%s] child %d started with PID %ld, sleeping %s &quot;</span></span><br><span class="line">                    <span class="string">&quot;seconds\n&quot;</span>, currTime(<span class="string">&quot;%T&quot;</span>), j, (<span class="type">long</span>) getpid(), argv[j]);</span><br><span class="line">            sleep(getInt(argv[j], GN_NONNEG, <span class="string">&quot;sleep-time&quot;</span>));</span><br><span class="line">            _exit(EXIT_SUCCESS);</span><br><span class="line">        <span class="keyword">default</span>:                    <span class="comment">/* 父进程：继续循环 */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numDead = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                      <span class="comment">/* 父进程等待每个子进程退出 */</span></span><br><span class="line">        childPid = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (childPid == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == ECHILD) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No more children - bye!\n&quot;</span>);</span><br><span class="line">                <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                <span class="comment">/* 发生其他（意外）错误 */</span></span><br><span class="line">                errExit(<span class="string">&quot;wait&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        numDead++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%s] wait() returned child PID %ld (numDead=%d)\n&quot;</span>,</span><br><span class="line">                currTime(<span class="string">&quot;%T&quot;</span>), (<span class="type">long</span>) childPid, numDead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的 shell 会话日志展示了我们使用该程序创建三个子进程时发生的情况：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./multi_wait 7 1 4</span><br><span class="line">[13:41:00] child 1 started with PID 21835, sleeping 7 seconds</span><br><span class="line">[13:41:00] child 2 started with PID 21836, sleeping 1 seconds</span><br><span class="line">[13:41:00] child 3 started with PID 21837, sleeping 4 seconds</span><br><span class="line">[13:41:01] wait() returned child PID 21836 (numDead=1)</span><br><span class="line">[13:41:04] wait() returned child PID 21837 (numDead=2)</span><br><span class="line">[13:41:07] wait() returned child PID 21835 (numDead=3)</span><br><span class="line">No more children - bye!</span><br></pre></td></tr></table></figure> 如果在某个特定时刻有多个子进程已终止，SUSv3 (Single UNIX
Specification, version 3) 未明确规定一系列 <code>wait()</code>
调用回收这些子进程的顺序；也就是说，顺序依赖于实现。即使在不同的 Linux
内核版本之间，该行为也有所不同。</p>
<h3
id="waitpid-系统调用-the-waitpid-system-call"><strong><code>waitpid()</code>
系统调用 (The waitpid() System Call)</strong></h3>
<p><code>wait()</code> 系统调用有一些局限性，<code>waitpid()</code>
的设计正是为了应对这些局限性：</p>
<ul>
<li>如果一个父进程创建了多个子进程，使用 <code>wait()</code>
无法等待<strong>特定某个子进程</strong>的完成；我们只能等待<strong>下一个终止</strong>的子进程。</li>
<li>如果尚无子进程终止，<code>wait()</code>
<strong>总是会阻塞</strong>。有时，更可取的是执行<strong>非阻塞的等待</strong>，这样如果尚无子进程终止，我们可以立即获得相应的指示。</li>
<li>使用
<code>wait()</code>，我们只能获知那些<strong>已经终止</strong>的子进程的信息。无法在一个子进程被信号（如
<code>SIGSTOP</code> 或
<code>SIGTTIN</code>）<strong>停止</strong>时，或在一个被停止的子进程因收到
<code>SIGCONT</code> 信号而<strong>恢复</strong>执行时得到通知。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *status, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>返回值：</strong> 成功则返回状态发生变化的子进程的进程ID
(PID)；如果指定了 <code>WNOHANG</code> 且未有子进程状态变化则返回
0；出错则返回 -1。</p>
<p><code>waitpid()</code> 的返回值和 <code>status</code> 参数与
<code>wait()</code> 相同。（关于通过 <code>status</code>
返回值的解释，请参见第 26.1.3 节）。<code>pid</code>
参数用于选择要等待的子进程，具体如下：</p>
<ul>
<li>如果 <code>pid</code> <strong>大于 0</strong>，则等待进程 ID 等于
<code>pid</code> 的那个子进程。</li>
<li>如果 <code>pid</code> <strong>等于
0</strong>，则等待与调用者（父进程）<strong>属于同一进程组</strong>的任何子进程。我们将在第
34.2 节描述进程组。</li>
<li>如果 <code>pid</code> <strong>小于
-1</strong>，则等待其<strong>进程组标识符</strong>等于 <code>pid</code>
绝对值 (<code>abs(pid)</code>) 的任何子进程。</li>
<li>如果 <code>pid</code> <strong>等于
-1</strong>，则等待<strong>任何</strong>子进程。调用
<code>wait(&amp;status)</code> 等价于调用
<code>waitpid(-1, &amp;status, 0)</code>。</li>
</ul>
<p><code>options</code> 参数是一个位掩码，可以包含（通过 OR
操作）以下零个或多个标志（所有这些标志都在 SUSv3 中指定）：</p>
<ul>
<li><strong><code>WUNTRACED</code></strong>
除了返回关于已终止子进程的信息外，还会在子进程因收到信号而<strong>停止</strong>时返回其信息。</li>
<li><strong><code>WCONTINUED</code></strong> (自 Linux 2.6.10 起)
还会在因收到 <code>SIGCONT</code>
信号而<strong>恢复</strong>执行的、之前被停止的子进程的状态信息。</li>
<li><strong><code>WNOHANG</code></strong> 如果由 <code>pid</code>
指定的子进程尚未改变状态，则立即返回而非阻塞（即执行一次“<strong>轮询</strong>”）。在这种情况下，<code>waitpid()</code>
的返回值为 <code>0</code>。如果调用进程没有符合 <code>pid</code>
指定条件的子进程，则 <code>waitpid()</code> 失败并返回错误
<code>ECHILD</code>。</li>
</ul>
<p>我们将在清单 26-3 中演示 <code>waitpid()</code> 的用法。</p>
<hr />
<p><strong>附加说明 (关于 WUNTRACED 名称的由来)：</strong></p>
<p>在其关于 <code>waitpid()</code> 的原理说明中，SUSv3 指出名称
<code>WUNTRACED</code> 是该标志源自 BSD 的一个历史产物，在 BSD
中，一个进程可以通过两种方式之一被停止：一种是由于被
<code>ptrace()</code>
系统调用<strong>跟踪</strong>的结果，另一种是被信号<strong>停止</strong>（即未被跟踪）。当一个子进程被
<code>ptrace()</code> 跟踪时，<strong>任何信号</strong>（除了
<code>SIGKILL</code>）的送达都会导致该子进程被停止，并随之向父进程发送一个
<code>SIGCHLD</code>
信号。即使子进程<strong>忽略</strong>该信号，此行为也会发生。然而，如果子进程<strong>阻塞</strong>了该信号，则它不会被停止（除非该信号是
<code>SIGSTOP</code>，它无法被阻塞）。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/09/05/intv_io/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/05/intv_io/" class="post-title-link" itemprop="url">算法笔试 | acm模式输入输出指南</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-09-05 23:18:58 / 修改时间：03:50:44" itemprop="dateCreated datePublished" datetime="2025-09-05T23:18:58+08:00">2025-09-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/interview/" itemprop="url" rel="index"><span itemprop="name">interview</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>使用c++作为笔试语言 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ====== 基础输入输出 ======</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取多个整数</span></span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入三个整数(用空格分隔): &quot;</span>;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;三个整数分别是: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除输入缓冲区</span></span><br><span class="line">    cin.<span class="built_in">ignore</span>(INT_MAX, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ====== 读取整行输入 ======</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n整行输入示例:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    string line;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入一行文本: &quot;</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;你输入的文本是: &quot;</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ====== 处理大数字 ======</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n大数字处理示例:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 32位大整数 (使用long)</span></span><br><span class="line">    <span class="type">long</span> big32;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入一个32位大整数: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; big32;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;32位大整数: &quot;</span> &lt;&lt; big32 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 64位大整数 (使用long long)</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> big64;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入一个64位大整数: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; big64;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;64位大整数: &quot;</span> &lt;&lt; big64 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    cin.<span class="built_in">ignore</span>(INT_MAX, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ====== 字符串流处理 ======</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n字符串流处理示例:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入多个用空格分隔的整数: &quot;</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);  <span class="comment">// 使用逗号作为分隔符：getline(ss, line, &#x27;,&#x27;)</span></span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="keyword">while</span> (ss &gt;&gt; num) &#123;</span><br><span class="line">        numbers.<span class="built_in">push_back</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;提取的数字: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : numbers) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ====== 多组输入数据 ======</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n多组输入数据示例:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入多行数据，每行两个整数(输入0 0结束):&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; x &gt;&gt; y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> &amp;&amp; y == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;和: &quot;</span> &lt;&lt; (x + y) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除状态并忽略剩余内容</span></span><br><span class="line">    cin.<span class="built_in">clear</span>();</span><br><span class="line">    cin.<span class="built_in">ignore</span>(INT_MAX, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ====== 文件结束处理 ======</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n文件结束处理示例(输入Ctrl+Z或Ctrl+D结束):&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入多个整数:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; eofNumbers;</span><br><span class="line">    <span class="type">int</span> input;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; input) &#123;</span><br><span class="line">        eofNumbers.<span class="built_in">push_back</span>(input);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cin.<span class="built_in">clear</span>();</span><br><span class="line">    cin.<span class="built_in">ignore</span>(INT_MAX, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入的数字: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : eofNumbers) &#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ====== 格式化输出 ======</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n格式化输出示例:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.141592653589793</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;默认输出: &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;保留4位: &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;保留10位: &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 恢复默认精度</span></span><br><span class="line">    cout.<span class="built_in">precision</span>(<span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ====== 实战示例 ======</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n实战示例: 计算一系列数字的平均值&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输入多个数字(用空格分隔): &quot;</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);</span><br><span class="line">    <span class="function">stringstream <span class="title">ss2</span><span class="params">(line)</span></span>;</span><br><span class="line">    <span class="type">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ss2 &gt;&gt; num) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;平均值: &quot;</span> &lt;&lt; (sum / count) &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;没有输入数字&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/09/03/oper_sys25exit/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/09/03/oper_sys25exit/" class="post-title-link" itemprop="url">操作系统基础 | 5.5 终止进程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-09-04 08:03:19 / 修改时间：08:03:43" itemprop="dateCreated datePublished" datetime="2025-09-04T08:03:19+08:00">2025-09-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="终止进程_exit-和-exit">终止进程：<code>_exit()</code> 和
<code>exit()</code></h3>
<p>进程可以通过两种通用方式终止。其中一种是<strong>异常终止</strong>，由接收到一个默认动作为终止进程（可能伴随核心转储）的信号引起。另一种方式是，进程可以使用
<code>_exit()</code> 系统调用进行<strong>正常终止</strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> _exit(<span class="type">int</span> status);</span><br></pre></td></tr></table></figure>
<p>传递给 <code>_exit()</code> 的 <code>status</code>
参数定义了进程的<strong>终止状态</strong>，该状态在此进程的父进程调用
<code>wait()</code> 时可用。虽然定义为 <code>int</code>
类型，但实际上只有 <code>status</code> 的低 <strong>8
位</strong>会提供给父进程。按照惯例，终止状态 <strong>0</strong>
表示进程<strong>成功完成</strong>，而<strong>非零</strong>状态值表示进程<strong>未成功终止</strong>。对于如何解释非零状态值没有固定规则；不同的应用程序遵循自己的惯例，这些惯例应在它们的文档中描述。SUSv3
规定了两个常量 <code>EXIT_SUCCESS</code> (0) 和
<code>EXIT_FAILURE</code> (1)，本书中的大多数程序都使用它们。进程总是被
<code>_exit()</code> <strong>成功终止</strong>（即 <code>_exit()</code>
从不返回）。</p>
<p>尽管任何在 0 到 255 范围内的值都可以通过 <code>_exit()</code> 的
<code>status</code> 参数传递给父进程，但指定大于 128 的值可能会在 shell
脚本中引起混淆。原因是，当一个命令被信号终止时，shell 通过将变量
<code>$?</code> 的值设置为 <strong>128 加上信号编号</strong>
来表明这一事实，而这个值与进程以相同的状态值调用 <code>_exit()</code>
所产生的值无法区分。</p>
<p>程序通常不直接调用 <code>_exit()</code>，而是调用 <code>exit()</code>
库函数，该函数在调用 <code>_exit()</code> 之前会执行各种操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure>
<p><code>exit()</code> 执行以下操作： *
调用<strong>退出处理程序</strong>（使用 <code>atexit()</code> 和
<code>on_exit()</code>
注册的函数），调用顺序与注册顺序<strong>相反</strong>。 *
<strong>刷新</strong> stdio 流缓冲区。 * 使用 <code>status</code>
中提供的值调用 <code>_exit()</code> 系统调用。</p>
<p>与 UNIX 特有的 <code>_exit()</code> 不同，<code>exit()</code>
被定义为标准 C 库的一部分；也就是说，它在每个 C 实现中都可用。</p>
<p>进程终止的另一种方式是从 <code>main()</code> 返回，无论是通过显式
<code>return</code> 语句，还是通过执行到 <code>main()</code>
函数末尾而隐式返回。执行显式的 <code>return n</code> 通常等同于调用
<code>exit(n)</code>，因为调用 <code>main()</code> 的运行时函数会在调用
<code>exit()</code> 时使用 <code>main()</code> 的返回值。</p>
<p>在一种情况下，调用 <code>exit()</code> 和从 <code>main()</code>
返回并不等效。如果在退出处理期间执行的任何步骤访问了 <code>main()</code>
的局部变量，那么从 <code>main()</code>
返回会导致<strong>未定义行为</strong>。例如，如果在调用
<code>setvbuf()</code> 或 <code>setbuf()</code>（第13.2节）时指定了
<code>main()</code> 的局部变量，就可能发生这种情况。</p>
<p>执行不指定值的 <code>return</code>，或者执行到 <code>main()</code>
函数末尾，也会导致 <code>main()</code> 的调用者调用
<code>exit()</code>，但结果会根据所支持的 C
标准版本和所使用的编译选项而有所不同： * 在 <strong>C89</strong>
中，这些情况下的行为是<strong>未定义的</strong>；程序可能以任意状态值终止。这是在
Linux 上使用 <code>gcc</code> 时的默认行为，程序的退出状态取自栈上或特定
CPU 寄存器中的某个随机值。应避免以这种方式终止程序。 *
<strong>C99</strong> 标准要求执行到主程序末尾应等同于调用
<code>exit(0)</code>。如果我们在 Linux 上使用 <code>gcc –std=c99</code>
编译程序，就会得到这种行为。</p>
<h3 id="进程终止的细节">进程终止的细节</h3>
<p>在进程的正常和异常终止期间，会发生以下操作： *
打开的<strong>文件描述符</strong>、<strong>目录流</strong>（第18.8节）、<strong>消息目录描述符</strong>（参见
<code>catopen(3)</code> 和 <code>catgets(3)</code>
手册页）和<strong>转换描述符</strong>（参见 <code>iconv_open(3)</code>
手册页）被关闭。 *
作为关闭文件描述符的后果，此进程持有的任何<strong>文件锁</strong>（第55章）都会被释放。
* 任何附加的 <strong>System V
共享内存段</strong>都会被分离（detach），并且相应每个段的
<code>shm_nattch</code> 计数器减一（参见第48.8节）。 * 对于进程已设置了
<code>semadj</code> 值的每个 <strong>System V 信号量</strong>，该
<code>semadj</code> 值会被添加到信号量值中（参见第47.8节）。 *
如果此进程是某个控制终端的<strong>控制进程</strong>，则
<strong><code>SIGHUP</code>
信号</strong>会被发送到该控制终端前台进程组中的每个进程，并且该终端与会话分离。我们将在第34.6节进一步讨论这一点。
* 调用进程中打开的任何 <strong>POSIX
命名信号量</strong>都会被关闭，就像调用了 <code>sem_close()</code>
一样。 * 调用进程中打开的任何 <strong>POSIX
消息队列</strong>都会被关闭，就像调用了 <code>mq_close()</code> 一样。 *
如果由于此进程退出导致一个进程组变为<strong>孤儿进程组</strong>，并且该组中存在任何<strong>停止的
(stopped)</strong> 进程，则该组中的所有进程都会收到一个
<code>SIGHUP</code> 信号，随后是一个 <code>SIGCONT</code>
信号。我们将在第34.7.4节进一步讨论这一点。 * 此进程使用
<code>mlock()</code> 或
<code>mlockall()</code>（第50.2节）建立的任何<strong>内存锁</strong>会被移除。
* 此进程使用 <code>mmap()</code>
建立的任何<strong>内存映射</strong>会被取消映射（unmapped）。</p>
<h3 id="退出处理程序-exit-handlers">退出处理程序 (Exit Handlers)</h3>
<p>有时，应用程序需要在进程终止时自动执行一些操作。考虑这样一个例子：一个应用程序库，如果在进程的生命周期中被使用，需要在进程退出时自动执行一些清理操作。由于该库无法控制进程何时以及如何退出，也不能强制主程序在退出前调用库特定的清理函数，因此无法保证清理一定会发生。在这种情况下，一种方法是使用<strong>退出处理程序</strong>（exit
handler）（较老的 System V 手册使用术语“程序终止例程”）。</p>
<p>退出处理程序是由程序员提供的函数，在进程生命周期的某个时间点<strong>注册</strong>，然后在进程通过
<code>exit()</code>
正常终止时被<strong>自动调用</strong>。如果程序直接调用
<code>_exit()</code>
或者进程被信号异常终止，则<strong>不会调用</strong>退出处理程序。</p>
<p>在某种程度上，进程被信号终止时不调用退出处理程序这一事实限制了它们的实用性。我们能做的最好方式是为可能发送给进程的信号建立处理程序，并让这些处理程序设置一个标志，促使主程序调用
<code>exit()</code>。（因为 <code>exit()</code>
不在表21-1（第426页）列出的异步信号安全函数中，所以我们通常不能从信号处理程序中调用它。）即使这样，也无法处理
<code>SIGKILL</code>
的情况，因为它的默认动作无法更改。这是我们应避免使用
<code>SIGKILL</code> 终止进程（如第20.2节所述）而应使用
<code>SIGTERM</code>（这是 <code>kill</code>
命令发送的默认信号）的又一个理由。</p>
<p><strong>注册退出处理程序</strong> GNU C
库提供了两种注册退出处理程序的方法。第一种方法，由 SUSv3 规定，是使用
<code>atexit()</code> 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">atexit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">void</span>))</span>;</span><br></pre></td></tr></table></figure>
<p>成功返回 0，错误返回非零值</p>
<p><code>atexit()</code> 函数将 <code>func</code>
添加到一个函数列表中，这些函数在进程终止时被调用。函数 <code>func</code>
应定义为不接收参数且不返回值，因此具有以下一般形式： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    <span class="comment">/* 执行一些操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意，<code>atexit()</code> 在出错时返回一个非零值（不一定是 -1）。</p>
<p>可以注册多个退出处理程序（甚至多次注册同一个退出处理程序）。当程序调用
<code>exit()</code>
时，这些函数按<strong>注册顺序的逆序</strong>被调用。这个顺序是合乎逻辑的，因为通常较早注册的函数执行更基本的清理类型，这些清理可能需要在后注册的函数之后执行。</p>
<p>本质上，可以在退出处理程序内部执行任何所需的操作，包括注册额外的退出处理程序（这些新处理程序会被放在待调用退出处理程序列表的头部）。但是，如果其中一个退出处理程序<strong>未能返回</strong>——要么是因为它调用了
<code>_exit()</code>，要么是因为进程被信号终止（例如，退出处理程序调用了
<code>raise()</code>）——那么剩余的退出处理程序将不会被调用。此外，<code>exit()</code>
通常会执行的剩余操作（即刷新 stdio 缓冲区）也不会执行。</p>
<p>SUSv3 规定，如果退出处理程序自身调用
<code>exit()</code>，结果是未定义的。在 Linux
上，剩余的退出处理程序会正常调用。然而，在一些系统上，这会导致所有退出处理程序再次被调用，这可能引发无限递归（直到栈溢出杀死进程）。可移植的应用程序应避免在退出处理程序内部调用
<code>exit()</code>。</p>
<p>SUSv3 要求实现允许一个进程至少能够注册 32 个退出处理程序。使用调用
<code>sysconf(_SC_ATEXIT_MAX)</code>，程序可以确定实现定义的可以注册的退出处理程序数量的上限。（但是，无法查明已经注册了多少退出处理程序。）通过将注册的退出处理程序链入一个动态分配的链表，glibc
允许注册几乎无限数量的退出处理程序。在 Linux
上，<code>sysconf(_SC_ATEXIT_MAX)</code> 返回
2,147,482,647（即最大的有符号 32
位整数）。换句话说，在达到可注册函数数量的限制之前，其他东西（例如内存不足）就会先出问题。</p>
<p>通过 <code>fork()</code>
创建的子进程<strong>继承</strong>其父进程的退出处理程序注册的一个副本。当进程执行
<code>exec()</code>
时，<strong>所有</strong>退出处理程序注册都会被<strong>移除</strong>。（这必然是如此的，因为
<code>exec()</code>
会替换掉退出处理程序的代码以及现有程序的其余代码。）</p>
<p>我们无法<strong>注销</strong>一个已经用
<code>atexit()</code>（或下面描述的
<code>on_exit()</code>）注册的退出处理程序。但是，我们可以让退出处理程序在执行其操作之前检查某个全局标志是否设置，并通过清除该标志来禁用该退出处理程序。</p>
<p>用 <code>atexit()</code>
注册的退出处理程序有<strong>几个局限性</strong>。第一个是当被调用时，退出处理程序<strong>不知道</strong>传递给
<code>exit()</code>
的状态（status）是什么。偶尔，了解这个状态可能有用；例如，我们可能希望根据进程是成功退出还是不成功退出执行不同的操作。第二个局限性是，我们无法在调用退出处理程序时为其指定<strong>参数</strong>。这种功能可能有助于定义一个根据其参数执行不同操作的退出处理程序，或者用不同的参数多次注册同一个函数。</p>
<p>为了解决这些局限性，glibc
提供了一种（非标准的）注册退出处理程序的替代方法：<code>on_exit()</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE           <span class="comment">/* 或者: #define _SVID_SOURCE */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">on_exit</span><span class="params">(<span class="type">void</span> (*func)(<span class="type">int</span>, <span class="type">void</span> *), <span class="type">void</span> *arg)</span>;</span><br></pre></td></tr></table></figure>
<p>成功返回 0，错误返回非零值</p>
<p><code>on_exit()</code> 的 <code>func</code>
参数是一个指向如下类型函数的指针： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> status, <span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="comment">/* 执行清理操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当被调用时，<code>func()</code> 被传入两个参数：提供给
<code>exit()</code> 的 <code>status</code> 参数，以及注册该函数时提供给
<code>on_exit()</code> 的 <code>arg</code>
参数的副本。虽然定义为指针类型，但 <code>arg</code>
可由程序员自由解释。它可以被用作指向某个结构的指针；同样地，通过明智地使用类型转换，它可以被视为整数或其他标量类型。</p>
<p>与 <code>atexit()</code> 一样，<code>on_exit()</code>
出错时返回非零值（不一定是 -1）。与 <code>atexit()</code> 一样，可以使用
<code>on_exit()</code> 注册多个退出处理程序。使用 <code>atexit()</code>
和 <code>on_exit()</code>
注册的函数被放在同一个列表中。如果在同一个程序中同时使用这两种方法，则退出处理程序按使用这两种方法<strong>注册顺序的逆序</strong>调用。</p>
<p>虽然比 <code>atexit()</code> 更灵活，但 <code>on_exit()</code>
在旨在可移植的程序中应<strong>避免使用</strong>，因为它不受任何标准涵盖，并且在其他
UNIX 实现上很少可用。</p>
<p><strong>示例程序</strong> 以下代码演示了使用 <code>atexit()</code> 和
<code>on_exit()</code> 注册退出处理程序。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _BSD_SOURCE     <span class="comment">/* 从 &lt;stdlib.h&gt; 获取 on_exit() 声明 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">atexitFunc1</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;atexit function 1 called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">atexitFunc2</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;atexit function 2 called\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">onexitFunc</span><span class="params">(<span class="type">int</span> exitStatus, <span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;on_exit function called: status=%d, arg=%ld\n&quot;</span>,</span><br><span class="line">                exitStatus, (<span class="type">long</span>) arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (on_exit(onexitFunc, (<span class="type">void</span> *) <span class="number">10</span>) != <span class="number">0</span>)</span><br><span class="line">        fatal(<span class="string">&quot;on_exit 1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (atexit(atexitFunc1) != <span class="number">0</span>)</span><br><span class="line">        fatal(<span class="string">&quot;atexit 1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (atexit(atexitFunc2) != <span class="number">0</span>)</span><br><span class="line">        fatal(<span class="string">&quot;atexit 2&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (on_exit(onexitFunc, (<span class="type">void</span> *) <span class="number">20</span>) != <span class="number">0</span>)</span><br><span class="line">        fatal(<span class="string">&quot;on_exit 2&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当我们运行这个程序时，会看到以下输出： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./exit_handlers</span><br><span class="line">on_exit function called: status=2, arg=20</span><br><span class="line">atexit function 2 called</span><br><span class="line">atexit function 1 called</span><br><span class="line">on_exit function called: status=2, arg=10</span><br></pre></td></tr></table></figure></p>
<p><strong>(输出顺序解释)</strong>
处理程序按<strong>注册顺序的逆序</strong>调用： * 最后注册的是
<code>on_exit</code> (arg=20)，所以最先调用。 * 然后是
<code>atexitFunc2</code>。 * 然后是 <code>atexitFunc1</code>。 *
最后是第一个注册的 <code>on_exit</code> (arg=10)。</p>
<h3 id="forkstdio-缓冲区与-_exit-之间的交互"><code>fork()</code>、stdio
缓冲区与 <code>_exit()</code> 之间的交互</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world\n&quot;</span>);</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;Ciao\n&quot;</span>, <span class="number">5</span>); <span class="comment">// 直接写入当前打开的文件描述符</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">-1</span>)</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父子进程都会执行到这里 */</span></span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上程序的输出展示了一个起初令人费解的现象。当我们直接在终端运行此程序时，会看到预期的结果：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./fork_stdio_buf</span><br><span class="line">Hello world</span><br><span class="line">Ciao</span><br></pre></td></tr></table></figure> 然而，当我们将标准输出重定向到一个文件时，却看到以下情况：
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./fork_stdio_buf &gt; a</span><br><span class="line">$ <span class="built_in">cat</span> a</span><br><span class="line">Ciao</span><br><span class="line">Hello world</span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure> 在上面的输出中，我们看到两件奇怪的事情：由
<code>printf()</code> 写入的行出现了两次，并且 <code>write()</code>
的输出先于 <code>printf()</code> 的输出出现。</p>
<p>要理解为什么用 <code>printf()</code>
写入的消息会出现两次，需要回忆一下：<strong>stdio
缓冲区是在进程的用户空间内存中维护的</strong>（参见第13.2节）。因此，这些缓冲区在
<code>fork()</code> 时会被<strong>子进程复制</strong>。</p>
<p>当标准输出指向终端时，默认是<strong>行缓冲</strong>的，因此由
<code>printf()</code>
写入的以换行符终止的字符串会<strong>立即显示</strong>。然而，当标准输出重定向到文件时，默认是<strong>块缓冲</strong>的。因此，在我们的例子中，在
<code>fork()</code> 发生时，由 <code>printf()</code>
写入的字符串仍然位于父进程的 stdio
缓冲区中，并且这个字符串被子进程复制。当父进程和子进程随后调用
<code>exit()</code> 时，它们都会<strong>刷新</strong>各自的 stdio
缓冲区副本，从而导致<strong>重复的输出</strong>。</p>
<p>我们可以通过以下方法之一来防止出现这种重复输出： * 作为解决 stdio
缓冲问题的特定方案，我们可以在调用 <code>fork()</code>
<strong>之前</strong>使用 <code>fflush()</code> 来刷新 stdio
缓冲区。或者，我们可以使用 <code>setvbuf()</code> 或
<code>setbuf()</code> 来<strong>禁用</strong> stdio 流的缓冲。 *
子进程可以调用 <code>_exit()</code> 而不是
<code>exit()</code>，这样它就不会刷新 stdio
缓冲区。这项技术阐明了一个更通用的原则：在创建子进程的应用程序中，通常<strong>只有一个进程</strong>（最常见的是父进程）应该通过
<code>exit()</code> 终止，而其他进程应该通过 <code>_exit()</code>
终止。这确保了只有一个进程调用退出处理程序并刷新 stdio
缓冲区，这通常是可取的。</p>
<p>也存在其他允许父进程和子进程都调用 <code>exit()</code>
的方法（有时是必要的）。例如，可以设计退出处理程序，使得即使从多个进程调用也能正确运行；或者让应用程序在调用
<code>fork()</code>
<strong>之后</strong>才安装退出处理程序。此外，有时我们可能确实希望所有进程在
<code>fork()</code> 后都刷新其 stdio
缓冲区。在这种情况下，我们可以选择使用 <code>exit()</code>
终止进程，或者根据情况在每个进程中使用显式的 <code>fflush()</code>
调用。</p>
<p>示例程序中 <code>write()</code> 的输出没有出现两次，是因为
<code>write()</code>
将数据<strong>直接传输到内核缓冲区</strong>，而该缓冲区在
<code>fork()</code> 期间<strong>不会被复制</strong>。</p>
<p>现在，程序输出重定向到文件时的第二个奇怪之处的原因应该很清楚了。<code>write()</code>
的输出出现在 <code>printf()</code> 的<strong>输出之前</strong>，是因为
<code>write()</code>
的输出会<strong>立即</strong>传输到内核缓冲区缓存，而
<code>printf()</code> 的输出只有在调用 <code>exit()</code> 刷新 stdio
缓冲区时才会被传输。（通常，如第13.7节所述，在同一文件上混合使用 stdio
函数和系统调用来执行 I/O 时需要小心。）</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mackz-maxw.github.io/2025/08/27/oper_sys24fork/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mackz-Maxw">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Maxw的小站">
      <meta itemprop="description" content="乘上燃犀船，还未曾去过倒悬山。">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Maxw的小站">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2025/08/27/oper_sys24fork/" class="post-title-link" itemprop="url">操作系统基础 | 5.3 信号；fork</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2025-08-28 09:15:23 / 修改时间：09:17:07" itemprop="dateCreated datePublished" datetime="2025-08-28T09:15:23+08:00">2025-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/os-basic/" itemprop="url" rel="index"><span itemprop="name">os basic</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="信号的概念">信号的概念</h3>
<p>信号（Signal）是通知进程已发生某种事件的一种机制。信号有时被描述为<strong>软件中断</strong>（software
interrupts）。信号与硬件中断类似，因为它们会中断程序的正常执行流程；在大多数情况下，无法精确预测信号何时到达。一个进程（如果它具有适当的权限）可以向另一个进程发送信号。这种用途下，信号可以作为一种同步技术，甚至作为一种原始的<strong>进程间通信（IPC）</strong>
形式。进程也可以向自己发送信号。</p>
<p>然而，传递给进程的许多信号的通常来源是<strong>内核</strong>（kernel）。导致内核为进程生成信号的事件类型包括：</p>
<ul>
<li><strong>发生硬件异常</strong>：这意味着硬件检测到故障条件并通知内核，内核随后向相关进程发送相应的信号。硬件异常的例子包括：执行格式错误的机器语言指令、除以0、或引用了无法访问的内存区域。</li>
<li><strong>用户键入了能生成信号的终端特殊字符</strong>。这些字符包括中断字符（通常是
<code>Control-C</code>）和挂起字符（通常是
<code>Control-Z</code>）。</li>
<li><strong>发生软件事件</strong>。例如：文件描述符上有输入可用、终端窗口大小改变、定时器超时、进程的CPU时间限制已超过、或该进程的一个子进程终止。</li>
</ul>
<p>每个信号都被定义为一个唯一的（小）整数，从1开始顺序编号。这些整数在
<code>&lt;signal.h&gt;</code> 头文件中用 <code>SIGxxxx</code>
形式的符号名定义。由于每个信号使用的实际数字因实现而异，因此在程序中总是使用这些符号名称。例如，当用户键入中断字符时，<code>SIGINT</code>（信号编号2）被传递给进程。</p>
<p>信号分为两大类。第一组构成了<strong>传统或标准信号</strong>（standard
signals），内核使用它们来通知进程事件。在Linux上，标准信号编号从1到31。本章我们描述标准信号。另一组信号由<strong>实时信号</strong>（realtime
signals）组成，其与标准信号的区别将在第22.8节描述。</p>
<p>信号被认为是<strong>由某个事件产生</strong>（generated）。一旦产生，信号随后会被<strong>递送</strong>（delivered）给一个进程，该进程随后会采取某些<strong>动作</strong>（action）来响应信号。在信号产生和递送之间的时间段，信号被称为<strong>处于等待状态</strong>（pending）。通常，一个等待中的信号会在进程下一次被调度运行时立即递送，如果进程已经在运行则立即递送（例如，进程向自己发送信号）。</p>
<p>然而，有时我们需要确保一段代码不会因信号的递送而中断。为此，我们可以将一个信号添加到进程的<strong>信号掩码</strong>（signal
mask）中——这是一组当前<strong>被阻塞</strong>（blocked）递送的信号。如果一个信号在阻塞状态下产生，它将保持等待状态，直到后来被<strong>解除阻塞</strong>（unblocked）（从信号掩码中移除）。各种系统调用允许进程向其信号掩码中添加和移除信号。</p>
<p>根据信号的不同，信号被递送时，进程会执行以下<strong>默认动作</strong>（default
actions）之一：</p>
<ul>
<li><strong>忽略信号</strong>（Ignored）：即信号被内核丢弃，对进程没有影响。（进程甚至不知道它发生了。）</li>
<li><strong>进程被终止</strong>（Terminated）（杀死）。这有时被称为异常进程终止，与进程使用
<code>exit()</code> 终止的正常进程终止相对。</li>
<li><strong>生成核心转储文件</strong>（Core dump
file）且进程被终止。核心转储文件包含进程虚拟内存的一个映像，可以将其加载到调试器中，以检查进程终止时的状态。</li>
<li><strong>进程被停止</strong>（Stopped）——进程的执行被暂停。</li>
<li><strong>进程被恢复</strong>（Resumed）执行——在之前被停止后恢复执行。</li>
</ul>
<p>程序可以改变信号递送时发生的动作，而不是接受特定信号的默认动作。这被称为设置信号的<strong>处置方式</strong>（disposition）。程序可以为信号设置以下处置方式之一：</p>
<ul>
<li>发生<strong>默认动作</strong>。这对于撤销之前将信号处置方式更改为非默认值的操作很有用。</li>
<li><strong>忽略</strong>信号。这对于那些默认动作是终止进程的信号很有用。</li>
<li>执行一个<strong>信号处理程序</strong>（signal
handler）。信号处理程序是由程序员编写的函数，它执行适当的任务以响应信号的递送。例如，shell
有一个用于 <code>SIGINT</code> 信号（由中断字符 <code>Control-C</code>
产生）的处理程序，该处理程序使其停止当前正在做的事情并将控制权返回给主输入循环，从而再次向用户显示
shell 提示符（用户按下 <code>Control-C</code>
-shell中断当前处理-用户可以再次在shell中输入指令了）。通知内核应调用某个处理函数通常被称为<strong>安装</strong>（installing）或<strong>建立</strong>（establishing）一个信号处理程序。当信号处理程序因信号递送而被调用时，我们说信号已被<strong>处理</strong>（handled）或，同义词，被<strong>捕获</strong>（caught）。
<em>注意：不可能将信号的处置方式设置为终止或转储核心（除非其中一个是该信号的默认处置方式）。最接近这一点的是为该信号安装一个处理程序，然后该处理程序调用
<code>exit()</code> 或 <code>abort()</code>。<code>abort()</code>
函数（第21.2.2节）为进程生成一个 <code>SIGABRT</code>
信号，这会导致其转储核心并终止。</em></li>
</ul>
<p>Linux特有的 <code>/proc/PID/status</code>
文件包含各种位掩码字段，可以检查这些字段以确定进程对信号的处理情况。位掩码以十六进制数显示，最低有效位代表信号1，左边下一位代表信号2，依此类推。这些字段是：
* <code>SigPnd</code>（线程内等待信号，per-thread pending signals） *
<code>ShdPnd</code>（进程范围内等待信号，process-wide pending
signals；自Linux 2.6起） * <code>SigBlk</code>（阻塞信号，blocked
signals） * <code>SigIgn</code>（忽略信号，ignored signals） *
<code>SigCgt</code>（捕获信号，caught signals）。
（当我们第33.2节描述多线程进程中的信号处理时，<code>SigPnd</code> 和
<code>ShdPnd</code> 字段之间的区别将变得清晰。）同样的信息也可以使用
<code>ps(1)</code> 命令的各种选项来获取。</p>
<h3 id="fork-exit-wait-和-execve-概述"><code>fork()</code>,
<code>exit()</code>, <code>wait()</code> 和 <code>execve()</code>
概述</h3>
<ul>
<li><p><strong><code>fork()</code></strong> <code>fork()</code>
系统调用允许一个进程（称为<strong>父进程</strong>）创建一个新的进程（称为<strong>子进程</strong>）。这是通过使新的子进程成为父进程的（近乎）完全副本来实现的：子进程获取父进程栈、数据、堆和文本段（第6.3节）的副本。“Fork”一词源于我们可以将父进程视为<strong>分裂
(forking)</strong> 以产生自身的两个副本这一构想。</p></li>
<li><p><strong><code>exit(status)</code></strong> <code>exit()</code>
库函数<strong>终止</strong>一个进程，使该进程使用的所有资源（内存、打开的文件描述符等）可供内核后续重新分配。<code>status</code>
参数是一个整数，用于确定进程的<strong>终止状态</strong>。通过
<code>wait()</code> 系统调用，父进程可以检索此状态。 <code>exit()</code>
库函数是基于 <code>_exit()</code>
系统调用构建的。在第25章，我们将解释这两个接口之间的区别。在此我们只需注意，在
<code>fork()</code>
之后，通常只有父进程和子进程中的<strong>一个</strong>通过调用
<code>exit()</code> 终止；<strong>另一个</strong>进程应使用
<code>_exit()</code> 终止。</p></li>
<li><p><strong><code>wait(&amp;status)</code></strong>
<code>wait(&amp;status)</code>
系统调用有两个目的。首先，如果该进程的某个子进程尚未调用
<code>exit()</code> 终止，那么 <code>wait()</code>
会<strong>暂停</strong>该进程的执行，直到它的一个子进程终止为止。其次，子进程的终止状态通过
<code>wait()</code> 的 <code>status</code>
参数<strong>返回</strong>。</p></li>
<li><p><strong><code>execve(pathname, argv, envp)</code></strong>
<code>execve(pathname, argv, envp)</code>
系统调用将一个新的程序（<code>pathname</code>，带有参数列表
<code>argv</code> 和环境列表
<code>envp</code>）<strong>加载</strong>到一个进程的内存中。现有的程序文本被丢弃，并为新程序<strong>全新创建</strong>栈、数据和堆段。此操作通常被称为
<strong>execing</strong> 一个新程序。后面我们会看到，有几个库函数是基于
<code>execve()</code>
构建的，每个函数都在编程接口上提供了有用的变体。当我们不关心这些接口变体时，我们遵循通用惯例，将这些调用统称为
<code>exec()</code>，但请注意，并没有叫这个名字的系统调用或库函数。</p></li>
</ul>
<p><strong>与其他系统的对比：</strong> 一些其他操作系统将
<code>fork()</code> 和 <code>exec()</code>
的功能组合到单个操作中——即所谓的
<strong>spawn</strong>——该操作创建一个新进程然后执行指定的程序。相比之下，UNIX
的方法通常更简单、更优雅。将这两个步骤分开使得 API
更简单（<code>fork()</code>
系统调用不需要参数），并且允许程序在两个步骤之间执行的操作具有极大的灵活性。此外，只进行
<code>fork()</code> 而不接着执行 <code>exec()</code> 通常也很有用。</p>
<p>SUSv3 规定了可选的 <code>posix_spawn()</code> 函数，它结合了
<code>fork()</code> 和 <code>exec()</code> 的效果。此函数以及 SUSv3
规定的几个相关 API 已在 glibc 中为 Linux 实现。SUSv3 规定
<code>posix_spawn()</code>
是为了允许为那些不提供交换设施或内存管理单元（这在许多嵌入式系统中很典型）的硬件架构编写可移植应用程序。在此类架构上，传统的
<code>fork()</code> 难以或无法实现。</p>
<p><strong>协同工作概述：</strong> <code>fork()</code>,
<code>exit()</code>, <code>wait()</code>, 和 <code>execve()</code>
通常是如何一起使用的。（shell
持续执行一个循环，该循环读取命令、对其进行各种处理，然后 fork
一个子进程来 exec 该命令。）</p>
<h3 id="创建新进程fork">创建新进程：<code>fork()</code></h3>
<p><code>fork()</code>
系统调用创建一个新的进程，即<strong>子进程</strong>，它是调用进程，即<strong>父进程</strong>的一个几乎完全相同的副本。</p>
<p>理解 <code>fork()</code>
的关键在于认识到，在它完成工作后，存在<strong>两个进程</strong>，并且在每个进程中，执行都从
<code>fork()</code>
<strong>返回的地方继续</strong>。两个进程执行相同的程序代码，但它们拥有独立的栈、数据和堆段副本。子进程的栈、数据和堆段最初是父进程内存相应部分的精确副本。在
<code>fork()</code>
之后，每个进程都可以修改其栈、数据和堆段中的变量，而<strong>不会影响另一个进程</strong>。</p>
<p>在程序代码中，我们可以通过 <code>fork()</code>
的返回值来区分这两个进程：</p>
<ul>
<li>对于<strong>父进程</strong>，<code>fork()</code>
返回新创建子进程的<strong>进程ID
(PID)</strong>。这很有用，因为父进程可能会创建多个子进程，并因此需要（通过
<code>wait()</code> 或其相关函数）跟踪它们。</li>
<li>对于<strong>子进程</strong>，<code>fork()</code> 返回
<strong>0</strong>。</li>
<li>如果无法创建新进程，<code>fork()</code> 返回
<strong>-1</strong>。失败的可能原因包括：已达到允许该（真实）用户ID创建的进程数的资源限制（<code>RLIMIT_NPROC</code>，在第36.3节描述），或者已达到系统范围内可创建进程数的上限。</li>
</ul>
<p>必要时，子进程可以使用 <code>getpid()</code> 获取自身的进程ID，使用
<code>getppid()</code> 获取其父进程的进程ID。</p>
<p>调用 <code>fork()</code> 时有时会使用以下惯用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pid_t</span> childPid; <span class="comment">/* 在父进程中用于记录成功 fork() 后的子进程 PID */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (childPid = fork()) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">/* fork() 失败 */</span></span><br><span class="line">    <span class="comment">/* 处理错误 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">/* 成功 fork() 后的子进程进入此处 */</span></span><br><span class="line">    <span class="comment">/* 执行子进程特定的操作 */</span></span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 或 exit()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">/* 成功 fork() 后的父进程进入此处 */</span></span><br><span class="line">    <span class="comment">/* 执行父进程特定的操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重要的是要认识到，在 <code>fork()</code>
之后，<strong>无法确定接下来是哪个进程被调度使用CPU</strong>。在编写不佳的程序中，这种不确定性可能导致称为<strong>竞争条件
(race conditions)</strong> 的错误，我们将在第24.4节进一步描述。</p>
<p>代码清单24-1演示了 <code>fork()</code>
的用法。该程序创建一个子进程，修改它在 <code>fork()</code>
期间继承的全局变量和自动变量的副本。在程序中（由父进程执行的代码中）使用
<code>sleep()</code>，是为了让子进程能在父进程之前被调度到CPU上，从而使子进程可以在父进程继续执行之前完成其工作并终止。使用
<code>sleep()</code>
这种方式并<strong>不是</strong>保证此结果的万无一失的方法；我们将在第24.5节探讨一种更好的方法。
<strong>代码清单 24-1: 使用 fork()</strong> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tlpi_hdr.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> idata = <span class="number">111</span>;             <span class="comment">/* 分配在数据段 (data segment) */</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> istack = <span class="number">222</span>;               <span class="comment">/* 分配在栈段 (stack segment) */</span></span><br><span class="line">    <span class="type">pid_t</span> childPid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (childPid = fork()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">        errExit(<span class="string">&quot;fork&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:                         <span class="comment">/* 子进程分支 */</span></span><br><span class="line">        idata *= <span class="number">3</span>;                 <span class="comment">/* 修改继承的变量副本 */</span></span><br><span class="line">        istack *= <span class="number">3</span>;                <span class="comment">/* 修改继承的变量副本 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:                        <span class="comment">/* 父进程分支 */</span></span><br><span class="line">        sleep(<span class="number">3</span>);                   <span class="comment">/* 给子进程一个执行的机会 */</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 父进程和子进程都会执行到这里 */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID=%ld %s idata=%d istack=%d\n&quot;</span>, (<span class="type">long</span>) getpid(),</span><br><span class="line">            (childPid == <span class="number">0</span>) ? <span class="string">&quot;(child) &quot;</span> : <span class="string">&quot;(parent)&quot;</span>, idata, istack);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
当我们运行清单24-1中的程序时，会看到以下输出： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./t_fork</span><br><span class="line">PID=28557 (child)  idata=333 istack=666</span><br><span class="line">PID=28556 (parent) idata=111 istack=222</span><br></pre></td></tr></table></figure>
上面的输出证明，子进程在 <code>fork()</code>
时获得了栈段和数据段的<strong>自有副本</strong>，并且它能够修改这些段中的变量而<strong>不影响父进程</strong>。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
  <div class="languages">
    <label class="lang-select-label">
      <i class="fa fa-language"></i>
      <span>简体中文</span>
      <i class="fa fa-angle-up" aria-hidden="true"></i>
    </label>
    <select class="lang-select" data-canonical="" aria-label="选择语言">
      
        <option value="zh-CN" data-href="/index.html" selected="">
          简体中文
        </option>
      
        <option value="en" data-href="/en/index.html" selected="">
          English
        </option>
      
    </select>
  </div>

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Mackz-Maxw</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>



</body>
</html>
